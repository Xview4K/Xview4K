//--------------------------------------------------------------------
// Microsoft OLE DB Test
//
// Copyright 1995-2000 Microsoft Corporation.
//
// @doc 
//
// @module ICMDPRPTS.CPP | The test module for ICommandProperties
//
 
#include "modstandard.hpp"	// Standard headers, precompiled in modcore.cpp
#define  DBINITCONSTANTS	// Must be defined to initialize constants in OLEDB.H
#define  INITGUID
#include "icmdprpt.h"		// Testcase's header
#include "extralib.h"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Module Values
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// {{ TCW_MODULE_GLOBALS
DECLARE_MODULE_CLSID = { 0xce185360, 0x0d97, 0x11cf, { 0xac, 0x3b, 0x00, 0xaa, 0x00, 0x4a, 0x99, 0xe0 }};
DECLARE_MODULE_NAME("ICommandProperties");
DECLARE_MODULE_OWNER("Microsoft");
DECLARE_MODULE_DESCRIP("Test module for ICommandProperties");
DECLARE_MODULE_VERSION(835645043);
// }}

//--------------------------------------------------------------------------------
//  The globals for this test module
//--------------------------------------------------------------------------------


//The global pointer for a CTable object so that a table will not be created and dropped
//got each test case
CTable *g_pCTable=NULL;

//A pointer to IDBCreateCommand pointer
IDBCreateCommand *g_pIDBCreateCommand=NULL;

//Provider Name
WCHAR g_pwszProviderName[100] = L"";

//Extra rowset PropSets 
ULONG g_ulExtraROWProp=0;
ULONG g_ulPropertyCount=0;

//Global for &DBPROPERTYSUPPORT attributes
struct DBPrptAttr
{
	const GUID			*pGuidPropertySet;	//The GUID of the property set
	DBPROPID			dwPropertyID;		//The ID of the property
	BOOL				fSupported;			//Whether the property is supported
	BOOL				fSettable;			//Whether the property is settable
	BOOL				fColumn;			//Whether the property is applicable to a column
	BOOL				fColumnOK;			//Applies to all columns
	VARTYPE				vtType;				//The type of the property
	VARIANT				vDefault;			//The default of the property
	WCHAR				wszDescription[DESCRIPTION_SIZE];	//The description of the property
}g_rgDBProperties[]={
//                                                                                                       
//pGuidPropertySet			dwPropertyID						fSupported	fSettable   fColumn		fColumnOK	vtType		vDefault				Description           
//================			============						==========	=========	=======		======		========				============     
&DBPROPSET_COLUMN,			DBPROP_COL_AUTOINCREMENT,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Autoincrement\0",
&DBPROPSET_COLUMN,			DBPROP_COL_DEFAULT,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Default\0",
&DBPROPSET_COLUMN,			DBPROP_COL_DESCRIPTION,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},  	L"Description\0",
&DBPROPSET_COLUMN,			DBPROP_COL_FIXEDLENGTH,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Fixed Length\0",
&DBPROPSET_COLUMN,			DBPROP_COL_INCREMENT,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Increment\0",
&DBPROPSET_COLUMN,			DBPROP_COL_ISLONG,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Is Long\0",
&DBPROPSET_COLUMN,			DBPROP_COL_NULLABLE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Nullable\0",
&DBPROPSET_COLUMN,			DBPROP_COL_PRIMARYKEY,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Primary Key\0",
&DBPROPSET_COLUMN,			DBPROP_COL_SEED,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Seed\0",
&DBPROPSET_COLUMN,			DBPROP_COL_UNIQUE,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Unique\0",
&DBPROPSET_COLUMN,			DBPROP_COLUMNLCID,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Column LCID\0",
&DBPROPSET_DATASOURCE,		DBPROP_CURRENTCATALOG,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Current Catalog\0",
&DBPROPSET_DATASOURCE,		DBPROP_MULTIPLECONNECTIONS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Multiple Connections\0",
&DBPROPSET_DATASOURCE,		DBPROP_RESETDATASOURCE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Reset Datasource\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_ACTIVESESSIONS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Active Sessions\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_ALTERCOLUMN,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Alter Column Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_ASYNCTXNABORT,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Asynchable Abort\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_ASYNCTXNCOMMIT,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Asynchable Commit\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_BYREFACCESSORS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Pass By Ref Accessors\0", 
&DBPROPSET_DATASOURCEINFO,	DBPROP_CATALOGLOCATION,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Catalog Location\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_CATALOGTERM,		            FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},  	L"Catalog Term\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_CATALOGUSAGE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Catalog Usage\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_COLUMNDEFINITION,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Column Definition\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_COMSERVICES,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"COM Service Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_CONCATNULLBEHAVIOR,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"NULL Concatenation Behavior\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_CONNECTIONSTATUS,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Connection Status\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DATASOURCENAME,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},  	L"Data Source Name\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DATASOURCEREADONLY,			FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Read-Only Data Source\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DATASOURCE_TYPE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Data Source Type\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DBMSNAME,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"DBMS Name\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DBMSVER,						FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"DBMS Version\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_DSOTHREADMODEL,	            FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Data Source Object Threading Model\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_GENERATEURL,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"URL Generation\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_GROUPBY,						FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"GROUP BY Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_HETEROGENEOUSTABLES,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Heterogeneous Table Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_IDENTIFIERCASE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Identifier Case Sensitivity\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MAXINDEXSIZE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Index Size\0",	
&DBPROPSET_DATASOURCEINFO,	DBPROP_MAXOPENCHAPTERS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Open Chapters\0",	
&DBPROPSET_DATASOURCEINFO,	DBPROP_MAXROWSIZE,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Row Size\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MAXROWSIZEINCLUDESBLOB,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Maximum Row Size Includes BLOB\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MAXTABLESINSELECT,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Tables in SELECT\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MULTIPLEPARAMSETS,			FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Multiple Parameter Sets\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MULTIPLERESULTS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Multiple Results\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MULTIPLESTORAGEOBJECTS,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Multiple Storage Objects\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_MULTITABLEUPDATE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Multi-Table Update\0",  
&DBPROPSET_DATASOURCEINFO,	DBPROP_NULLCOLLATION,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"NULL Collation Order\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_OLEOBJECTS,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"OLE Object Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_OPENROWSETSUPPORT,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Open Rowset Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_ORDERBYCOLUMNSINSELECT,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ORDER BY Columns in Select List\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_OUTPUTPARAMETERAVAILABILITY,	FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Output Parameter Availability\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PERSISTENTIDTYPE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Persistent ID Type\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PREPAREABORTBEHAVIOR,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Prepare Abort Behavior\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PREPARECOMMITBEHAVIOR,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Prepare Commit Behavior\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROCEDURETERM,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Procedure Term\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROVIDERFRIENDLYNAME,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Provider Friendly Name\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROVIDERFILENAME,			FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Provider Name\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROVIDERMEMORY,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Provider Owned Memory\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROVIDEROLEDBVER,			FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},  	L"OLE DB Version\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_PROVIDERVER,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Provider Version\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_QUOTEDIDENTIFIERCASE,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Quoted Identifier Sensitivity\0", 
&DBPROPSET_DATASOURCEINFO,	DBPROP_ROWSETCONVERSIONSONCOMMAND,	FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Rowset Conversions on Command\0", 
&DBPROPSET_DATASOURCEINFO,	DBPROP_SCHEMATERM,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Schema Term\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SCHEMAUSAGE,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Schema Usage\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SERVERNAME,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Server Name\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SQLSUPPORT,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"SQL Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_STRUCTUREDSTORAGE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Structured Storage\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SUBQUERIES,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Subquery Support\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SUPPORTEDTXNDDL,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Transaction DDL\0", 
&DBPROPSET_DATASOURCEINFO,	DBPROP_SUPPORTEDTXNISOLEVELS,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Isolation Levels\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_SUPPORTEDTXNISORETAIN,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Isolation Retention\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_TABLETERM,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Table Term\0",
&DBPROPSET_DATASOURCEINFO,	DBPROP_USERNAME,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"User Name\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_AUTOUPDATE,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Auto-Update\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_CLUSTERED,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Clustered\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_FILLFACTOR,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Fill Factor\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_INITIALSIZE,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Initial Size\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_NULLCOLLATION,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"NULL Collation\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_NULLS,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"NULL Keys\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_PRIMARYKEY,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Primary Key\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_SORTBOOKMARKS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Sort Bookmarks\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_TEMPINDEX,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Temporary Index\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_TYPE,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Index Type\0",
&DBPROPSET_INDEX,			DBPROP_INDEX_UNIQUE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Unique\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_CACHE_AUTHINFO,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Cache Authentication\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_ENCRYPT_PASSWORD,		FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Encrypt Password\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_INTEGRATED,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Integrated Security\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_MASK_PASSWORD,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Mask Password\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_PASSWORD,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Password\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_PERSIST_ENCRYPTED,		FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Persist Encrypted\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO,	FALSE,	TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Persist Security Info\0",
&DBPROPSET_DBINIT,			DBPROP_AUTH_USERID,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"User ID\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_ASYNCH,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Asynchronous Processing\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_BINDFLAGS,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Bind Flags\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_CATALOG,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Initial Catalog\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_DATASOURCE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Data Source\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_GENERALTIMEOUT,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"General Timeout\0",
#ifdef _WIN64
&DBPROPSET_DBINIT,			DBPROP_INIT_HWND,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I8,		{VT_EMPTY,0,0,0,0},		L"Window Handle\0",
#else
&DBPROPSET_DBINIT,			DBPROP_INIT_HWND,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Window Handle\0",
#endif
&DBPROPSET_DBINIT,			DBPROP_INIT_IMPERSONATION_LEVEL,	FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Impersonation Level\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_LCID,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Locale Identifier\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_LOCATION,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Location\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_LOCKOWNER,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Lock Owner\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_MODE,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Mode\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_OLEDBSERVICES,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"OLE DB Services\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_PROMPT,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I2,		{VT_EMPTY,0,0,0,0},		L"Prompt\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_PROTECTION_LEVEL,		FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Protection Level\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_PROVIDERSTRING,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Extended Properties\0",
&DBPROPSET_DBINIT,			DBPROP_INIT_TIMEOUT,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Connect Timeout\0",
&DBPROPSET_ROWSET,			DBPROP_ABORTPRESERVE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Preserve on Abort\0",
&DBPROPSET_ROWSET,			DBPROP_ACCESSORDER,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Access Order\0",
&DBPROPSET_ROWSET,			DBPROP_APPENDONLY,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Append-Only Rowset\0",
&DBPROPSET_ROWSET,			DBPROP_BLOCKINGSTORAGEOBJECTS,		FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Blocking Storage Objects\0",
&DBPROPSET_ROWSET,			DBPROP_BOOKMARKINFO,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Bookmark Information\0", 
&DBPROPSET_ROWSET,			DBPROP_BOOKMARKS,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Use Bookmarks\0", 
&DBPROPSET_ROWSET,			DBPROP_BOOKMARKSKIPPED,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Skip Deleted Bookmarks\0",
&DBPROPSET_ROWSET,			DBPROP_BOOKMARKTYPE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Bookmark Type\0",
&DBPROPSET_ROWSET,			DBPROP_CACHEDEFERRED,				FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Cache Deferred Columns\0",
&DBPROPSET_ROWSET,			DBPROP_CANFETCHBACKWARDS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Fetch Backwards\0",
&DBPROPSET_ROWSET,			DBPROP_CANHOLDROWS,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Hold Rows\0",
&DBPROPSET_ROWSET,			DBPROP_CANSCROLLBACKWARDS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Scroll Backwards\0",
&DBPROPSET_ROWSET,			DBPROP_CHANGEINSERTEDROWS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Change Inserted Rows\0",
&DBPROPSET_ROWSET,			DBPROP_CLIENTCURSOR,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Client Cursor\0",
&DBPROPSET_ROWSET,			DBPROP_COLUMNRESTRICT,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Column Privileges\0",
&DBPROPSET_ROWSET,			DBPROP_COMMANDTIMEOUT,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Command Time Out\0",
&DBPROPSET_ROWSET,			DBPROP_COMMITPRESERVE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Preserve on Commit\0",
&DBPROPSET_ROWSET,			DBPROP_DEFERRED,					FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Defer Column\0",
&DBPROPSET_ROWSET,			DBPROP_DELAYSTORAGEOBJECTS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Delay Storage Object Updates\0",
&DBPROPSET_ROWSET,			DBPROP_FINDCOMPAREOPS,				FALSE,		TRUE,		TRUE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Find Operations\0",
&DBPROPSET_ROWSET,			DBPROP_HIDDENCOLUMNS,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Hidden Columns\0",
&DBPROPSET_ROWSET,			DBPROP_IMMOBILEROWS,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Immobile Rows\0",
&DBPROPSET_ROWSET,			DBPROP_LITERALBOOKMARKS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"Literal Bookmarks\0",
&DBPROPSET_ROWSET,			DBPROP_LITERALIDENTITY,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Literal Row Identity\0",	
&DBPROPSET_ROWSET,			DBPROP_LOCKMODE,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Lock Mode\0",	
&DBPROPSET_ROWSET,			DBPROP_MAXOPENROWS,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Open Rows\0",
&DBPROPSET_ROWSET,			DBPROP_MAXPENDINGROWS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},  	L"Maximum Pending Rows\0",
&DBPROPSET_ROWSET,			DBPROP_MAXROWS,						FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Rows\0",
&DBPROPSET_ROWSET,			DBPROP_MAYWRITECOLUMN,				FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Column Writable\0",
&DBPROPSET_ROWSET,			DBPROP_MEMORYUSAGE,					FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Memory Usage\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFICATIONGRANULARITY,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Notification Granularity\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFICATIONPHASES,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Notification Phases\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYCOLUMNSET,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Column Set Notification\0", 
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWDELETE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Delete Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWFIRSTCHANGE,		FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row First Change Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWINSERT,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Insert Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWRESYNCH,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Resynchronization Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWSETCHANGED,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Rowset Change Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE,	FALSE,	FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Rowset Fetch Position Change Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWSETRELEASE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Rowset Release Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWUNDOCHANGE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Undo Change Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWUNDODELETE,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Undo Delete Notification\0",
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWUNDOINSERT,			FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Undo Insert Notification\0",			
&DBPROPSET_ROWSET,			DBPROP_NOTIFYROWUPDATE,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Update Notification\0",
&DBPROPSET_ROWSET,			DBPROP_ORDEREDBOOKMARKS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Bookmarks Ordered\0",  
&DBPROPSET_ROWSET,			DBPROP_OTHERINSERT,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Others' Inserts Visible\0",
&DBPROPSET_ROWSET,			DBPROP_OTHERUPDATEDELETE,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Others' Changes Visible\0",
&DBPROPSET_ROWSET,			DBPROP_OWNINSERT,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Own Inserts Visible\0", 
&DBPROPSET_ROWSET,			DBPROP_OWNUPDATEDELETE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Own Changes Visible\0",
&DBPROPSET_ROWSET,			DBPROP_QUICKRESTART,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Quick Restart\0",
&DBPROPSET_ROWSET,			DBPROP_REENTRANTEVENTS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Reentrant Events\0",
&DBPROPSET_ROWSET,			DBPROP_REMOVEDELETED,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Remove Deleted Rows\0",
&DBPROPSET_ROWSET,			DBPROP_REPORTMULTIPLECHANGES,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Report Multiple Changes\0",
&DBPROPSET_ROWSET,			DBPROP_RETURNPENDINGINSERTS,		FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Return Pending Inserts\0",
&DBPROPSET_ROWSET,			DBPROP_ROW_BULKOPS,					FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Bulk Operations\0",
&DBPROPSET_ROWSET,			DBPROP_ROWRESTRICT,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Row Privileges\0",
&DBPROPSET_ROWSET,			DBPROP_ROWSET_ASYNCH,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Asynchronous Rowset Processing\0",
&DBPROPSET_ROWSET,			DBPROP_ROWTHREADMODEL,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Row Threading Model\0",
&DBPROPSET_ROWSET,			DBPROP_SERVERCURSOR,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Server Cursor\0",
&DBPROPSET_ROWSET,			DBPROP_SERVERDATAONINSERT,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Server Data on Insert\0",
&DBPROPSET_ROWSET,			DBPROP_STORAGEFLAGS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Storage Flags\0",
&DBPROPSET_ROWSET,			DBPROP_STRONGIDENTITY,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Strong Row Identity\0",
&DBPROPSET_ROWSET,			DBPROP_TRANSACTEDOBJECT,			FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Objects Transacted\0",
&DBPROPSET_ROWSET,			DBPROP_UNIQUEROWS,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Unique Rows\0",
&DBPROPSET_ROWSET,			DBPROP_UPDATABILITY,				FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Updatability\0",			
&DBPROPSET_ROWSET,			DBPROP_IAccessor,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IAccessor\0",
&DBPROPSET_ROWSET,			DBPROP_IBindResource,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IBindResource\0",
&DBPROPSET_ROWSET,			DBPROP_IChapteredRowset,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IChapteredRowset\0",
&DBPROPSET_ROWSET,			DBPROP_IColumnsInfo,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IColumnsInfo\0",
&DBPROPSET_ROWSET,			DBPROP_IColumnsInfo2,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IColumnsInfo2\0",
&DBPROPSET_ROWSET,			DBPROP_IColumnsRowset,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IColumnsRowset\0",
&DBPROPSET_ROWSET,			DBPROP_IConnectionPointContainer,	FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IConnectionPointContainer\0",
&DBPROPSET_ROWSET,			DBPROP_IConvertType,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IConvertType\0",
&DBPROPSET_ROWSET,			DBPROP_ICreateRow,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ICreateRow\0",
&DBPROPSET_ROWSET,			DBPROP_IDBAsynchStatus,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IDBAsynchStatus\0",
&DBPROPSET_ROWSET,			DBPROP_IDBBinderProperties,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IDBBinderProperties\0",
&DBPROPSET_ROWSET,			DBPROP_IGetRow,						FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IGetRow\0",
&DBPROPSET_ROWSET,			DBPROP_IGetSession,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IGetSession\0",
&DBPROPSET_ROWSET,			DBPROP_IGetSourceRow,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IGetSourceRow\0",
&DBPROPSET_ROWSET,			DBPROP_IMultipleResults,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IMultipleResults\0",
&DBPROPSET_ROWSET,			DBPROP_IParentRowset,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IParentRowset\0",
&DBPROPSET_ROWSET,			DBPROP_IRegisterProvider,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRegisterProvider\0",
&DBPROPSET_ROWSET,			DBPROP_IRow,						FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRow\0",
&DBPROPSET_ROWSET,			DBPROP_IRowChange,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowChange\0",
&DBPROPSET_ROWSET,			DBPROP_IRowSchemaChange,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowSchemaChange\0",
&DBPROPSET_ROWSET,			DBPROP_IRowset,						FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowset\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetChange,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetChange\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetCurrentIndex,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetCurrentIndex\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetFind,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetFind\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetIdentity,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetIdentity\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetIndex,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetIndex\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetInfo,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetInfo\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetLocate,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"IRowsetLocate\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetRefresh,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},  	L"IRowsetRefresh\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetResynch,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetResynch\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetScroll,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetScroll\0", 
&DBPROPSET_ROWSET,			DBPROP_IRowsetUpdate,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetUpdate\0",
&DBPROPSET_ROWSET,			DBPROP_IRowsetView,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetView\0",
&DBPROPSET_ROWSET,			DBPROP_IScopedOperations,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IScopedOperations\0",
&DBPROPSET_ROWSET,			DBPROP_ISupportErrorInfo,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ISupportErrorInfo\0",
&DBPROPSET_ROWSET,			DBPROP_ILockBytes,					FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ILockBytes\0",
&DBPROPSET_ROWSET,			DBPROP_ISequentialStream,			FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ISequentialStream\0",
&DBPROPSET_ROWSET,			DBPROP_IStorage,					FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IStorage\0",
&DBPROPSET_ROWSET,			DBPROP_IStream,						FALSE,		TRUE,		TRUE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IStream\0",
&DBPROPSET_SESSION,			DBPROP_SESS_AUTOCOMMITISOLEVELS,	FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Autocommit Isolation Levels\0",
&DBPROPSET_TABLE,			DBPROP_TBL_TEMPTABLE,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Temporary Table\0",
&DBPROPSET_TRUSTEE,			DBPROP_TRUSTEE_USERNAME,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Trustee User Name\0",
&DBPROPSET_TRUSTEE,			DBPROP_TRUSTEE_AUTHENTICATION,		FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Trustee Authentication\0",
&DBPROPSET_TRUSTEE,			DBPROP_TRUSTEE_NEWAUTHENTICATION,	FALSE,		TRUE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"New Trustee Authentication\0",
&DBPROPSET_VIEW,			DBPROP_FILTERCOMPAREOPS,			FALSE,		TRUE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Filter Operations\0",
&DBPROPSET_VIEW,			DBPROP_IAccessor,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IAccessor\0",
&DBPROPSET_VIEW,			DBPROP_IColumnsInfo,				FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IColumnsInfo\0",
&DBPROPSET_VIEW,			DBPROP_ISupportErrorInfo,			FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"ISupportErrorInfo\0",
&DBPROPSET_VIEW,			DBPROP_IViewChapter,				FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IViewChapter\0",
&DBPROPSET_VIEW,			DBPROP_IViewFilter,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IViewFilter\0",
&DBPROPSET_VIEW,			DBPROP_IViewRowset,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IViewRowset\0",
&DBPROPSET_VIEW,			DBPROP_IViewSort,					FALSE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IViewSort\0",
&DBPROPSET_VIEW,			DBPROP_MAXORSINFILTER,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum OR Conditions\0",	
&DBPROPSET_VIEW,			DBPROP_MAXSORTCOLUMNS,				FALSE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Maximum Sort Columns\0",	
&DBPROPSET_VIEW,			DBPROP_SORTONINDEX,					FALSE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Sort on Index\0", 

&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_ACCESSIBLEPROCEDURES,TRUE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Accessible Procedures\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_ACCESSIBLETABLES,	TRUE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Accessible Tables\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_ODBCSQLOPTIEF,		TRUE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Integrity Enhancement Facility\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_OJCAPABILITY,		TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Outer Join Capabilities\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_PROCEDURES,			TRUE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Stored Procedures\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_DRIVERNAME,			TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Driver Name\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_DRIVERVER,			TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Driver Version\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_DRIVERODBCVER,		TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Driver ODBC Version\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_LIKEESCAPECLAUSE,	TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Like Escape Clause\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_SPECIALCHARACTERS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Special Characters\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_MAXCOLUMNSINGROUPBY,TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Max Columns in Group By\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_MAXCOLUMNSININDEX,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Max Columns in Index\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_MAXCOLUMNSINORDERBY,TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Max Columns in Order By\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_MAXCOLUMNSINSELECT,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Max Columns in Select\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_MAXCOLUMNSINTABLE,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Max Columns in Table\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_NUMERICFUNCTIONS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Numeric Functions\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_ODBCSQLCONFORMANCE,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"SQL Grammar Support\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_OUTERJOINS,			TRUE,		FALSE,		FALSE,		FALSE,		VT_BSTR,	{VT_EMPTY,0,0,0,0},		L"Outer Joins\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_STRINGFUNCTIONS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"String Functions\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_SYSTEMFUNCTIONS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"System Functions\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_TIMEDATEFUNCTIONS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Time/Date Functions\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_FILEUSAGE,			TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"File Usage\0",
&DBPROPSET_PROVIDERDATASOURCEINFO,	KAGPROP_ACTIVESTATEMENTS,	TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"Active Statements\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_QUERYBASEDUPDATES,	TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Query Based Updates/Deletes/Inserts\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_MARSHALLABLE,		TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Generate a Rowset that can be marshalled\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_POSITIONONNEWROW,	TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Position on the last row after insert\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_IRowsetChangeExtInfo,TRUE,		FALSE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"IRowsetChangeExtInfo\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_CURSOR,				TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"ODBC Cursor Type\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_CONCURRENCY,		TRUE,		FALSE,		FALSE,		FALSE,		VT_I4,		{VT_EMPTY,0,0,0,0},		L"ODBC Concurrency Type\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_BLOBSONFOCURSOR,	TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"BLOB accessibility on Forward-Only cursor\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_INCLUDENONEXACT,	TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Include SQL_FLOAT, SQL_DOUBLE, and SQL_REAL in QBU where clauses\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_FORCESSFIREHOSEMODE,TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Force SQL Server Firehose Mode cursor\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_FORCENOPARAMETERREBIND,TRUE,	TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Force no parameter rebinding when executing a command\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_FORCENOPREPARE,		TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Force no command preparation when executing a parameterized command\0",
&DBPROPSET_PROVIDERROWSET,			KAGPROP_FORCENOREEXECUTE,	TRUE,		TRUE,		FALSE,		FALSE,		VT_BOOL,	{VT_EMPTY,0,0,0,0},		L"Force no command reexecution when failure to satisfy all required properties\0",
};																	                                     

ULONG g_cDBProperties = sizeof(g_rgDBProperties)/sizeof(g_rgDBProperties[0]);

//Indexes to g_rgDBProperties[] array.  Need parenthese in the code.
//Can not add parenthese here, exceeds compiler limit.
										
const ULONG IDX_COL_AUTOINCREMENT						=(ULONG)0L;
const ULONG IDX_COL_DEFAULT								=IDX_COL_AUTOINCREMENT+1;
const ULONG IDX_COL_DESCRIPTION							=IDX_COL_DEFAULT+1;
const ULONG IDX_COL_FIXEDLENGTH							=IDX_COL_DESCRIPTION+1;
const ULONG IDX_COL_INCREMENT							=IDX_COL_FIXEDLENGTH+1;
const ULONG IDX_COL_ISLONG								=IDX_COL_INCREMENT+1;
const ULONG IDX_COL_NULLABLE							=IDX_COL_ISLONG+1;
const ULONG IDX_COL_PRIMARYKEY							=IDX_COL_NULLABLE+1;
const ULONG IDX_COL_SEED								=IDX_COL_PRIMARYKEY+1;
const ULONG IDX_COL_UNIQUE								=IDX_COL_SEED+1;
const ULONG IDX_COLUMNLCID								=IDX_COL_UNIQUE+1;
const ULONG IDX_CURRENTCATALOG							=IDX_COLUMNLCID+1;
const ULONG IDX_MULTIPLECONNECTIONS						=IDX_CURRENTCATALOG+1;
const ULONG IDX_RESETDATASOURCE							=IDX_MULTIPLECONNECTIONS+1;
const ULONG IDX_ACTIVESESSIONS							=IDX_RESETDATASOURCE+1;
const ULONG IDX_ALTERCOLUMN								=IDX_ACTIVESESSIONS+1;
const ULONG IDX_ASYNCTXNABORT							=IDX_ALTERCOLUMN+1;
const ULONG IDX_ASYNCTXNCOMMIT							=IDX_ASYNCTXNABORT+1;
const ULONG IDX_BYREFACCESSORS							=IDX_ASYNCTXNCOMMIT+1;
const ULONG IDX_CATALOGLOCATION							=IDX_BYREFACCESSORS+1;
const ULONG IDX_CATALOGTERM		        				=IDX_CATALOGLOCATION+1;
const ULONG IDX_CATALOGUSAGE							=IDX_CATALOGTERM+1;
const ULONG IDX_COLUMNDEFINITION						=IDX_CATALOGUSAGE+1;
const ULONG IDX_COMSERVICES								=IDX_COLUMNDEFINITION+1;
const ULONG IDX_CONCATNULLBEHAVIOR						=IDX_COMSERVICES+1;
const ULONG IDX_CONNECTIONSTATUS						=IDX_CONCATNULLBEHAVIOR+1;
const ULONG IDX_DATASOURCENAME							=IDX_CONNECTIONSTATUS+1;
const ULONG IDX_DATASOURCEREADONLY						=IDX_DATASOURCENAME+1;
const ULONG IDX_DATASOURCETYPE							=IDX_DATASOURCEREADONLY+1;
const ULONG IDX_DBMSNAME								=IDX_DATASOURCETYPE+1;
const ULONG IDX_DBMSVER									=IDX_DBMSNAME+1;
const ULONG IDX_DSOTHREADMODEL							=IDX_DBMSVER+1;
const ULONG IDX_GENERATEURL								=IDX_DSOTHREADMODEL+1;
const ULONG IDX_GROUPBY									=IDX_GENERATEURL+1;
const ULONG IDX_HETEROGENEOUSTABLES						=IDX_GROUPBY+1;
const ULONG IDX_IDENTIFIERCASE							=IDX_HETEROGENEOUSTABLES+1;
const ULONG IDX_MAXINDEXSIZE							=IDX_IDENTIFIERCASE+1;
const ULONG	IDX_MAXOPENCHAPTERS							=IDX_MAXINDEXSIZE+1;	
const ULONG IDX_MAXROWSIZE								=IDX_MAXOPENCHAPTERS+1;
const ULONG IDX_MAXROWSIZEINCLUDESBLOB					=IDX_MAXROWSIZE+1;
const ULONG IDX_MAXTABLESINSELECT						=IDX_MAXROWSIZEINCLUDESBLOB+1;
const ULONG IDX_MULTIPLEPARAMSETS						=IDX_MAXTABLESINSELECT+1;
const ULONG IDX_MULTIPLERESULTS							=IDX_MULTIPLEPARAMSETS+1;
const ULONG IDX_MULTIPLESTORAGEOBJECTS					=IDX_MULTIPLERESULTS+1;
const ULONG IDX_MULTITABLEUPDATE						=IDX_MULTIPLESTORAGEOBJECTS+1;
const ULONG IDX_NULLCOLLATION							=IDX_MULTITABLEUPDATE+1;
const ULONG IDX_OLEOBJECTS								=IDX_NULLCOLLATION+1;
const ULONG IDX_OPENROWSETSUPPORT						=IDX_OLEOBJECTS+1;
const ULONG IDX_ORDERBYCOLUMNSINSELECT					=IDX_OPENROWSETSUPPORT+1;
const ULONG IDX_OUTPUTPARAMETERAVAILABILITY				=IDX_ORDERBYCOLUMNSINSELECT+1;
const ULONG IDX_PERSISTENTIDTYPE						=IDX_OUTPUTPARAMETERAVAILABILITY+1;
const ULONG IDX_PREPAREABORTBEHAVIOR					=IDX_PERSISTENTIDTYPE+1;
const ULONG IDX_PREPARECOMMITBEHAVIOR					=IDX_PREPAREABORTBEHAVIOR+1;
const ULONG IDX_PROCEDURETERM							=IDX_PREPARECOMMITBEHAVIOR+1;
const ULONG IDX_PROVIDERFRIENDLYNAME					=IDX_PROCEDURETERM+1;
const ULONG IDX_PROVIDERMEMORY							=IDX_PROVIDERFRIENDLYNAME+1;
const ULONG IDX_PROVIDERFILENAME						=IDX_PROVIDERMEMORY+1;
const ULONG IDX_PROVIDEROLEDBVER						=IDX_PROVIDERFILENAME+1;
const ULONG IDX_PROVIDERVER								=IDX_PROVIDEROLEDBVER+1;
const ULONG IDX_QUOTEDIDENTIFIERCASE					=IDX_PROVIDERVER+1;
const ULONG IDX_ROWSETCONVERSIONSONCOMMAND				=IDX_QUOTEDIDENTIFIERCASE+1;
const ULONG IDX_SCHEMATERM								=IDX_ROWSETCONVERSIONSONCOMMAND+1;
const ULONG IDX_SCHEMAUSAGE								=IDX_SCHEMATERM+1;
const ULONG IDX_SERVERNAME								=IDX_SCHEMAUSAGE+1;
const ULONG IDX_SQLSUPPORT								=IDX_SERVERNAME+1;
const ULONG IDX_STRUCTUREDSTORAGE						=IDX_SQLSUPPORT+1;
const ULONG IDX_SUBQUERIES								=IDX_STRUCTUREDSTORAGE+1;
const ULONG IDX_SUPPORTEDTXNDDL							=IDX_SUBQUERIES+1;
const ULONG IDX_SUPPORTEDTXNISOLEVELS					=IDX_SUPPORTEDTXNDDL+1;
const ULONG IDX_SUPPORTEDTXNISORETAIN					=IDX_SUPPORTEDTXNISOLEVELS+1;
const ULONG IDX_TABLETERM								=IDX_SUPPORTEDTXNISORETAIN+1;
const ULONG IDX_USERNAME								=IDX_TABLETERM+1;
const ULONG IDX_INDEX_AUTOUPDATE						=IDX_USERNAME+1;
const ULONG IDX_INDEX_CLUSTERED							=IDX_INDEX_AUTOUPDATE+1;
const ULONG IDX_INDEX_FILLFACTOR						=IDX_INDEX_CLUSTERED+1;
const ULONG IDX_INDEX_INITIALSIZE						=IDX_INDEX_FILLFACTOR+1;
const ULONG IDX_INDEX_NULLCOLLATION						=IDX_INDEX_INITIALSIZE+1;
const ULONG IDX_INDEX_NULLS								=IDX_INDEX_NULLCOLLATION+1;
const ULONG IDX_INDEX_PRIMARYKEY						=IDX_INDEX_NULLS+1;
const ULONG IDX_INDEX_SORTBOOKMARKS						=IDX_INDEX_PRIMARYKEY+1;
const ULONG IDX_INDEX_TEMPINDEX							=IDX_INDEX_SORTBOOKMARKS+1;
const ULONG IDX_INDEX_TYPE								=IDX_INDEX_TEMPINDEX+1;
const ULONG IDX_INDEX_UNIQUE							=IDX_INDEX_TYPE+1;
const ULONG IDX_AUTH_CACHE_AUTHINFO						=IDX_INDEX_UNIQUE+1;
const ULONG IDX_AUTH_ENCRYPT_PASSWORD					=IDX_AUTH_CACHE_AUTHINFO+1;
const ULONG IDX_AUTH_INTEGRATED							=IDX_AUTH_ENCRYPT_PASSWORD+1;
const ULONG IDX_AUTH_MASK_PASSWORD						=IDX_AUTH_INTEGRATED+1;
const ULONG IDX_AUTH_PASSWORD							=IDX_AUTH_MASK_PASSWORD+1;
const ULONG IDX_AUTH_PERSIST_ENCRYPTED					=IDX_AUTH_PASSWORD+1;
const ULONG IDX_AUTH_PERSIST_SENSITIVE_AUTHINFO			=IDX_AUTH_PERSIST_ENCRYPTED+1;
const ULONG IDX_AUTH_USERID								=IDX_AUTH_PERSIST_SENSITIVE_AUTHINFO+1;
const ULONG IDX_INIT_ASYNCH								=IDX_AUTH_USERID+1;
const ULONG IDX_INIT_BINDFLAGS							=IDX_INIT_ASYNCH+1;
const ULONG IDX_INIT_CATALOG							=IDX_INIT_BINDFLAGS+1;
const ULONG IDX_INIT_DATASOURCE							=IDX_INIT_CATALOG+1;
const ULONG IDX_INIT_GENERALTIMEOUT						=IDX_INIT_DATASOURCE+1;
const ULONG IDX_INIT_HWND								=IDX_INIT_GENERALTIMEOUT+1;
const ULONG IDX_INIT_IMPERSONATION_LEVEL				=IDX_INIT_HWND+1;
const ULONG IDX_INIT_LCID								=IDX_INIT_IMPERSONATION_LEVEL+1;
const ULONG IDX_INIT_LOCATION							=IDX_INIT_LCID+1;
const ULONG IDX_INIT_LOCKOWNER							=IDX_INIT_LOCATION+1;
const ULONG IDX_INIT_MODE								=IDX_INIT_LOCKOWNER+1;
const ULONG IDX_INIT_OLEDBSERVICES						=IDX_INIT_MODE+1;
const ULONG IDX_INIT_PROMPT								=IDX_INIT_OLEDBSERVICES+1;
const ULONG IDX_INIT_PROTECTION_LEVEL					=IDX_INIT_PROMPT+1;
const ULONG IDX_INIT_PROVIDERSTRING						=IDX_INIT_PROTECTION_LEVEL+1;
const ULONG IDX_INIT_TIMEOUT							=IDX_INIT_PROVIDERSTRING+1;
const ULONG IDX_ABORTPRESERVE							=IDX_INIT_TIMEOUT+1;
const ULONG IDX_ACCESSORDER								=IDX_ABORTPRESERVE+1;
const ULONG IDX_APPENDONLY								=IDX_ACCESSORDER+1;
const ULONG IDX_BLOCKINGSTORAGEOBJECTS					=IDX_APPENDONLY+1;
const ULONG IDX_BOOKMARKINFO							=IDX_BLOCKINGSTORAGEOBJECTS+1;
const ULONG IDX_BOOKMARKS								=IDX_BOOKMARKINFO+1;
const ULONG IDX_BOOKMARKSKIPPED							=IDX_BOOKMARKS+1;
const ULONG IDX_BOOKMARKTYPE	        				=IDX_BOOKMARKSKIPPED+1;
const ULONG IDX_CACHEDEFERRED							=IDX_BOOKMARKTYPE+1;
const ULONG IDX_CANFETCHBACKWARDS						=IDX_CACHEDEFERRED+1;
const ULONG IDX_CANHOLDROWS								=IDX_CANFETCHBACKWARDS+1;
const ULONG IDX_CANSCROLLBACKWARDS						=IDX_CANHOLDROWS+1;
const ULONG IDX_CHANGEINSERTEDROWS						=IDX_CANSCROLLBACKWARDS+1;
const ULONG IDX_CLIENTCURSOR							=IDX_CHANGEINSERTEDROWS+1;
const ULONG IDX_COLUMNRESTRICT							=IDX_CLIENTCURSOR+1;
const ULONG IDX_COMMANDTIMEOUT							=IDX_COLUMNRESTRICT+1;
const ULONG IDX_COMMITPRESERVE	        				=IDX_COMMANDTIMEOUT+1;
const ULONG IDX_DEFERRED								=IDX_COMMITPRESERVE+1;
const ULONG IDX_DELAYSTORAGEOBJECTS						=IDX_DEFERRED+1;
const ULONG IDX_FINDCOMPAREOPS							=IDX_DELAYSTORAGEOBJECTS+1;
const ULONG IDX_HIDDENCOLUMNS							=IDX_FINDCOMPAREOPS+1;
const ULONG IDX_IMMOBILEROWS							=IDX_HIDDENCOLUMNS+1;
const ULONG IDX_LITERALBOOKMARKS						=IDX_IMMOBILEROWS+1;
const ULONG IDX_LITERALIDENTITY							=IDX_LITERALBOOKMARKS+1;
const ULONG IDX_LOCKMODE								=IDX_LITERALIDENTITY+1;
const ULONG IDX_MAXOPENROWS								=IDX_LOCKMODE+1;
const ULONG IDX_MAXPENDINGROWS							=IDX_MAXOPENROWS+1;
const ULONG IDX_MAXROWS									=IDX_MAXPENDINGROWS+1;
const ULONG IDX_MAYWRITECOLUMN							=IDX_MAXROWS+1;
const ULONG IDX_MEMORYUSAGE								=IDX_MAYWRITECOLUMN+1;
const ULONG IDX_NOTIFICATIONGRANULARITY					=IDX_MEMORYUSAGE+1;
const ULONG IDX_NOTIFICATIONPHASES						=IDX_NOTIFICATIONGRANULARITY+1;
const ULONG IDX_NOTIFYCOLUMNSET							=IDX_NOTIFICATIONPHASES+1;
const ULONG IDX_NOTIFYROWDELETE							=IDX_NOTIFYCOLUMNSET+1;
const ULONG IDX_NOTIFYROWFIRSTCHANGE					=IDX_NOTIFYROWDELETE+1;
const ULONG IDX_NOTIFYROWINSERT							=IDX_NOTIFYROWFIRSTCHANGE+1;
const ULONG IDX_NOTIFYROWRESYNCH						=IDX_NOTIFYROWINSERT+1;
const ULONG IDX_NOTIFYROWSETCHANGED						=IDX_NOTIFYROWRESYNCH+1;
const ULONG IDX_NOTIFYROWSETFETCHPOSITIONCHANGE			=IDX_NOTIFYROWSETCHANGED+1;
const ULONG IDX_NOTIFYROWSETRELEASE						=IDX_NOTIFYROWSETFETCHPOSITIONCHANGE+1;
const ULONG IDX_NOTIFYROWUNDOCHANGE						=IDX_NOTIFYROWSETRELEASE+1;
const ULONG IDX_NOTIFYROWUNDODELETE						=IDX_NOTIFYROWUNDOCHANGE+1;
const ULONG IDX_NOTIFYROWUNDOINSERT						=IDX_NOTIFYROWUNDODELETE+1;
const ULONG IDX_NOTIFYROWUPDATE							=IDX_NOTIFYROWUNDOINSERT+1;
const ULONG IDX_ORDEREDBOOKMARKS						=IDX_NOTIFYROWUPDATE+1;
const ULONG IDX_OTHERINSERT								=IDX_ORDEREDBOOKMARKS+1;
const ULONG IDX_OTHERUPDATEDELETE						=IDX_OTHERINSERT+1;
const ULONG IDX_OWNINSERT								=IDX_OTHERUPDATEDELETE+1;
const ULONG IDX_OWNUPDATEDELETE							=IDX_OWNINSERT+1;
const ULONG IDX_QUICKRESTART							=IDX_OWNUPDATEDELETE+1;
const ULONG IDX_REENTRANTEVENTS							=IDX_QUICKRESTART+1;
const ULONG IDX_REMOVEDELETED							=IDX_REENTRANTEVENTS+1;
const ULONG IDX_REPORTMULTIPLECHANGES					=IDX_REMOVEDELETED+1;
const ULONG IDX_RETURNPENDINGINSERTS					=IDX_REPORTMULTIPLECHANGES+1;
const ULONG IDX_ROW_BULKOPS								=IDX_RETURNPENDINGINSERTS+1;
const ULONG IDX_ROWRESTRICT								=IDX_ROW_BULKOPS+1;
const ULONG IDX_ROWSET_ASYNCH							=IDX_ROWRESTRICT+1;
const ULONG IDX_ROWTHREADMODEL							=IDX_ROWSET_ASYNCH+1;
const ULONG IDX_SERVERCURSOR							=IDX_ROWTHREADMODEL+1;
const ULONG IDX_SERVERDATAONINSERT						=IDX_SERVERCURSOR+1;
const ULONG IDX_STORAGEFLAGS							=IDX_SERVERDATAONINSERT+1;
const ULONG IDX_STRONGIDENTITY							=IDX_STORAGEFLAGS+1;
const ULONG IDX_TRANSACTEDOBJECT						=IDX_STRONGIDENTITY+1;
const ULONG IDX_UNIQUEROWS								=IDX_TRANSACTEDOBJECT+1;
const ULONG IDX_UPDATABILITY							=IDX_UNIQUEROWS+1;
const ULONG IDX_IACCESSOR								=IDX_UPDATABILITY+1;
const ULONG IDX_IBINDRESOURCE							=IDX_IACCESSOR+1;
const ULONG IDX_ICHAPTEREDROWSET						=IDX_IBINDRESOURCE+1;
const ULONG IDX_ICOLUMNSINFO							=IDX_ICHAPTEREDROWSET+1;
const ULONG IDX_ICOLUMNSINFO2							=IDX_ICOLUMNSINFO+1;
const ULONG IDX_ICOLUMNSROWSET							=IDX_ICOLUMNSINFO2+1;
const ULONG IDX_ICONNECTIONPOINTCONTAINER				=IDX_ICOLUMNSROWSET+1;
const ULONG IDX_ICONVERTTYPE							=IDX_ICONNECTIONPOINTCONTAINER+1;
const ULONG IDX_ICREATEROW								=IDX_ICONVERTTYPE+1;
const ULONG IDX_IDBASYNCHSTATUS							=IDX_ICREATEROW+1;
const ULONG IDX_IBINDERPROPERTIES						=IDX_IDBASYNCHSTATUS+1;
const ULONG IDX_IGETROW									=IDX_IBINDERPROPERTIES+1;
const ULONG IDX_IGETSESSION								=IDX_IGETROW+1;
const ULONG IDX_IGETSOURCEROW							=IDX_IGETSESSION+1;
const ULONG IDX_IMULTIPLERESULTS						=IDX_IGETSOURCEROW+1;
const ULONG IDX_IPARENTROWSET							=IDX_IMULTIPLERESULTS+1;
const ULONG IDX_IREGISTERPROVIDER						=IDX_IPARENTROWSET+1;
const ULONG IDX_IROW									=IDX_IREGISTERPROVIDER+1;
const ULONG IDX_IROWCHANGE								=IDX_IROW+1;
const ULONG IDX_IROWSCHEMACHANGE						=IDX_IROWCHANGE+1;
const ULONG IDX_IROWSET									=IDX_IROWSCHEMACHANGE+1;
const ULONG IDX_IROWSETCHANGE							=IDX_IROWSET+1;
const ULONG IDX_IROWSETCURRENTINDEX						=IDX_IROWSETCHANGE+1;
const ULONG IDX_IROWSETFIND								=IDX_IROWSETCURRENTINDEX+1;
const ULONG IDX_IROWSETIDENTITY							=IDX_IROWSETFIND+1;
const ULONG IDX_IROWSETINDEX							=IDX_IROWSETIDENTITY+1;
const ULONG IDX_IROWSETINFO								=IDX_IROWSETINDEX+1;
const ULONG IDX_IROWSETLOCATE							=IDX_IROWSETINFO+1;
const ULONG IDX_IROWSETREFRESH							=IDX_IROWSETLOCATE+1;
const ULONG IDX_IROWSETRESYNCH							=IDX_IROWSETREFRESH+1;
const ULONG IDX_IROWSETSCROLL							=IDX_IROWSETRESYNCH+1;
const ULONG IDX_IROWSETUPDATE							=IDX_IROWSETSCROLL+1;
const ULONG IDX_IROWSETVIEW								=IDX_IROWSETUPDATE+1;
const ULONG IDX_ISCOPEDOPERATIONS						=IDX_IROWSETVIEW+1;
const ULONG IDX_ISUPPORTERRORINFO						=IDX_ISCOPEDOPERATIONS+1;
const ULONG IDX_ILOCKBYTES								=IDX_ISUPPORTERRORINFO+1;
const ULONG IDX_ISEQUENTIALSTREAM						=IDX_ILOCKBYTES+1;
const ULONG IDX_ISTORAGE								=IDX_ISEQUENTIALSTREAM+1;
const ULONG IDX_ISTREAM									=IDX_ISTORAGE+1;
const ULONG IDX_SESS_AUTOCOMMITISOLEVELS				=IDX_ISTREAM+1;
const ULONG IDX_TBL_TEMPTABLE							=IDX_SESS_AUTOCOMMITISOLEVELS+1;
const ULONG IDX_TRUSTEE_USERNAME						=IDX_TBL_TEMPTABLE+1;
const ULONG IDX_TRUSTEE_AUTHENTICATION					=IDX_TRUSTEE_USERNAME+1;
const ULONG IDX_TRUSTEE_NEWAUTHENTICATION				=IDX_TRUSTEE_AUTHENTICATION+1;
const ULONG IDX_FILTERCOMPAREOPS						=IDX_TRUSTEE_NEWAUTHENTICATION+1;
const ULONG IDX_VIACCESSOR								=IDX_FILTERCOMPAREOPS+1;
const ULONG IDX_VICOLUMNSINFO							=IDX_VIACCESSOR+1;
const ULONG IDX_VISUPPORTERRORINFO						=IDX_VICOLUMNSINFO+1;
const ULONG IDX_IVIEWCHAPTER							=IDX_VISUPPORTERRORINFO+1;
const ULONG IDX_IVIEWFILTER								=IDX_IVIEWCHAPTER+1;
const ULONG IDX_IVIEWROWSET								=IDX_IVIEWFILTER+1;
const ULONG IDX_IVIEWSORT								=IDX_IVIEWROWSET+1;
const ULONG IDX_MAXORSINFILTER							=IDX_IVIEWSORT+1;
const ULONG IDX_MAXSORTCOLUMNS							=IDX_MAXORSINFILTER+1;
const ULONG IDX_SORTONINDEX								=IDX_MAXSORTCOLUMNS+1;

// Provider Specific
const ULONG  IDX_ACCESSIBLEPROCEDURES					=IDX_TBL_TEMPTABLE+1;
const ULONG  IDX_ACCESSIBLETABLES						=IDX_ACCESSIBLEPROCEDURES+1;
const ULONG  IDX_ODBCSQLOPTIEF							=IDX_ACCESSIBLETABLES+1;
const ULONG  IDX_OJCAPABILITY							=IDX_ODBCSQLOPTIEF+1;
const ULONG  IDX_PROCEDURES								=IDX_OJCAPABILITY+1;
const ULONG  IDX_DRIVERNAME								=IDX_PROCEDURES+1;
const ULONG  IDX_DRIVERVER								=IDX_DRIVERNAME+1;
const ULONG  IDX_DRIVERODBCVER							=IDX_DRIVERVER+1;
const ULONG  IDX_LIKEESCAPECLAUSE						=IDX_DRIVERODBCVER+1;
const ULONG  IDX_SPECIALCHARACTERS						=IDX_LIKEESCAPECLAUSE+1;
const ULONG  IDX_MAXCOLUMNSINGROUPBY					=IDX_SPECIALCHARACTERS+1;
const ULONG  IDX_MAXCOLUMNSININDEX						=IDX_MAXCOLUMNSINGROUPBY+1;
const ULONG  IDX_MAXCOLUMNSINORDERBY					=IDX_MAXCOLUMNSININDEX+1;
const ULONG  IDX_MAXCOLUMNSINSELECT						=IDX_MAXCOLUMNSINORDERBY+1;
const ULONG  IDX_MAXCOLUMNSINTABLE						=IDX_MAXCOLUMNSINSELECT+1;
const ULONG  IDX_NUMERICFUNCTIONS						=IDX_MAXCOLUMNSINTABLE+1;
const ULONG  IDX_ODBCSQLCONFORMANCE						=IDX_NUMERICFUNCTIONS+1;
const ULONG  IDX_OUTERJOINS								=IDX_ODBCSQLCONFORMANCE+1;
const ULONG  IDX_STRINGFUNCTIONS						=IDX_OUTERJOINS+1;
const ULONG  IDX_SYSTEMFUNCTIONS						=IDX_STRINGFUNCTIONS+1;
const ULONG  IDX_TIMEDATEFUNCTIONS						=IDX_SYSTEMFUNCTIONS+1;
const ULONG  IDX_FILEUSAGE								=IDX_TIMEDATEFUNCTIONS+1;
const ULONG  IDX_ACTIVESTATEMENTS						=IDX_FILEUSAGE+1;

const ULONG  IDX_QUERYBASEDUPDATES						=IDX_ACTIVESTATEMENTS+1;
const ULONG  IDX_MARSHALLABLE							=IDX_QUERYBASEDUPDATES+1;
const ULONG  IDX_POSITIONONNEWROW						=IDX_MARSHALLABLE+1;
const ULONG  IDX_IROWSETCHANGEEXTINFO					=IDX_POSITIONONNEWROW+1;
const ULONG  IDX_CURSOR									=IDX_IROWSETCHANGEEXTINFO+1;
const ULONG  IDX_CONCURRENCY							=IDX_CURSOR+1;
const ULONG  IDX_BLOBSONFOCURSOR						=IDX_CONCURRENCY+1;
const ULONG  IDX_INCLUDENONEXACT						=IDX_BLOBSONFOCURSOR+1;
const ULONG  IDX_FORCESSFIREHOSEMODE					=IDX_INCLUDENONEXACT+1;
const ULONG  IDX_FORCENOPARAMETERREBIND					=IDX_FORCESSFIREHOSEMODE+1;
const ULONG  IDX_FORCENOPREPARE							=IDX_FORCENOPARAMETERREBIND+1;
const ULONG  IDX_FORCENOREEXECUTE						=IDX_FORCENOPREPARE+1;

const ULONG  IDX_ROWSET_START							=IDX_ABORTPRESERVE;
const ULONG  IDX_ROWSET_END								=IDX_ISTREAM;										

const ULONG  IDX_INTERFACE_START						=IDX_IACCESSOR;
const ULONG  IDX_INTERFACE_END							=IDX_ISTREAM;

const ULONG  IDX_OLEDB_START							=IDX_COL_AUTOINCREMENT;
const ULONG  IDX_OLEDB_END								=IDX_TBL_TEMPTABLE;

const ULONG  IDX_KAGERA_START							=IDX_ACCESSIBLEPROCEDURES;
const ULONG  IDX_KAGERA_END								=IDX_FORCENOREEXECUTE;

	
//-----------------------------------------------------------------------------
//  Unitility C functions
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//@mfunc: Verify the property is not mandatory
//
//-----------------------------------------------------------------------------
BOOL PassAsNotSupported(DBPROPID DBPropID)
{
	if(DBPropID==DBPROP_IAccessor) 
	{
		odtLog<<wszIAccessorNotSupported;
		return FALSE;
	}

	if(DBPropID==DBPROP_IRowsetInfo)
	{
		odtLog<<wszIRowsetInfoNotSupported;
		return FALSE;
	}

	if(DBPropID==DBPROP_IColumnsInfo)
	{
		odtLog<<wszIColumnsInfoNotSupported;
		return FALSE;
	}

	if(DBPropID==DBPROP_IRowset)
	{
		odtLog<<wszIRowsetNotSupported;
		return FALSE;
	}

	if(DBPropID==DBPROP_IConvertType)
	{
		odtLog<<wszIConvertTypeNotSupported;
		return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: Create a table to be used by the whole test module
//
//-----------------------------------------------------------------------------
BOOL CreateTable(IDBCreateCommand *pIDBCreateCommand)
{
	// Create the table, passing in the module name
	g_pCTable = new CTable(pIDBCreateCommand, (WCHAR *)gwszModuleName, USENULLS);

	if(!g_pCTable)
	{
		odtLog<<wszCMDMemoryAllocationError;
		return FALSE;
	}

	// Create a table with an index on it to eliminate special behavior of SQL Server
	if( !SUCCEEDED(g_pCTable->CreateTable(TABLE_ROW_COUNT)))
	{
		odtLog<<wszCanNotCreateTable;
		SAFE_DELETE(g_pCTable);
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
//@mfunc: Retrieve supported IDBProperties
//
//-----------------------------------------------------------------------------
BOOL InitSupported(	IDBProperties *pIDBProperties,CThisTestModule *pThisTestModule)
{				
	HRESULT			hr=E_FAIL;
	ULONG			cPrptSupported=0;
	DBPROPIDSET		DBPropIDSet;
	DBPROPID		DBPropID;
	ULONG			cPropertyInfoSets=0;
	DBPROPINFOSET	*pPropertyInfoSets=NULL;
	WCHAR			*pDescBuffer=NULL;
	BOOL			fPass=FALSE;

	// Loop through the struct.  Get default info on each command property
	for(ULONG cDBProperties = 0; cDBProperties<g_cDBProperties; cDBProperties++)
	{
		// Init for IDBProperties
		DBPropID=g_rgDBProperties[cDBProperties].dwPropertyID;
		DBPropIDSet.guidPropertySet=*(g_rgDBProperties[cDBProperties].pGuidPropertySet);
		DBPropIDSet.cPropertyIDs=1;
		DBPropIDSet.rgPropertyIDs=&DBPropID;

		//GetPropertyID
		hr=pIDBProperties->GetPropertyInfo(1,&DBPropIDSet,
						&cPropertyInfoSets,&pPropertyInfoSets,&pDescBuffer);

		if( (hr != S_OK) && (hr != DB_E_ERRORSOCCURRED) )
			goto END;

		// Check for return DBProperties
		COMPARE(cPropertyInfoSets, 1);

		// Check DBPROPINFOSET.guidPropertySet
		COMPARE(pPropertyInfoSets->guidPropertySet,
			*(g_rgDBProperties[cDBProperties].pGuidPropertySet));

		// Check DBPROPINFOSET.cPropertyInfos
		COMPARE(pPropertyInfoSets->cPropertyInfos, 1);

		// Check dwPropertyID
		COMPARE(pPropertyInfoSets->rgPropertyInfos->dwPropertyID,DBPropID);

		// Check dwFlags
		// Mark the property as not supported
		if(pPropertyInfoSets->rgPropertyInfos->dwFlags == DBPROPFLAGS_NOTSUPPORTED)
			g_rgDBProperties[cDBProperties].fSupported=FALSE;
		else
		{
			// Flip the Supported flag on
			g_rgDBProperties[cDBProperties].fSupported=TRUE;

			// Check pwszDescription
			if(!COMPARE(0, wcscmp(pPropertyInfoSets->rgPropertyInfos->pwszDescription,
									g_rgDBProperties[cDBProperties].wszDescription)))
				  odtLog<<L"The description is not same at "<<cDBProperties<<L" \n";

			// dwFlags should set DBPROPFLAGS_ROWSET
			if( (((cDBProperties >= IDX_ROWSET_START) && (cDBProperties <= IDX_ROWSET_END)) || 
				 (cDBProperties > IDX_QUERYBASEDUPDATES)) &&
				(!(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_ROWSET)) )
				odtLog<<wszRowsetFlagNotSetAt<<cDBProperties<<L" \n";
			else if( ((cDBProperties < IDX_ROWSET_START) || 
					  ((cDBProperties > IDX_ROWSET_END) && (cDBProperties < IDX_QUERYBASEDUPDATES)))   &&
					 (!(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_COLUMN)			&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_DATASOURCE)		&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_DATASOURCECREATE)	&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_DATASOURCEINFO)	&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_DBINIT)			&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_INDEX)			&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_SESSION)			&&
					  !(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_TABLE)) )
				odtLog<<wszDataSourceFlagSetAt<<cDBProperties<<L" \n";
			else if(!(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_DBINIT)	&&
					pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_REQUIRED)
				odtLog<<L"The DBPROPFLAGS_REQUIRED flag was on a NON DBINIT Property at index "<<cDBProperties<<L" \n";

			// dwFlags should not set DBPROPFLAGS_NOTSUPPORTED
			if(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_NOTSUPPORTED)
				odtLog<<L"The DBPROPFLAGS_NOTSUPPORTED flag was on a Supported Property at index "<<cDBProperties<<L" \n";

			// dwFlags should set for DBPROPFLAGS_READ
			if(!(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_WRITE))
			{
				g_rgDBProperties[cDBProperties].fSettable = FALSE;
				COMPARE((pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_READ), DBPROPFLAGS_READ);
			}
			else
				g_rgDBProperties[cDBProperties].fSettable = TRUE;

			// Should be able to read all properties
			COMPARE((pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_READ), DBPROPFLAGS_READ);

			// dwFlags should set for DBPROPFLAGS_COLUMNOK
			if(g_rgDBProperties[cDBProperties].fColumn)
			{
				if(!(pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_COLUMNOK))
					odtLog<<wszColumnFlagNotSetAt<<cDBProperties<<L" \n";
				else
					g_rgDBProperties[cDBProperties].fColumnOK = TRUE;
			}
			else
			{
				if((pPropertyInfoSets->rgPropertyInfos->dwFlags & DBPROPFLAGS_COLUMNOK))
				{
					// Compare is used just to increment the count of errors
					odtLog<<wszColumnFlagSetAt<<cDBProperties<<L" \n";
					COMPARE(g_rgDBProperties[cDBProperties].fColumn, TRUE);
				}
			}

			// Skip DBPROP_COL_DEFAULT because can return an type
			if(g_rgDBProperties[cDBProperties].dwPropertyID != DBPROP_COL_DEFAULT)
			{
				//Compare the vtType
				if(!COMPARE(pPropertyInfoSets->rgPropertyInfos->vtType, g_rgDBProperties[cDBProperties].vtType))
					odtLog<<wszIncorrectVtType<<cDBProperties<<L" \n";
			}

			// Copy the default value into the array
			if(!SUCCEEDED(VariantCopy(&(g_rgDBProperties[cDBProperties].vDefault),
						&(pPropertyInfoSets->rgPropertyInfos->vValues))))
			{
				odtLog<<wszDefaultValueFailed<<cDBProperties<<L" \n";
				goto FREE;
			}

			// Keep track of # of supported properties
			cPrptSupported++;	
		}

FREE:
		// Free memory from GetProperties
		FreeProperties(&cPropertyInfoSets,&pPropertyInfoSets,&pDescBuffer);
	}

	// The command object has to support at least one property in order
	// to continue on testing
	if(!cPrptSupported)
		odtLog<<wszNoneSupported;
	else
		odtLog<<wszTotalSupportedIs<<cPrptSupported<<L" \n";

	fPass=TRUE;

END:

	// Free memory from GetProperties
	FreeProperties(&cPropertyInfoSets,&pPropertyInfoSets,&pDescBuffer);
	return fPass;
}


//-----------------------------------------------------------------------------
//@mfunc: Intialize the default values for all rowset properties
//
//-----------------------------------------------------------------------------
BOOL  InitDefault(ICommandProperties *pICommandProperties,CThisTestModule *pThisTestModule)
{
	ULONG		cSetCount;
	ULONG		cPropertyCount;
	ULONG		cIndex;
	ULONG		cPropertySets=0;
	ULONG		cPrptSupported=0;
	DBPROPSET	*pPropertySets=NULL;
	HRESULT		hr;
	BOOL		fPass=FALSE;
	DWORD		dwMask=0;
	ULONG		ExtraCnt=0;

	// Call ICommandProperties
	if(!CHECK(hr=pICommandProperties->GetProperties(0,NULL,
										&cPropertySets,&pPropertySets), S_OK))
		goto END;

	// Set the default value for each property set
	for(cSetCount=0;cSetCount<cPropertySets;cSetCount++)
	{
		cPrptSupported = cPrptSupported + pPropertySets[cSetCount].cProperties;
		
		// Check to see if the Provider has Provider specific PropSets
		if(pPropertySets[cSetCount].guidPropertySet != DBPROPSET_ROWSET)
			ExtraCnt++;

		// Make sure we get at least 1 property
		if(!pPropertySets[cSetCount].cProperties)
			COMPARE(pPropertySets[cSetCount].cProperties, 1);

		// Go through each property
		for(cPropertyCount=0; cPropertyCount<pPropertySets[cSetCount].cProperties; 
		cPropertyCount++)
		{
			//Check to see if the Provider has returned an invalid PropSets
			if( (pPropertySets[cSetCount].guidPropertySet == DBPROPSET_DBINIT) || 
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_DATASOURCE) ||
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_DATASOURCEINFO) ||
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_COLUMN) ||
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_INDEX)  ||
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_SESSION)||
				(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_TABLE) )
				odtLog<<L"ERROR: An Invalid OLEDB PropertySet has been returned by ICommandProperties::GetProperties!\n";

			// Count the Rowset properties
			if(pPropertySets[cSetCount].guidPropertySet == DBPROPSET_ROWSET)
				g_ulPropertyCount++;

			// Go through the whole list
			for(cIndex=IDX_OLEDB_START; cIndex<=(ExtraCnt ? IDX_KAGERA_END : IDX_OLEDB_END);cIndex++)
			{
				// Search for the properties
				if((g_rgDBProperties[cIndex].dwPropertyID ==
					pPropertySets[cSetCount].rgProperties[cPropertyCount].dwPropertyID) &&
					(*(g_rgDBProperties[cIndex].pGuidPropertySet) == 
					pPropertySets[cSetCount].guidPropertySet))
				{
					// Print the value to the screen
					odtLog<<"      "<<g_rgDBProperties[cIndex].wszDescription<<" = ";
					if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt)
						odtLog<<pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue<<L" \n";
					else
						odtLog<<L"VT_EMPTY \n";

					// Set the property to supported
					g_rgDBProperties[cIndex].fSupported=TRUE;

					// Copy the default
					if( pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt )
					{
						hr = VariantCopy(&(g_rgDBProperties[cIndex].vDefault),
							&(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue));
					}
					else
						VariantInit(&g_rgDBProperties[cIndex].vDefault);

					// dwStatus has to be DBPROPSTATUS_OK
					if(pPropertySets[cSetCount].rgProperties[cPropertyCount].dwStatus!=
						DBPROPSTATUS_OK)
						odtLog<<L"The dwStatus in default is not DBPROPSTATUS_OK at index "<<cIndex<<"!\n";

					// Check VT type
					if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt!=
							g_rgDBProperties[cIndex].vtType)
					{
						if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt!=
								VT_EMPTY)
							odtLog<<L"The vt in vValue is not correct at index "<<cIndex<<"!\n";
						else
							goto BREAK;
					}

					//If VT==VT_BOOL, the value has to be either VAIANT_TRUE or VARIANT_FALSE
					if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt==
						VT_BOOL)
					{
						if((V_BOOL(&pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue)!=VARIANT_TRUE) &&
							(V_BOOL(&pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue)!=VARIANT_FALSE))
							odtLog<<L"The bool is not VARIANT_TRUE or VARIANT_FALSE at index "<<cIndex<<"!\n";
					}
					else
					{
						if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt==
							VT_EMPTY)
						{
							//The value has to be 0
							if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.lVal!=0)
								odtLog<<L"The lVal is not 0 at index "<<cIndex<<"!\n";
						}
						else
						{
							if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt==
								VT_I4)
							{
								//The value has to be greate than 0
								if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.lVal<0)
									odtLog<<L"The lVal is less than 0 at index "<<cIndex<<"!\n";
							}
							else
							{
								if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.vt==
									VT_I2)
								{
									//The value has to be greate than 0
									if(pPropertySets[cSetCount].rgProperties[cPropertyCount].vValue.iVal<0)
										odtLog<<L"The lVal is less than 0 at index "<<cIndex<<"!\n";
								}
							}
						}
					}
BREAK:
					break;
				}
			}

			// Check the Index count with the total number of properties
			if(cIndex > (ExtraCnt ? IDX_KAGERA_END : IDX_OLEDB_END))
			{
				if(ExtraCnt)
					odtLog<<L"This autotest needs to be updated with Provider specific properties!\n";
				else
					odtLog<<L"ERROR: A OLEDB Property has the wrong guidPropertySet!\n";
			}
		}
	}
	odtLog<<wszTotalGetPropertiesIs<<cPrptSupported<<L" \n";
	
	if(ExtraCnt)
		odtLog<<L"The Total includes Provider specific properties"<<L" \n";
	
	g_ulExtraROWProp = ExtraCnt;

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&pPropertySets);
	return fPass;
}


//-----------------------------------------------------------------------------
//@mfunc: Get the pointer to the guid for the interface
//
//-----------------------------------------------------------------------------
const GUID	*GetGuidPointer(ULONG cIndex)
{

	switch(cIndex)
	{
		case	IDX_IACCESSOR:
			return &IID_IAccessor;

		case	IDX_ICHAPTEREDROWSET:
			return &IID_IChapteredRowset;

		case	IDX_ICOLUMNSINFO:
			return &IID_IColumnsInfo;

		case	IDX_ICOLUMNSROWSET:
			return &IID_IColumnsRowset;

		case	IDX_ICONNECTIONPOINTCONTAINER:
			return &IID_IConnectionPointContainer;

		case	IDX_ICONVERTTYPE:
			return &IID_IConvertType;

		case	IDX_IDBASYNCHSTATUS:
			return &IID_IDBAsynchStatus;

		case	IDX_IROWSET:
			return &IID_IRowset;

		case	IDX_IROWSETCHANGE:
			return &IID_IRowsetChange;

		case	IDX_IROWSETFIND:
			return &IID_IRowsetFind;

		case	IDX_IROWSETIDENTITY:
			return &IID_IRowsetIdentity;

		case	IDX_IROWSETINDEX:
			return &IID_IRowsetIndex;

		case	IDX_IROWSETINFO:
			return &IID_IRowsetInfo;

		case	IDX_IROWSETLOCATE:
			return &IID_IRowsetLocate;

		case	IDX_IROWSETRESYNCH:
			return &IID_IRowsetResynch;

		case	IDX_IROWSETSCROLL:
			return &IID_IRowsetScroll;

		case	IDX_IROWSETUPDATE:
			return &IID_IRowsetUpdate;

		case	IDX_IROWSETVIEW:
			return &IID_IRowsetView;

		case	IDX_IVIEWCHAPTER:
			return &IID_IViewChapter;

		case	IDX_IVIEWFILTER:
			return &IID_IViewFilter;

		case	IDX_IVIEWROWSET:
			return &IID_IViewRowset;

		case	IDX_IVIEWSORT:
			return &IID_IViewSort;

		case	IDX_ILOCKBYTES:
			return &IID_ILockBytes;

		case	IDX_ISEQUENTIALSTREAM:
			return &IID_ISequentialStream;

		case	IDX_ISTORAGE:
			return &IID_IStorage;

		case	IDX_ISTREAM:
			return &IID_IStream;

		case	IDX_ISUPPORTERRORINFO:
			return &IID_ISupportErrorInfo;

		default:
			return &IID_IUnknown;
	}
}


//-----------------------------------------------------------------------------
//@mfunc: If the property contains a numeric value
//
//-----------------------------------------------------------------------------
BOOL	PropertyNumeric(const ULONG cPrpt)
{
	if(g_rgDBProperties[cPrpt].vtType==VT_I4)
		return TRUE;
	else
		return FALSE;
}


//-----------------------------------------------------------------------------
//@mfunc: Set the DBPROPIDSET
//
//-----------------------------------------------------------------------------
BOOL	InitDBPropIDSet(const ULONG cPrpt, DBPROPIDSET *pDBPropIDSet)
{
	if(!(pDBPropIDSet->rgPropertyIDs))
		return FALSE;

	pDBPropIDSet->guidPropertySet=*(g_rgDBProperties[cPrpt].pGuidPropertySet);
	pDBPropIDSet->cPropertyIDs=1;
	*(pDBPropIDSet->rgPropertyIDs)=g_rgDBProperties[cPrpt].dwPropertyID;

	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: Set the DBPROPSET
//
//-----------------------------------------------------------------------------
BOOL	InitDBPropSet(
	const ULONG		cPrpt, 
	DBPROPSET		*pDBPropSet,
	BOOL			fSet)
{
	if(!(pDBPropSet->rgProperties))
		return FALSE;

	memset(pDBPropSet->rgProperties ,0,sizeof(DBPROP));
	pDBPropSet->guidPropertySet=*(g_rgDBProperties[cPrpt].pGuidPropertySet);
	pDBPropSet->cProperties=1;
	pDBPropSet->rgProperties->dwStatus=99;

	//Set dwPropertyID and dwOptions
	pDBPropSet->rgProperties->dwPropertyID=g_rgDBProperties[cPrpt].dwPropertyID;
	if(3 != fSet)
		pDBPropSet->rgProperties->dwOptions=DBPROPOPTIONS_REQUIRED;
	else
		pDBPropSet->rgProperties->dwOptions=DBPROPOPTIONS_SETIFCHEAP;

	//Set column info
	if(g_rgDBProperties[cPrpt].fColumn)
	   pDBPropSet->rgProperties->colid=DB_NULLID;

	//Set value
	if(2 == fSet)
	{
		pDBPropSet->rgProperties->vValue.vt=VT_EMPTY;
	}
	else
	{
		switch(g_rgDBProperties[cPrpt].vtType)
		{
			case VT_BOOL:
			{
				pDBPropSet->rgProperties->vValue.vt=VT_BOOL;

				if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.boolVal == VARIANT_FALSE))
					V_BOOL(&pDBPropSet->rgProperties->vValue)=VARIANT_TRUE;
				else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.boolVal == VARIANT_TRUE))
					V_BOOL(&pDBPropSet->rgProperties->vValue)=VARIANT_FALSE;
				else
					V_BOOL(&pDBPropSet->rgProperties->vValue)=g_rgDBProperties[cPrpt].vDefault.boolVal;
			}
				break;

			case VT_I4:
			{
				pDBPropSet->rgProperties->vValue.vt=VT_I4;

				switch(cPrpt)
				{
					case IDX_BOOKMARKTYPE:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_BMK_NUMERIC))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_BMK_NUMERIC;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_BMK_NUMERIC))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_BMK_KEY;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_FILTERCOMPAREOPS:
					case IDX_FINDCOMPAREOPS:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_CO_EQUALITY))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_CO_EQUALITY;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_CO_EQUALITY))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_CO_STRING;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_LOCKMODE:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_LM_NONE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_LM_NONE;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_LM_NONE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_LM_SINGLEROW;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_COMMANDTIMEOUT:
					case IDX_MAXOPENROWS:
					case IDX_MAXPENDINGROWS:
					case IDX_MAXROWS:
					case IDX_MEMORYUSAGE:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != 0))
							pDBPropSet->rgProperties->vValue.lVal = 0;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == 0))
							pDBPropSet->rgProperties->vValue.lVal = 1;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_NOTIFICATIONGRANULARITY:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NT_SINGLEROW))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_NT_SINGLEROW;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NT_SINGLEROW))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_NT_MULTIPLEROWS;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_NOTIFICATIONPHASES:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NP_OKTODO))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_NP_OKTODO;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NP_OKTODO))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_NP_ABOUTTODO;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_NOTIFYCOLUMNSET:
					case IDX_NOTIFYROWDELETE:
					case IDX_NOTIFYROWFIRSTCHANGE:
					case IDX_NOTIFYROWINSERT:
					case IDX_NOTIFYROWRESYNCH:
					case IDX_NOTIFYROWSETRELEASE:
					case IDX_NOTIFYROWSETFETCHPOSITIONCHANGE:
					case IDX_NOTIFYROWUNDOCHANGE:
					case IDX_NOTIFYROWUNDODELETE:
					case IDX_NOTIFYROWUNDOINSERT:
					case IDX_NOTIFYROWUPDATE:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != 0))
							pDBPropSet->rgProperties->vValue.lVal = 0;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == 0))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_NP_OKTODO;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_ROWSET_ASYNCH:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_ASYNCH_INITIALIZE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_ASYNCH_INITIALIZE;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_ASYNCH_INITIALIZE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_ROWTHREADMODEL:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_RT_FREETHREAD))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_RT_FREETHREAD;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_RT_FREETHREAD))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_RT_APTMTTHREAD;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;

					case IDX_UPDATABILITY:
						// Set the Non Default value and the Default value
						if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_UP_CHANGE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_UP_CHANGE;
						else if ((fSet) && (g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_UP_CHANGE))
							pDBPropSet->rgProperties->vValue.lVal = DBPROPVAL_UP_DELETE;
						else
							pDBPropSet->rgProperties->vValue.lVal = g_rgDBProperties[cPrpt].vDefault.lVal;
						break;
					
					default:
						break;
				}
			}
				break;
		}
	}

	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: Verify the property is set
//
//-----------------------------------------------------------------------------
BOOL	VerifyDBPropSet(
	const ULONG		cPrpt, 
	DBPROPSET		*pDBPropSet, 
	DBPROPSTATUS	dwStatus,
	BOOL			fSet)
{
	if(!(pDBPropSet->rgProperties))
		return FALSE;

	//Check guidPropertySet
	if(pDBPropSet->guidPropertySet != *(g_rgDBProperties[cPrpt].pGuidPropertySet))
		return FALSE;

	//Check cProperties
	if(pDBPropSet->cProperties != 1)
		return FALSE;

	//Check dwPropertyID 
	if(pDBPropSet->rgProperties->dwPropertyID != 
		g_rgDBProperties[cPrpt].dwPropertyID)
		return FALSE;

	//Check dwOptions
	if((3 != fSet) && (dwStatus != DBPROPSTATUS_BADOPTION))
	{
		if(pDBPropSet->rgProperties->dwOptions != DBPROPOPTIONS_REQUIRED)
			return FALSE;
	}
	else if (dwStatus != DBPROPSTATUS_BADOPTION)
	{
		if(pDBPropSet->rgProperties->dwOptions != DBPROPOPTIONS_SETIFCHEAP)
			return FALSE;
	}
	else
	{
		if(pDBPropSet->rgProperties->dwOptions != 99)
			return FALSE;
	}

	//Check dwStatus
	if(pDBPropSet->rgProperties->dwStatus != dwStatus)
		return FALSE;

	//Check column info
	if(g_rgDBProperties[cPrpt].fColumn)
	{
	   if(!CompareDBID(pDBPropSet->rgProperties->colid, DB_NULLID))
		   return FALSE;
	}

	//Check vValue
	switch(g_rgDBProperties[cPrpt].vtType)
	{
		case VT_BOOL:
		{
			if(pDBPropSet->rgProperties->vValue.vt != VT_BOOL)
				return FALSE;

			if (fSet)
			{
				if (((V_BOOL(&g_rgDBProperties[cPrpt].vDefault) == VARIANT_TRUE)  &&
					 (V_BOOL(&pDBPropSet->rgProperties->vValue) == VARIANT_TRUE)) ||
					((V_BOOL(&g_rgDBProperties[cPrpt].vDefault) != VARIANT_TRUE)  &&
					 (V_BOOL(&pDBPropSet->rgProperties->vValue) != VARIANT_TRUE)))
					return FALSE;
			}
			else
			{
				if (V_BOOL(&g_rgDBProperties[cPrpt].vDefault) != V_BOOL(&pDBPropSet->rgProperties->vValue))
					return FALSE;
			}
		}
			break;

		case VT_I4:
		{
			if(pDBPropSet->rgProperties->vValue.vt != VT_I4)
				return FALSE;

			switch(cPrpt)
			{
				case IDX_BOOKMARKTYPE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_BMK_NUMERIC)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_BMK_KEY)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_BMK_NUMERIC)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_BMK_NUMERIC))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_FILTERCOMPAREOPS:
				case IDX_FINDCOMPAREOPS:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_CO_EQUALITY)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_CO_STRING)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_CO_EQUALITY)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_CO_EQUALITY))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_LOCKMODE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_LM_NONE)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_LM_SINGLEROW)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_LM_NONE)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_LM_NONE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
					case IDX_COMMANDTIMEOUT:
					case IDX_MAXOPENROWS:
					case IDX_MAXPENDINGROWS:
					case IDX_MAXROWS:
					case IDX_MEMORYUSAGE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 1))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 0))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_NOTIFICATIONGRANULARITY:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NT_SINGLEROW) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NT_MULTIPLEROWS))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NT_SINGLEROW) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NT_SINGLEROW))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_NOTIFICATIONPHASES:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NP_OKTODO) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_ABOUTTODO))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NP_OKTODO) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_OKTODO))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
					case IDX_NOTIFYCOLUMNSET:
					case IDX_NOTIFYROWDELETE:
					case IDX_NOTIFYROWFIRSTCHANGE:
					case IDX_NOTIFYROWINSERT:
					case IDX_NOTIFYROWRESYNCH:
					case IDX_NOTIFYROWSETRELEASE:
					case IDX_NOTIFYROWSETFETCHPOSITIONCHANGE:
					case IDX_NOTIFYROWUNDOCHANGE:
					case IDX_NOTIFYROWUNDODELETE:
					case IDX_NOTIFYROWUNDOINSERT:
					case IDX_NOTIFYROWUPDATE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_OKTODO))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 0))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_ROWSET_ASYNCH:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_ASYNCH_INITIALIZE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_ASYNCH_INITIALIZE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_ASYNCH_INITIALIZE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_ROWTHREADMODEL:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_RT_FREETHREAD) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_RT_APTMTTHREAD))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_RT_FREETHREAD) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_RT_FREETHREAD))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_UPDATABILITY:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_UP_CHANGE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_UP_DELETE))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_UP_CHANGE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_UP_CHANGE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

					break;
			}
		}
			break;
	}	
	
	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: VerifyDBPropGet
//
//-----------------------------------------------------------------------------
BOOL	VerifyDBPropGet(
	const ULONG		cPrpt, 
	DBPROPSET		*pDBPropSet, 
	DBPROPSTATUS	dwStatus,
	BOOL			fSet
)
{
	if(!(pDBPropSet->rgProperties))
		return FALSE;

	//Check guidPropertySet
	if(pDBPropSet->guidPropertySet!= *(g_rgDBProperties[cPrpt].pGuidPropertySet))
		return FALSE;

	//Check cProperties
	if(pDBPropSet->cProperties !=1)
		return FALSE;

	//Check dwPropertyID 
	if(pDBPropSet->rgProperties->dwPropertyID != 
		g_rgDBProperties[cPrpt].dwPropertyID)
		return FALSE;

	//Check dwStatus
	if(pDBPropSet->rgProperties->dwStatus!=dwStatus)
		return FALSE;

	//Stop if dwStatus==DBPROPSTATUS_NOTSUPPORTED
	if(dwStatus==DBPROPSTATUS_NOTSUPPORTED)
		return TRUE;

	//Check column info
	if(g_rgDBProperties[cPrpt].fColumn && fSet)
	{
	   if(!CompareDBID(pDBPropSet->rgProperties->colid, DB_NULLID))
		   return FALSE;
	}

	//Check vValue
	switch(g_rgDBProperties[cPrpt].vtType)
	{
		case VT_BOOL:
		{
			if(pDBPropSet->rgProperties->vValue.vt != VT_BOOL)
				return FALSE;

			if (fSet)
			{
				if (((V_BOOL(&g_rgDBProperties[cPrpt].vDefault) == VARIANT_TRUE)  &&
					 (V_BOOL(&pDBPropSet->rgProperties->vValue) == VARIANT_TRUE)) ||
					((V_BOOL(&g_rgDBProperties[cPrpt].vDefault) != VARIANT_TRUE)  &&
					 (V_BOOL(&pDBPropSet->rgProperties->vValue) != VARIANT_TRUE)))
					return FALSE;
			}
			else
			{
				if (V_BOOL(&g_rgDBProperties[cPrpt].vDefault) != V_BOOL(&pDBPropSet->rgProperties->vValue))
					return FALSE;
			}
		}
			break;

		case VT_I4:
		{
			if(pDBPropSet->rgProperties->vValue.vt != VT_I4)
				return FALSE;

			switch(cPrpt)
			{
				case IDX_BOOKMARKTYPE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_BMK_NUMERIC)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_BMK_KEY)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_BMK_NUMERIC)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_BMK_NUMERIC))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_FILTERCOMPAREOPS:
				case IDX_FINDCOMPAREOPS:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_CO_EQUALITY)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_CO_STRING)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_CO_EQUALITY)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_CO_EQUALITY))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_LOCKMODE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_LM_NONE)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_LM_SINGLEROW)) ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_LM_NONE)  &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_LM_NONE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
					case IDX_COMMANDTIMEOUT:
					case IDX_MAXOPENROWS:
					case IDX_MAXPENDINGROWS:
					case IDX_MAXROWS:
					case IDX_MEMORYUSAGE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 1))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 0))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_NOTIFICATIONGRANULARITY:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NT_SINGLEROW) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NT_MULTIPLEROWS))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NT_SINGLEROW) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NT_SINGLEROW))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
				case IDX_NOTIFICATIONPHASES:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_NP_OKTODO) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_ABOUTTODO))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_NP_OKTODO) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_OKTODO))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;
				
					case IDX_NOTIFYCOLUMNSET:
					case IDX_NOTIFYROWDELETE:
					case IDX_NOTIFYROWFIRSTCHANGE:
					case IDX_NOTIFYROWINSERT:
					case IDX_NOTIFYROWRESYNCH:
					case IDX_NOTIFYROWSETRELEASE:
					case IDX_NOTIFYROWSETFETCHPOSITIONCHANGE:
					case IDX_NOTIFYROWUNDOCHANGE:
					case IDX_NOTIFYROWUNDODELETE:
					case IDX_NOTIFYROWUNDOINSERT:
					case IDX_NOTIFYROWUPDATE:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_NP_OKTODO))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != 0) &&
						  (pDBPropSet->rgProperties->vValue.lVal == 0))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_ROWSET_ASYNCH:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_ASYNCH_INITIALIZE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_ASYNCH_INITIALIZE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_ASYNCH_INITIALIZE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_ROWTHREADMODEL:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_RT_FREETHREAD) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_RT_APTMTTHREAD))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_RT_FREETHREAD) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_RT_FREETHREAD))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

				case IDX_UPDATABILITY:
					if ((fSet) &&
						(((g_rgDBProperties[cPrpt].vDefault.lVal == DBPROPVAL_UP_CHANGE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_UP_DELETE))  ||
						 ((g_rgDBProperties[cPrpt].vDefault.lVal != DBPROPVAL_UP_CHANGE) &&
						  (pDBPropSet->rgProperties->vValue.lVal == DBPROPVAL_UP_CHANGE))))
						break;
					else if ((!fSet) &&
						(g_rgDBProperties[cPrpt].vDefault.lVal == pDBPropSet->rgProperties->vValue.lVal))
						break;
					else
						return FALSE;

					break;
			}
		}
			break;
	}	
	
	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: VerifyDBPropDefault: Verify the return value is the same as 
//			the default value.
//
//-----------------------------------------------------------------------------
BOOL	VerifyDBPropDefault(ULONG cPrpt, DBPROPSET *pDBPropSet, BOOL fAfterRowset)
{
	if(!(pDBPropSet->rgProperties))
		return FALSE;

	//Check guidPropertySet
	if(pDBPropSet->guidPropertySet != *(g_rgDBProperties[cPrpt].pGuidPropertySet))
		return FALSE;

	//Check cProperties
	if(pDBPropSet->cProperties != 1)
		return FALSE;

	//Check dwPropertyID 
	if(pDBPropSet->rgProperties->dwPropertyID != 
			g_rgDBProperties[cPrpt].dwPropertyID)
		return FALSE;

	//Check dwStatus has to be DBPROPSTATUS_OK
	if(pDBPropSet->rgProperties->dwStatus != DBPROPSTATUS_OK)
		return FALSE;

	//Check vValue
	if(!((fAfterRowset == TRUE) && (g_rgDBProperties[cPrpt].fSettable == FALSE)))
	{
		if(pDBPropSet->rgProperties->vValue.vt == VT_I4)
		{
			if(pDBPropSet->rgProperties->vValue.lVal!=g_rgDBProperties[cPrpt].vDefault.lVal)
				return FALSE;
		}
		else
		{
			if(V_BOOL(&pDBPropSet->rgProperties->vValue) !=
					V_BOOL(&g_rgDBProperties[cPrpt].vDefault))
				return FALSE;
		}
	}	
	
	return TRUE;
}


//-----------------------------------------------------------------------------
//@mfunc: Check to make sure a specific command properties is returned from
//			ICommandProperties->GetProperties
//
//-----------------------------------------------------------------------------
BOOL CheckSet(
ULONG				cIDX,				//the index to g_rgDBProperties
GUID				*pGuidPropertySet,	//the GUID of the property set
ULONG				cProperties,		//the count of cProperties
DBPROP				*rgProperties		//the array of DBPROP returned by ICommandProperties::GetProperties
)
{
	ULONG	cCount;

	for(cCount=0;cCount<cProperties;cCount++)
	{
		//Check the guidPropertySet and dwPropertyID
		if( (*(g_rgDBProperties[cIDX].pGuidPropertySet)== *pGuidPropertySet) 
		   &&(g_rgDBProperties[cIDX].dwPropertyID==rgProperties[cCount].dwPropertyID))
		{
			if(rgProperties[cCount].vValue.vt != g_rgDBProperties[cIDX].vtType)
				return FALSE;

			if(!CompareVariant(&(rgProperties[cCount].vValue),
							   &(g_rgDBProperties[cIDX].vDefault)))
				return FALSE;
			else
				return TRUE;
		}
	}

	//Check if the property is supported
	if((cCount==cProperties) && (!(g_rgDBProperties[cIDX].fSupported)))
		return TRUE;

	return FALSE;
}


//-----------------------------------------------------------------------------
// @func Module level initialization routine
//
// @rdesc Success or Failure
// 		@flag  TRUE  | Successful initialization
//		@flag  FALSE | Initialization problems
//
//-----------------------------------------------------------------------------
BOOL ModuleInit(CThisTestModule * pThisTestModule)
{
	HRESULT				hr=E_FAIL;
	IDBProperties		*pIDBProperties=NULL;
	ICommandProperties	*pICommandProperties=NULL;
	BOOL				fInitPass=FALSE;
	ULONG				cPropertySets=0;
	DBPROPSET			*rgPropertySets=NULL;
	IDBInitialize *		pIDBInitialize = NULL;

	// Initialize the globals
	g_ulExtraROWProp=0;
	g_ulPropertyCount=0;
	g_pCTable=NULL;
	g_pIDBCreateCommand=NULL;
	
	// Set the fSupported back to TRUE
	for(ULONG i=0; i < g_cDBProperties; i++) {
		g_rgDBProperties[i].fSupported=TRUE;
		g_rgDBProperties[i].fColumnOK=FALSE;
	}

	// Use pThisTestModule->m_pIUnknown2 to get an IDBCreateCommand pointer
	// and pThisTestModule->m_pIUnknown to get an IDBCreateSession pointer.
	if(!CommonModuleInit(pThisTestModule))
		return FALSE;

	// Fail gracefully and quit module if we don't support Commands
	if(!VerifyInterface(pThisTestModule->m_pIUnknown2, IID_IDBCreateCommand, 
			SESSION_INTERFACE, (IUnknown**)&g_pIDBCreateCommand))
	{
		odtLog << L"IDBCreateCommand is not supported by Provider." << ENDL;
		return TEST_SKIPPED;
	}

	// IDBProperties interface
	if(!VerifyInterface(pThisTestModule->m_pIUnknown, IID_IDBProperties, 
						DATASOURCE_INTERFACE, (IUnknown **)&pIDBProperties))
		goto END;

	// Create a command object, asking for ICommandProperties pointer
	if(!SUCCEEDED(g_pIDBCreateCommand->CreateCommand(NULL,IID_ICommandProperties,
			(IUnknown **)&pICommandProperties)))
	{
		odtLog<<wszCMDInterfaceNotSupported;
		fInitPass=TEST_SKIPPED;
		goto END;
	}

	// Retrieve the information on supported command properties and their
	// default values
	if(!InitSupported(pIDBProperties, pThisTestModule))
		goto END;

	// Get the default values
	if(InitDefault(pICommandProperties, pThisTestModule))
		fInitPass=TRUE;

	// Create a table
	if(!CreateTable(g_pIDBCreateCommand))
		odtLog <<wszCanNotCreateTable;

	if (!VerifyInterface(pThisTestModule->m_pIUnknown, IID_IDBInitialize, DATASOURCE_INTERFACE, (IUnknown**)&pIDBInitialize))
			return FALSE;


END:
	// Release the ICommandProperties pointer on the command object
	SAFE_RELEASE_(pICommandProperties);
	SAFE_RELEASE(pIDBProperties);
    SAFE_RELEASE(pIDBInitialize);

	FreeProperties(&cPropertySets,&rgPropertySets);

	return fInitPass;
}	
  
//-----------------------------------------------------------------------------
// @func Module level termination routine
//
// @rdesc Success or Failure
// 		@flag  TRUE  | Successful initialization
//		@flag  FALSE | Initialization problems
//
//-----------------------------------------------------------------------------
BOOL ModuleTerminate(CThisTestModule * pThisTestModule)
{
	//Drop the table
	if(g_pCTable)
	{
		g_pCTable->DropTable();
		delete g_pCTable;
	}

	// Loop through the struct.  Free the variants
	for(ULONG cDBProperties = 0; cDBProperties<g_cDBProperties; cDBProperties++)
		VariantClear(&g_rgDBProperties[cDBProperties].vDefault);
	
	//Release g_pICreateCommand pointer
	SAFE_RELEASE(g_pIDBCreateCommand);
	
	//Release the IDBCreateCommand pointer to pThisTestModule->m_pIUnknown2
	//and a IDBCreateSession pointer to pThisTestModule->m_pIUnknown.
	if(!CommonModuleTerminate(pThisTestModule))
		return FALSE;

	return TRUE;
}	


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//  Base test Case Section
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

//Base class TCICMDPRPT: The base class for the rest of test cases in this 
//							test module.

class TCICMDPRPT : public COLEDB
{
	private:

	protected:

		//@cmember: Interface pointer for ICommand
		ICommand			*m_pICommand;

		//@cmember: Interface pointer for ICommandProperties
		ICommandProperties	*m_pICommandProperties;

		//@cmember: Interface pointer for ICommandText
		ICommandText		*m_pICommandText;

		//@cmember: Interface pointer for IRowset
		IRowsetInfo			*m_pIRowsetInfo;

		//@cmember: HResult
		HRESULT    			m_hr;

		//@mfunc: Init creates a Data Source object, a DB Session object, 
		//and a command object and initialialize interface pointers
		BOOL	Init();

		//@mfunc: Retreive supported DBProperties
		BOOL	InitSupported();		
	
		//@mfunc: Terminate releases the data source object, DB Session object, 
		// and Command object
		BOOL	Terminate();

		//@mfunc: Recreate a new command object, start from scratch
		BOOL	ResetProperties();

		//@mfunc: Open a rowset and initialize m_pIRowset
		BOOL	OpenRowset(EQUERY	eSQLStmt=SELECT_COLLISTFROMTBL);

		//@mfunc: Release a rowset object
		BOOL	ReleaseRowset();

		//@mfunc: Set Command text, 
		BOOL	ReadyToExecute(EQUERY	eSQLStmt=SELECT_COLLISTFROMTBL);

		//@mfunc: Clean Up Command text
		BOOL	CleanUpFromExecute();

		//@mfunc: Verify if the property is supported. It has to be called after
		//			InitSupported()
		inline	BOOL	VerifySupported(ULONG idxPrpt)
				{return g_rgDBProperties[idxPrpt].fSupported;};

	public:
		//constructor
		TCICMDPRPT(WCHAR *wstrTestCaseName);

		//destructor
		virtual ~TCICMDPRPT();
};


//--------------------------------------------------------------------
// @mfunc base class TCICMDPRPT constructor, must take testcase name
//			as parameter.
//
TCICMDPRPT::TCICMDPRPT(WCHAR * wstrTestCaseName)	//Takes TestCase Class name as parameter
						: COLEDB (wstrTestCaseName) 
{
	//initialize member data
	m_pICommand=NULL;
	m_pICommandProperties = NULL;
	m_pICommandText=NULL;
	m_pIRowsetInfo = NULL;
}


//--------------------------------------------------------------------
// @mfunc base class TCICMDPRPT destructor
//
TCICMDPRPT::~TCICMDPRPT() 
{

}


//--------------------------------------------------------------------
//@mfunc: Init creates a Data Source object, a DB Session object, 
//and a command object and initialize corresponding interface pointers.
//
BOOL TCICMDPRPT::Init()
{
	if(!(COLEDB::Init()))
		goto END;

	//create a command object
	if(!CHECK(g_pIDBCreateCommand->CreateCommand(NULL,IID_ICommand,(IUnknown **)&m_pICommand),S_OK))
		goto END;

	//queryinterface for ICommandProperties interface pointer
	if(!CHECK(m_pICommand->QueryInterface(IID_ICommandProperties,(LPVOID *)&m_pICommandProperties),S_OK))
		goto END;

	return TRUE;	

END:
	odtLog<<wszTestCaseInitFail;
	return FALSE;
}


//--------------------------------------------------------------------
//@mfunc: Terminate release the data source object, DB Session object, Command object
//
BOOL TCICMDPRPT::Terminate()
{
	// Release the objects
	SAFE_RELEASE(m_pICommandProperties);
	SAFE_RELEASE_(m_pICommand);

	return (COLEDB::Terminate());
}


//--------------------------------------------------------------------
// @cmember Recreate a new command object, start from scratch
//
BOOL TCICMDPRPT::ResetProperties()
{
	//Release the objects
	SAFE_RELEASE(m_pIRowsetInfo);
	SAFE_RELEASE(m_pICommandText);
	SAFE_RELEASE(m_pICommandProperties);
	SAFE_RELEASE(m_pICommand);

	//Create CommandObject
	if(!CHECK(g_pIDBCreateCommand->CreateCommand(NULL,IID_ICommand,(IUnknown **)&m_pICommand),S_OK))
	{
		COMPARE(m_pICommand, NULL);
		return FALSE;
	}

	//QueryInterface for ICommandProperties
	if(!CHECK(m_pICommand->QueryInterface(IID_ICommandProperties,
											(LPVOID *)&m_pICommandProperties), S_OK))
	{
		odtLog<<wszCMDInterfaceNotSupported;
		SAFE_RELEASE_(m_pICommand);
		return FALSE;
	}

	return TRUE;
}
	

//--------------------------------------------------------------------
//@mfunc: Open a rowset and initialize m_pIRowset.  OpenRowset has to be called
//			after CreateTable().
//
BOOL	TCICMDPRPT::OpenRowset(EQUERY eSQLStmt)
{
	HRESULT hr = E_FAIL;

	//Make sure a select statement has been set up
	if(!m_pICommandText)
		if(!ReadyToExecute(eSQLStmt))
			goto END;

	hr=m_pICommand->Execute(NULL,IID_IRowsetInfo,NULL,NULL,(IUnknown **)&m_pIRowsetInfo);
		
	// The Execute may fail
	if( ((hr == S_OK) && (m_pIRowsetInfo)) ||
		((hr == DB_E_ERRORSOCCURRED) && (!m_pIRowsetInfo)) )
	{
		// If the Execute failed, get the DBPROPSET_PROPERTIESINERROR errors
		if(hr == DB_E_ERRORSOCCURRED)
			odtLog << L"The Execute failed" <<ENDL;

		return TRUE;
	}

END:
	return FALSE;
}


//--------------------------------------------------------------------
//@mfunc: release a rowset object
//
BOOL	TCICMDPRPT::ReleaseRowset()
{
	// Release the object
	SAFE_RELEASE_(m_pIRowsetInfo);

	return (CleanUpFromExecute());
}
	
//--------------------------------------------------------------------
//mfunc: ReadyToExecute: Set the command text for 
//			the command object.  ReadyToExecute has to be called after
//			CreateTable()
//
BOOL TCICMDPRPT::ReadyToExecute(EQUERY	eSQLStmt)
{
	WCHAR	*wszSelectStmt=NULL;
	BOOL	fPass=FALSE;
	ULONG	cRefCount=0;

	//make sure Init() is called
	if(!m_pICommandProperties)
		goto END;

	//make sure CreateTable( ) is called
	if(!g_pCTable)
		goto END;

	//ask for ICommandText interface
	if(!SUCCEEDED(m_pICommandProperties->QueryInterface(IID_ICommandText,
			(LPVOID *)&m_pICommandText)))
	{
		odtLog<<wszICommandTextNotSupprted;
		goto END;
	}

	//get the SQL Statement
	if(!SUCCEEDED(g_pCTable->CreateSQLStmt(eSQLStmt,NULL,&wszSelectStmt,NULL,NULL)))
		goto END;

	//set the SQL Statement
	if(CHECK(m_pICommandText->SetCommandText(DBGUID_DBSQL, wszSelectStmt),S_OK))
		fPass=TRUE;

END:
	//release the memory for SQL Statement
	PROVIDER_FREE(wszSelectStmt);

	return fPass;
}


//--------------------------------------------------------------------
//@mfunc: Clean Up Command text
//
BOOL TCICMDPRPT::CleanUpFromExecute()
{
	//m_pICommand and m_pICommandProperties are only two interfaces pointers on the command.
	SAFE_RELEASE(m_pICommandText);

	return TRUE;
}


//---------------------------------------------------------------------------------
//base class: base class inherited by TCICMDPRPT_SetProperties
//				and TCICMDPRPT_GetProperties
//
class TCICMDPRPT_ChangeProperties:public TCICMDPRPT
{
	protected:

	//@cmember: The index array of default implied properties.
	//Should be IAccessor, IRowsetInfo, IColumnsInfo, IConvertType, and IRowset
	ULONG m_rgImpPrpt[5];

	//@cmember: Initialization Routine
	virtual BOOL Init();  

	//@cmember: Termination Routine
	virtual BOOL Terminate() {return (TCICMDPRPT::Terminate());};

	//@mfunc: Check to make sure the mandatory interfaces are set
	BOOL	VerifyMandatoryInterfaces();

	//@mfunc: Get the attribute of the property
	EPROPERTYATTR GetPrptAttr(const ULONG cPrpt);

	//@mfunc: Verify the property is set or unset correctly
	virtual BOOL VerifyProperty(ULONG cPrpt,BOOL fIReadData=FALSE,ULONG cImpPrpt=0,
						ULONG rgIDXPrpt[]=NULL){return TRUE;};

	//@mfunc: Verify the implied properties
	virtual BOOL VerifyImpliedProperties(ULONG cImpPrpt,ULONG rgIDXPrpt[]){return TRUE;};

	//@mfunc: Verify the interface is mandatory
	BOOL	VerifyInterfaceMandatory(ULONG	cPrpt,BOOL fIReadData);

	//@mfunc: Verify the rowset property set on a particular column
	BOOL	VerifyRowsetColumn(ULONG	cPrpt);

	//@mfunc: Verify the command property is not supported
	BOOL	VerifyNotSupported(ULONG cPrpt, EPROPERTYATTR ePrptAttr);

	//@mfunc: Verify the interface property is supported
	BOOL	VerifyInterfaceSupported(ULONG cPrpt,BOOL fIReadData=FALSE,
				ULONG cImpPrpt=0,ULONG rgIDXPrpt[]=NULL, BOOL fSet=TRUE);

	//@mfunc: Verify rowset property is supported and not settable
	BOOL	VerifyRowsetSettable(ULONG cPrpt,BOOL fIReadData=FALSE,
				ULONG cImpPrpt=0,ULONG rgIDXPrpt[]=NULL, BOOL fSet=TRUE);

	//@mfunc: Verify rowset property is supported and settable
	BOOL	VerifyRowsetNotSettable(ULONG cPrpt,BOOL fIReadData=FALSE,
				ULONG cImpPrpt=0,ULONG rgIDXPrpt[]=NULL, BOOL fSet=TRUE);

	public:
		//Constructor
		TCICMDPRPT_ChangeProperties(WCHAR *wstrTestCaseName);

		//Destructor
		virtual ~TCICMDPRPT_ChangeProperties();
};


//--------------------------------------------------------------------
// @mfunc base class TCICMDPRPT constructor, must take testcase name
//			as parameter.
//
TCICMDPRPT_ChangeProperties::TCICMDPRPT_ChangeProperties(WCHAR * wstrTestCaseName)	//Takes TestCase Class name as parameter
						: TCICMDPRPT (wstrTestCaseName) 
{
}


//--------------------------------------------------------------------
// @mfunc base class TCICMDPRPT destructor
//
TCICMDPRPT_ChangeProperties::~TCICMDPRPT_ChangeProperties()
{
}

//--------------------------------------------------------------------
// @mfunc Init: set up the default implied properties
//
BOOL TCICMDPRPT_ChangeProperties::Init()
{
	if(TCICMDPRPT::Init())
	{
		m_rgImpPrpt[0]=IDX_IACCESSOR;
		m_rgImpPrpt[1]=IDX_IROWSETINFO;
		m_rgImpPrpt[2]=IDX_ICOLUMNSINFO;
		m_rgImpPrpt[3]=IDX_IROWSET;
		m_rgImpPrpt[4]=IDX_ICONVERTTYPE;

		return TRUE;
	}

	return FALSE;
}

//--------------------------------------------------------------------
//@mfunc: Get the attribute of the property
//
EPROPERTYATTR TCICMDPRPT_ChangeProperties::GetPrptAttr(const ULONG cPrpt)
{
	BOOL	fInterface=FALSE;
	
	if(cPrpt >= g_cDBProperties)
		return PROPERTY_INVALID;

	//Return INTERFACE_MANDATORY for IAccessor, IColumnsInfo, IRowsetInfo,
	//	IRowset, and IConvertType
	if(	(cPrpt==(ULONG)IDX_IACCESSOR) ||
		(cPrpt==(ULONG)IDX_ICOLUMNSINFO) ||
		(cPrpt==(ULONG)IDX_IROWSETINFO)	||
		(cPrpt==(ULONG)IDX_ICONVERTTYPE) ||
		(cPrpt==(ULONG)IDX_IROWSET)
	  )
		return INTERFACE_MANDATORY;

	if(cPrpt >= (ULONG)IDX_INTERFACE_START &&
		cPrpt <= (ULONG)IDX_INTERFACE_END)
		fInterface=TRUE;

	//Check if the property is supported
	if(((cPrpt < IDX_ROWSET_START) || (cPrpt > IDX_ROWSET_END)) ||
	   (!(g_rgDBProperties[cPrpt].fSupported)))
		if(fInterface)
			return INTERFACE_NOT_SUPPORTED;
		else
			return ROWSET_NOT_SUPPORTED;
	
	//Check if the property is settable
	if(g_rgDBProperties[cPrpt].fSettable)
		//Interface property is always settable
		if(fInterface)
			return INTERFACE_SUPPORTED;
		else
			return ROWSET_SETTABLE;

	return (ROWSET_NOT_SETTABLE);
}


//--------------------------------------------------------------------------------
//@ mfunc: Check to make sure the mandatory interfaces are set
//
BOOL TCICMDPRPT_ChangeProperties::VerifyMandatoryInterfaces()
{

	ULONG				cPrpt;
	DBPROPID			DBPropID;
	DBPROPIDSET			DBPropIDSet;
	ULONG				cPropertySets;
	DBPROPSET			*pPropertySets=NULL;
	const GUID			*pGuidProperty;
	IUnknown			*pIUnknown;
	BOOL				fTest=FALSE;

	//Init DBPropIDSet
	DBPropIDSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPropIDSet.cPropertyIDs=1;
	DBPropIDSet.rgPropertyIDs=&DBPropID;

	//Get each of the mandatory interfaces
	for(cPrpt=0;cPrpt<5;cPrpt++)
	{
		DBPropID=g_rgDBProperties[m_rgImpPrpt[cPrpt]].dwPropertyID;

		//Call GetProperties to verify the property is set
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPropIDSet,
			&cPropertySets,&pPropertySets),S_OK))
			goto END;

		//Only one set will come back
		if(!COMPARE(cPropertySets,1))
			goto END;

		//Only one property will come back
		if(!COMPARE(pPropertySets->cProperties,1))
			goto END;

		if(!COMPARE(V_BOOL(&pPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;

		//Release the memory for next use
		FreeProperties(&cPropertySets,&pPropertySets);

		//Call GetProperties to verify the property is set
		if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
			&cPropertySets,&pPropertySets),S_OK))
			goto END;

		//Only one set will come back
		if(!COMPARE(cPropertySets,1))
			goto END;

		//Only one property will come back
		if(!COMPARE(pPropertySets->cProperties,1))
			goto END;

		if(!COMPARE(V_BOOL(&pPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;

		//Release the memory for next use
		FreeProperties(&cPropertySets,&pPropertySets);

		//Get the guid for the interface
		pGuidProperty=GetGuidPointer(m_rgImpPrpt[cPrpt]);

		//Call Queryinterface to verify that the property is set
		//if the property is an interface property
		if(!CHECK(m_pIRowsetInfo->QueryInterface(*pGuidProperty,
					(LPVOID *)&pIUnknown),S_OK)) 
				goto END;

		SAFE_RELEASE(pIUnknown);

		fTest=TRUE;
	}

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&pPropertySets);

	if(fTest && (cPrpt==5))
		return TRUE;
	else
		return FALSE;
}


//------------------------------------------------------------------------------------
// @cmember: Verify the interface is mandatory
//
BOOL	TCICMDPRPT_ChangeProperties::VerifyInterfaceMandatory(ULONG	cPrpt,BOOL fIReadData)
{
	DBPROPIDSET			DBPropIDSet;
	DBPROPID			DBPropID;
	DBPROPSET			DBPropSet;
	DBPROP				DBProp;
	DBPROPSET			*pDBPropSet=NULL;
	ULONG				cDBPrpt=0;
	BOOL				fTest=FALSE;

	//Reset the command objects
	if(!ResetProperties())
		return FALSE;

	//Init
	DBPropIDSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPropIDSet.cPropertyIDs=1;
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;

	//Set property to TRUE should return NOTSETTABLE
	//Set DBPropSet
	if(!InitDBPropSet(cPrpt,&DBPropSet,TRUE))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet), DB_E_ERRORSOCCURRED))
		goto END;

	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_NOTSETTABLE,TRUE))
		goto END;

	//Set property to FALSE should return NOTSETTABLE
	if(!InitDBPropSet(cPrpt,&DBPropSet,FALSE))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet), S_OK))
		goto END;

	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,FALSE))
		goto END;

	//Get property always returns TRUE

	//set DBPROPIDSET
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
			&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//One property set should be returned
	if(!COMPARE(cDBPrpt,1))
		goto END;

	//The property should always be set
	if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,FALSE))
		goto END;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fTest=TRUE;

	ReleaseRowset();

END:
	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}

//------------------------------------------------------------------------------------
//@mfunc: Verify the rowset property set on a particular column
//
BOOL	TCICMDPRPT_ChangeProperties::VerifyRowsetColumn(ULONG	cPrpt)
{
	IColumnsInfo	*pIColumnsInfo=NULL;
	ICommandPrepare	*pICommandPrepare=NULL;
	DBORDINAL		cColumns;
	DBCOLUMNINFO	*pColumnsInfo;
	WCHAR			*pwStrings;
	ULONG			cDBPrpt;
	DBPROPIDSET		DBPropIDSet;
	DBPROPID		DBPropID;
	DBPROPSET		DBPropSet;
	DBPROP			DBProp;
	DBPROPSET		*pDBPropSet=NULL;
	BOOL			fPass=FALSE;

	//Make sure it is supported
	if(	!(g_rgDBProperties[cPrpt].fSupported) ||
		!(g_rgDBProperties[cPrpt].fSettable))
		return TRUE;

	if(!ResetProperties())
		return FALSE;

	//Init
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;

	//Set DBPropSet
	if(!InitDBPropSet(cPrpt,&DBPropSet,TRUE))
		return FALSE;

	//Set up a select * statement
	if(!ReadyToExecute())
		return FALSE;

	//Ask for ICommandPrepare interface
	if(!CHECK(m_pICommandProperties->QueryInterface(IID_ICommandPrepare,
		(LPVOID *)&pICommandPrepare),S_OK))
		goto END;

	//Prepare the query so that IColumndInfo will return valid information
	if(!CHECK(pICommandPrepare->Prepare(1),S_OK))
		goto END;

	//Ask for IColumnsInfo interface
	if(!CHECK(m_pICommandProperties->QueryInterface(IID_IColumnsInfo,
		(LPVOID *)&pIColumnsInfo),S_OK))
		goto END;

	//Ask for the columns ID of the first column
	if(!CHECK(pIColumnsInfo->GetColumnInfo(&cColumns,&pColumnsInfo,&pwStrings),S_OK))
		goto END;

	//Have to have columns in the table
	if(!cColumns)
		goto END;
	
	//Try to set the property
	memcpy(&(DBPropSet.rgProperties->colid),
		&(pColumnsInfo[1].columnid),sizeof(DBID));

	//Unprepare
	if(!CHECK(pICommandPrepare->Unprepare(),S_OK))
		goto END;

	//Set the property with the first column deferred
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet),S_OK))
		goto END;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//Set DBPROPIDSET
	if(!InitDBPropIDSet(cPrpt, &DBPropIDSet))
		goto END;

	//Verify the property is set correctly
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
		&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	if(CompareDBID(pDBPropSet->rgProperties->colid,
		pColumnsInfo[1].columnid))
		fPass=TRUE;
	
END:
	//Free memory
	PROVIDER_FREE(pColumnsInfo);
	PROVIDER_FREE(pwStrings);

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);

	//Release the objects
	SAFE_RELEASE(pICommandPrepare);
	SAFE_RELEASE(pIColumnsInfo);
	ReleaseRowset();

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}

//------------------------------------------------------------------------------------
// @cmember: Verify the property is not supported
//
BOOL TCICMDPRPT_ChangeProperties::VerifyNotSupported(
ULONG cPrpt,				//@[in]: The index to g_rgDBProperties array
EPROPERTYATTR ePrptAttr		//@[in]: Either INTERFACE_NOT_SUPPORTED or ROWSET_NOT_SUPPORTED
)
{
	DBPROPIDSET			DBPropIDSet;
	DBPROPID			DBPropID;
	DBPROPSET			DBPropSet;
	DBPROP				DBProp;
	DBPROPSET			*pDBPropSet=NULL;
	ULONG				cDBPrpt=0;
	IUnknown			*pIUnknown;
	BOOL				fPass=FALSE;

	//Create a new command object, start from scratch
	if(!ResetProperties())
		return FALSE;

	if(ePrptAttr!=INTERFACE_NOT_SUPPORTED && ePrptAttr!=ROWSET_NOT_SUPPORTED)
		return FALSE;

	//Init
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;

	//If the property is a mandatory interface, it has to be supported
	if(!PassAsNotSupported(g_rgDBProperties[cPrpt].dwPropertyID))
		return FALSE;

	//Try to unset the property
	//Init DBPropSet
	if(!InitDBPropSet(cPrpt,&DBPropSet,FALSE))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet), DB_E_ERRORSOCCURRED))
		goto END;

	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_NOTSUPPORTED,FALSE))
		goto END;

	//Try to set the property
	if(!InitDBPropSet(cPrpt,&DBPropSet,TRUE))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet), DB_E_ERRORSOCCURRED))
		goto END;

	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_NOTSUPPORTED,TRUE))
		goto END;
	
	//Verify that the property is not supported by calling GetProperties
	//set DBPROPIDSET
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
		&cDBPrpt,&pDBPropSet), DB_E_ERRORSOCCURRED))
		goto END;

	if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_NOTSUPPORTED,TRUE))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	
	//Open a rowset
	if(!OpenRowset())
		goto END;

	// Check the pointer the property my conflict
	if(!m_pIRowsetInfo)
	{
		fPass=TRUE;
		goto END;
	}

	//Call Queryinterface if the property is an interface property
	if(ePrptAttr==INTERFACE_NOT_SUPPORTED)
	{
		if(!CHECK(m_hr=m_pIRowsetInfo->QueryInterface(*(GetGuidPointer(cPrpt)),
			(LPVOID *)&pIUnknown), E_NOINTERFACE))
		{	
			if(SUCCEEDED(m_hr))
				SAFE_RELEASE(pIUnknown);
			goto END;
		}

		//pIUnknown should be NULL
		if(!COMPARE(pIUnknown, NULL))
			goto END;
	}

	//Call GetRowsetInfo to verify that the property is not supported
	if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPropIDSet,&cDBPrpt,
				&pDBPropSet), DB_E_ERRORSOCCURRED))
			goto END;

	if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_NOTSUPPORTED,TRUE))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	
	//Verify that the property is not supported by calling GetProperties
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,&cDBPrpt,
				&pDBPropSet), DB_E_ERRORSOCCURRED))
		goto END;

	if(VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_NOTSUPPORTED,TRUE))
		fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	ReleaseRowset();
	return (fPass);
}
	

//-------------------------------------------------------------------------------------
// @cmember: Verify the interface property is supported
//
BOOL TCICMDPRPT_ChangeProperties::VerifyInterfaceSupported
(ULONG	cPrpt,			//@[in]: The index to g_rgDBProperties array
 BOOL	fIReadData,
 ULONG	cImpPrpt,		//@[in]: The count of implied properties
 ULONG	rgIDXPrpt[],	//@[in]: The index array of implied properties
 BOOL	fSet			//@[in]: To set or unset the property
)
{
	DBPROPIDSET			DBPropIDSet;
	DBPROPID			DBPropID;
	DBPROPSET			DBPropSet;
	DBPROP				DBProp;
	DBPROPSET			*pDBPropSet=NULL;
	ULONG				cDBPrpt;
	IUnknown			*pIUnknown;
	BOOL				fPass=FALSE;

	//Create a new command object, start from scratch
	if(!ResetProperties())
		goto END;

	//Init
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;
	
	//Set the property to the default value using VT_EMPTY
	if(!InitDBPropSet(cPrpt,&DBPropSet,2))
		goto END;

	//Set the properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet),
				S_OK))
		goto END;

	//Get the property and check the default values
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
				&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Verify the result against its default values
	if(!VerifyDBPropDefault(cPrpt,pDBPropSet,FALSE))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);

	//Set the property with dwOptions = DBPROPOPTIONS_SETIFCHEAP
	if(!InitDBPropSet(cPrpt,&DBPropSet,3))
		goto END;

	//Set the properties
	m_hr = m_pICommandProperties->SetProperties(1,&DBPropSet);

	//As long as we get back S_OK with status = OK or
	if( m_hr == S_OK )
	{
		if(!COMPARE(DBProp.dwStatus,DBPROPSTATUS_OK))
			goto END;
	}
	else
	{
		//DB_E_ERRORSOCCURRED with NOTSET it succeeded.
		if( m_hr == DB_E_ERRORSOCCURRED )
		{
			if(!COMPARE(DBProp.dwStatus,DBPROPSTATUS_NOTSET))
				goto END;
		}
		else
			goto END;
	}

	//Verify the result. Status was already verified and 
	//fSet=3 that which is the same as fSet=TRUE
	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBProp.dwStatus,3))
		goto END;
	
	//Set the property 
	//Init DBPropSet
	if(!InitDBPropSet(cPrpt,&DBPropSet,TRUE))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet),S_OK))
		goto END;

	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,TRUE))
		goto END;

	//Initialization to set/unset the property
	if(!fSet)
	{
		if(!InitDBPropSet(cPrpt,&DBPropSet,FALSE))
			goto END;
	}

	//Try to set/unset the property
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet),S_OK))
		goto END;

	if(fSet)
	{
		if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,TRUE))
			goto END;
	}
	else
	{
		 if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,FALSE))
			goto END;
	}

	//Verify that the property is set/unset by calling GetProperties
	//Init DBPOPRID
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
		&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Only one set is returned
	if(!COMPARE(cDBPrpt,1))
		goto END;

	//Make sure the property is set/unset
	if(fSet)
	{
		if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK, TRUE))
			goto END;
	}
	else
	{
		if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK, FALSE))
			goto END;
	}

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	if(m_pIRowsetInfo)
	{
		if((fSet) && (V_BOOL(&g_rgDBProperties[cPrpt].vDefault) == VARIANT_FALSE))
		{	//If the interface is set
			if( (g_rgDBProperties[cPrpt].dwPropertyID!=DBPROP_ISequentialStream) &&
				(g_rgDBProperties[cPrpt].dwPropertyID!=DBPROP_IStream) &&
				(g_rgDBProperties[cPrpt].dwPropertyID!=DBPROP_IStorage) &&
				(g_rgDBProperties[cPrpt].dwPropertyID!=DBPROP_ILockBytes) )
			{
				if(!CHECK(m_pIRowsetInfo->QueryInterface(*GetGuidPointer(cPrpt),
					(LPVOID *)&pIUnknown),S_OK))
						goto END;
				SAFE_RELEASE(pIUnknown);
			}
		}
		else
		{	//If the interface is not set, it is still possibly set by the provider
			m_hr=m_pIRowsetInfo->QueryInterface(*GetGuidPointer(cPrpt),
					(LPVOID *)&pIUnknown);

			if(SUCCEEDED(m_hr))
				SAFE_RELEASE(pIUnknown);
		}

		//Call GetRowsetInfo to verify the property is set/unset
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPropIDSet,&cDBPrpt,
				&pDBPropSet),S_OK))
			goto END;

		//Only one property set is returned
		if(!COMPARE(cDBPrpt,1))
			goto END;

		//Make sure the property is set/unset
		if(fSet)
		{
			if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,TRUE))
				goto END;
		}
		else
		{
			if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,FALSE))
				goto END;
		}

		//Free memory from GetProperties
		FreeProperties(&cDBPrpt,&pDBPropSet);

		//Check for mandatory interfaces
		if(!VerifyMandatoryInterfaces())
			goto END;
	}

	//Call GetProperties to verify the property is set/unset
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
			&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Only one property set is returned
	if(!COMPARE(cDBPrpt,1))
		goto END;

	//Make sure the property is set/unset
	if(fSet)
	{
		if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,TRUE))
			goto END;
	}
	else
	{
		if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,FALSE))
			goto END;
	}
	
	//Check for the implied properties.  If the property is set, the implied properties
	//shoud be set.
	if(cImpPrpt)
		if(!VerifyImpliedProperties(cImpPrpt,rgIDXPrpt))
			goto END;

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	ReleaseRowset();
	return fPass;
}


//-------------------------------------------------------------------------------------
// @cmember: Verify the rowset property is not settable
//
BOOL TCICMDPRPT_ChangeProperties::VerifyRowsetNotSettable
(ULONG	cPrpt,			//@[in]: The index to g_rgDBProperties array
 BOOL fIReadData,
 ULONG	cImpPrpt,		//@[in]: The count of implied properties
 ULONG	rgIDXPrpt[],	//@[in]: The index array of implied properties
 BOOL	fSet			//@[in]: To set or unset the property	
 )
{
	DBPROPIDSET	DBPropIDSet;
	DBPROPID	DBPropID;
	DBPROPSET	DBPropSet;
	DBPROP		DBProp;
	DBPROPSET	*pDBPropSet=NULL;
	ULONG		cDBPrpt=0;
	BOOL		fPass=FALSE;
	HRESULT		hr=S_OK;

	//Create a new command object, start from scratch
	if(!ResetProperties())
		return FALSE;

	//Initialization
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;

	//Initialization to set/unset the property
	if(fSet)
		hr = DB_E_ERRORSOCCURRED;
	else
		hr = S_OK;

	if(!InitDBPropSet(cPrpt,&DBPropSet,fSet))
		goto END;

	//Try to set the property
	m_hr=m_pICommandProperties->SetProperties(1,&DBPropSet);

	//Check for the ReturnCode
	if(SUCCEEDED(m_hr) && fSet && CHECKW(m_hr, hr))
		odtLog <<wszPropertySet;
	else
		CHECK(m_hr, hr);

	//Verify the status value
	// If GetPropertyInfo lied about ReadOnly
	if(!VerifyDBPropSet(cPrpt,&DBPropSet,(FAILED(m_hr) ? DBPROPSTATUS_NOTSETTABLE : DBPROPSTATUS_OK),fSet))
		goto END;

	//Verify the property before execution by calling GetProperties.  
	//Init DBPROPIDSET
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
				&cDBPrpt,&pDBPropSet), S_OK))
		goto END;

	//Only one set should return
	if(!COMPARE(cDBPrpt, 1))
		goto END;

	//Verify the result against its default values
	if(!VerifyDBPropDefault(cPrpt,pDBPropSet,(FAILED(m_hr) ? FALSE : TRUE)))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	
	if(!InitDBPropSet(cPrpt,&DBPropSet,FALSE))
		goto END;

	//Try to set to the default property
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet), S_OK))
		goto END;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	if(m_pIRowsetInfo)
	{
		//Call GetRowsetInfo to retrieve rowset property info
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPropIDSet,&cDBPrpt,
					&pDBPropSet),S_OK))
			goto END;

		//Only one set should return
		if(!COMPARE(cDBPrpt, 1))
			goto END;

		//Verify the result against its default values
		if(!VerifyDBPropDefault(cPrpt,pDBPropSet,TRUE))
			goto END;

		//Free memory from GetProperties
		FreeProperties(&cDBPrpt,&pDBPropSet);

		//Check for mandatory interfaces
		if(!VerifyMandatoryInterfaces())
			goto END;
	}

	//Call GetProperties to retrieve rowset property info
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,&cDBPrpt,
				&pDBPropSet),S_OK))
		goto END;

	//Only one set should return
	if(!COMPARE(cDBPrpt, 1))
		goto END;

	//Verify the result against its default values
	if(!VerifyDBPropDefault(cPrpt,pDBPropSet,TRUE))
		goto END;

	//Check for the implied properties.  If the property is set, the implied properties
	//shoud be set.
	//We are verifying unsettable property, so only if the default is TRUR, the implied properties
	//would be true.
	if(cImpPrpt && (g_rgDBProperties[cPrpt].vDefault.boolVal==VARIANT_TRUE) && fSet)
		if(!VerifyImpliedProperties(cImpPrpt,rgIDXPrpt))
			fPass=FALSE;

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	ReleaseRowset();
	return (fPass);
}

//-------------------------------------------------------------------------------------
// @cmember: Verify the rowset property is settable
//
BOOL TCICMDPRPT_ChangeProperties::VerifyRowsetSettable
(ULONG	cPrpt,			//@[in]: The index to g_rgDBProperties array
 BOOL fIReadData,
 ULONG	cImpPrpt,		//@[in]: The count of implied properties
 ULONG	rgIDXPrpt[],	//@[in]: The index array of implied properties
 BOOL	fSet			//@[in]: To set or unset property	
 )
{
	DBPROPIDSET			DBPropIDSet;
	DBPROPID			DBPropID;
	DBPROPSET			DBPropSet;
	DBPROP				DBProp;
	DBPROPSET			*pDBPropSet=NULL;
	ULONG				cDBPrpt=0;
	BOOL				fPass=FALSE;

	//Create a new command object, start from scratch
	if(!ResetProperties())
		return FALSE;

	//Initialization
	DBPropIDSet.rgPropertyIDs=&DBPropID;
	DBPropSet.rgProperties=&DBProp;

	//Set the property to the default value using VT_EMPTY
	if(!InitDBPropSet(cPrpt,&DBPropSet,2))
		goto END;

	//Set the properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPropSet),
				S_OK))
		goto END;

	//Get the property and check the default values
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
				&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Verify the result against its default values
	if(!VerifyDBPropDefault(cPrpt,pDBPropSet,FALSE))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);

	//Set the property with dwOptions = DBPROPOPTIONS_SETIFCHEAP
	if(!InitDBPropSet(cPrpt,&DBPropSet,3))
		goto END;

	//Set the properties
	m_hr = m_pICommandProperties->SetProperties(1,&DBPropSet);

	//As long as we get back S_OK with status = OK or
	if( m_hr == S_OK )
	{
		if(!COMPARE(DBProp.dwStatus,DBPROPSTATUS_OK))
			goto END;
	}
	else
	{
		//DB_S_ERRORSOCCURRED with NOTSET it succeeded.
		if( m_hr == DB_E_ERRORSOCCURRED )
		{
			if(!COMPARE(DBProp.dwStatus,DBPROPSTATUS_NOTSET))
				goto END;
		}
		else
			goto END;
	}

	//Verify the result. Status was already verified and 
	//fSet=3 that which is the same as fSet=TRUE
	if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBProp.dwStatus,3))
		goto END;
	
	//Try to set the property
	if(!InitDBPropSet(cPrpt,&DBPropSet,TRUE))
		goto END;

	//Set the properties
	//For the same reason above, set bogus string could return DB_E_ERRORSOCCURRED 
	//and status DBPROPSTATUS_BADVALUE
	m_hr = m_pICommandProperties->SetProperties(1,&DBPropSet);

	//As long as we get back S_OK with status = OK or
	if( m_hr == S_OK )
	{
		//Verify the result
		if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,TRUE))
			goto END;
	}
	else
	{
		//DB_E_ERRORSOCCURRED with BADVALUE it succeeded.
		if( m_hr == DB_E_ERRORSOCCURRED )
		{
			//Verify the result
			if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_BADVALUE,TRUE))
				goto END;
		}
		else
			goto END;
	}
	
	//Try to set/unset the property
	//Initialization
	if(!fSet)
		 if(!InitDBPropSet(cPrpt,&DBPropSet,FALSE))
			goto END;

	//for the same reason as above, setProperties may fail with BADVALUE.
	m_hr = m_pICommandProperties->SetProperties(1,&DBPropSet);
	if( (m_hr != S_OK) && (m_hr != DB_E_ERRORSOCCURRED) )
		goto END;
	
	//Verify the result
	if( m_hr == S_OK )
	{
		if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_OK,fSet))
			goto END;
	}
	else
	{
		if(!VerifyDBPropSet(cPrpt,&DBPropSet,DBPROPSTATUS_BADVALUE,fSet))
			goto END;
		
		// Set to False since the SetProperties Failed
		fSet = FALSE;
	}

	//Verify that the property is set/unset by calling GetProperties
	//Init DBPROPID
	if(!InitDBPropIDSet(cPrpt,&DBPropIDSet))
		goto END;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
				&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Make sure GetProperties returns the same value as SetPropeties.  
	if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,fSet))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	
	//Open a rowset
	if(!OpenRowset())
		goto END;

	// Check the rowset pointer
	if(m_pIRowsetInfo)
	{
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPropIDSet,
					&cDBPrpt,&pDBPropSet),S_OK))
			goto END;

		//Make sure the information returned is correct
		if(!COMPARE(cDBPrpt,1))
			goto END;

		//Make sure GetProperties returns the same value as SetPropeties.  
		if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,fSet))
			goto END;

		//Free memory from GetProperties
		FreeProperties(&cDBPrpt,&pDBPropSet);

		//Check for mandatory interfaces
		if(!VerifyMandatoryInterfaces())
			goto END;
	}

	//Call GetProperties to retrieve rowset property info
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPropIDSet,
				&cDBPrpt,&pDBPropSet),S_OK))
		goto END;

	//Make sure the information returned is correct
	if(!COMPARE(cDBPrpt,1))
		goto END;

	//Make sure GetProperties returns the same value as SetPropeties.  
	if(!VerifyDBPropGet(cPrpt,pDBPropSet,DBPROPSTATUS_OK,fSet))
		goto END;

	//Check for the implied properties.  If the property is set, the implied properties
	//shoud be set.
	if(cImpPrpt)
		if(!VerifyImpliedProperties(cImpPrpt,rgIDXPrpt))
			goto END;

	//Make sure we can set the property on a particular column
	if(g_rgDBProperties[cPrpt].fColumnOK)
		if(!VerifyRowsetColumn(cPrpt))
			goto END;

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cDBPrpt,&pDBPropSet);
	ReleaseRowset();
	return fPass;
}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Test Case Section
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_BulkProcess)
//--------------------------------------------------------------------
// @class Use array of GUIDs and DBProperties
//
class TCICMDPRPT_BulkProcess : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_BulkProcess,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();

	//@cmember: Get a setttable rowset property
	BOOL	RowsetSettable(DBPROPID *dwPropertyID);

	//@cmember: Get a not setttable rowset property
	BOOL	RowsetNotSettable(DBPROPID *dwPropertyID, ULONG *ulPropIdx);

	//@cmember: Get a not supported rowset property
	BOOL	RowsetNotSupported(DBPROPID *dwPropertyID);

	//@cmember: Get a not supported interface property
	BOOL	InterfaceNotSupported(DBPROPID *dwPropertyID);

	//@cmember: Get a supported interface property
	BOOL	InterfaceSupported(DBPROPID *dwPropertyID);

	//@cmember: Get a supported Kagera property
	BOOL	KageraSupported(DBPROPID *dwPropertyID);

	// {{ TCW_TESTVARS()
	// @cmember cProperties==0
	int Variation_1();
	// @cmember GetProperties returns correct info for array of properties in the same property set
	int Variation_2();
	// @cmember SetProperties set array of properties in the same property set
	int Variation_3();
	// @cmember Duplicated property IDs
	int Variation_4();
	// @cmember MAXROWS >= MAXOPENROWS verified with two GetProperties calls
	int Variation_5();
	// @cmember GetProperties returns correct info for array of properties in different property sets
	int Variation_6();
	// @cmember SetProperties sets array of properties in different property sets
	int Variation_7();
	// @cmember Set all Interface properties with DBPROPOPTIONS_OPTIONAL
	int Variation_8();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_BulkProcess)
#define THE_CLASS TCICMDPRPT_BulkProcess
BEG_TEST_CASE(TCICMDPRPT_BulkProcess, TCICMDPRPT, L"Use array of GUIDs and DBProperties")
	TEST_VARIATION(1,		L"cProperties==0")
	TEST_VARIATION(2,		L"GetProperties returns correct info for array of properties in the same property set")
	TEST_VARIATION(3,		L"SetProperties set array of properties in the same property set")
	TEST_VARIATION(4,		L"Duplicated property IDs")
	TEST_VARIATION(5,		L"MAXROWS >= MAXOPENROWS verified with two GetProperties calls")
	TEST_VARIATION(6,		L"GetProperties returns correct info for array of properties in different property sets")
	TEST_VARIATION(7,		L"SetProperties sets array of properties in different property sets")
	TEST_VARIATION(8,		L"Set all Interface properties with DBPROPOPTIONS_OPTIONAL")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_SetProperties)
//--------------------------------------------------------------------
// @class set all interface and rowset properties
//
class TCICMDPRPT_SetProperties : public TCICMDPRPT_ChangeProperties {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();

	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_SetProperties,TCICMDPRPT_ChangeProperties);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	//@cmember Verify the impled properties are set correctly
	virtual BOOL VerifyImpliedProperties(ULONG cImpPrpt,ULONG rgIDXPrpt[]);	
	// @mfunc: Verify the attrbute of the property
	virtual BOOL VerifyProperty(ULONG cPrpt,BOOL fIReadData=FALSE,ULONG cImpPrpt=0,
						ULONG rgIDXPrpt[]=NULL);

	// {{ TCW_TESTVARS()
	// @cmember set DBPROP_ACTIVESESSIONS
	int Variation_1();
	// @cmember set DBPROP_ASYNCTXNABORT
	int Variation_2();
	// @cmember set DBPROP_ASYNCTXNCOMMIT
	int Variation_3();
	// @cmember set DBPROP_BYREFACCESSORS
	int Variation_4();
	// @cmember set DBPROP_CATALOGLOCATION
	int Variation_5();
	// @cmember set DBPROP_CATALOGTERM
	int Variation_6();
	// @cmember set DBPROP_CATALOGUSAGE
	int Variation_7();
	// @cmember set DBPROP_COLUMNDEFINITION
	int Variation_8();
	// @cmember set DBPROP_CONCATNULLBEHAVIOR
	int Variation_9();
	// @cmember set DBPROP_DATASOURCENAME
	int Variation_10();
	// @cmember set DBPROP_DATASOURCEREADONLY
	int Variation_11();
	// @cmember set DBPROP_DBMSNAME
	int Variation_12();
	// @cmember set DBPROP_DBMSVER
	int Variation_13();
	// @cmember set DBPROP_DSOTHREADMODEL
	int Variation_14();
	// @cmember set DBPROP_GROUPBY
	int Variation_15();
	// @cmember set DBPROP_HETEROGENEOUSTABLES
	int Variation_16();
	// @cmember set DBPROP_IDENTIFIERCASE
	int Variation_17();
	// @cmember set DBPROP_MAXINDEXSIZE
	int Variation_18();
	// @cmember set DBPROP_MAXOPENCHAPTERS
	int Variation_19();
	// @cmember set DBPROP_MAXORSINFILTER
	int Variation_20();
	// @cmember set DBPROP_MAXROWSIZE
	int Variation_21();
	// @cmember set DBPROP_MAXROWSIZEINCLUDESBLOB
	int Variation_22();
	// @cmember setDBPROP_MAXSORTCOLUMNS
	int Variation_23();
	// @cmember set DBPROP_MAXTABLESINSELECT
	int Variation_24();
	// @cmember set DBPROP_MULTIPLEPARAMSETS
	int Variation_25();
	// @cmember set DBPROP_MULTIPLERESULTS
	int Variation_26();
	// @cmember set DBPROP_MULTIPLESTORAGEOBJECTS
	int Variation_27();
	// @cmember set DBPROP_MULTITABLEUPDATE
	int Variation_28();
	// @cmember set DBPROP_NULLCOLLATION
	int Variation_29();
	// @cmember set DBPROP_OLEOBJECTS
	int Variation_30();
	// @cmember set DBPROP_ORDERBYCOLUMNSINSELECT
	int Variation_31();
	// @cmember set DBPROP_OUTPUTPARAMETERAVAILABILITY
	int Variation_32();
	// @cmember set DBPROP_PERSISTENTIDTYPE
	int Variation_33();
	// @cmember set DBPROP_PREPAREABORTBEHAVIOR
	int Variation_34();
	// @cmember set DBPROP_PREPARECOMMITBEHAVIOR
	int Variation_35();
	// @cmember set DBPROP_PROCEDURETERM
	int Variation_36();
	// @cmember set DBPROP_PROVIDERNAME
	int Variation_37();
	// @cmember set DBPROP_PROVIDEROLEDBVER
	int Variation_38();
	// @cmember set DBPROP_PROVIDERVER
	int Variation_39();
	// @cmember set DBPROP_QUOTEDIDENTIFIERCASE
	int Variation_40();
	// @cmember set DBPROP_ROWSETCONVERSIONSONCOMMAND
	int Variation_41();
	// @cmember set DBPROP_SCHEMATERM
	int Variation_42();
	// @cmember set DBPROP_SCHEMAUSAGE
	int Variation_43();
	// @cmember set DBPROP_SORTONINDEX
	int Variation_44();
	// @cmember set DBPROP_SQLSUPPORT
	int Variation_45();
	// @cmember set DBPROP_STRUCTUREDSTORAGE
	int Variation_46();
	// @cmember set DBPROP_SUBQUERIES
	int Variation_47();
	// @cmember set DBPROP_SUPPORTEDTXNDDL
	int Variation_48();
	// @cmember set DBPROP_SUPPORTEDTXNISOLEVELS
	int Variation_49();
	// @cmember set DBPROP_SUPPORTEDTXNISORETAIN
	int Variation_50();
	// @cmember set DBPROP_TABLETERM
	int Variation_51();
	// @cmember set DBPROP_USERNAME
	int Variation_52();
	// @cmember set DBPROP_CURRENTCATALOG
	int Variation_53();
	// @cmember set DBPROP_AUTH_CACHE_AUTHINFO
	int Variation_54();
	// @cmember set DBPROP_AUTH_ENCRYPT_PASSWORD
	int Variation_55();
	// @cmember set DBPROP_AUTH_INTEGRATED
	int Variation_56();
	// @cmember set DBPROP_AUTH_MASK_PASSWORD
	int Variation_57();
	// @cmember set DBPROP_AUTH_PASSWORD
	int Variation_58();
	// @cmember set DBPROP_AUTH_PERSIST_ENCRYPTED
	int Variation_59();
	// @cmember set DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO
	int Variation_60();
	// @cmember set DBPROP_AUTH_USERID
	int Variation_61();
	// @cmember set BPROP_INIT_ASYNCH
	int Variation_62();
	// @cmember set DBPROP_INIT_DATASOURCE
	int Variation_63();
	// @cmember set DBPROP_INIT_HWND
	int Variation_64();
	// @cmember set DBPROP_INIT_IMPERSONATION_LEVEL
	int Variation_65();
	// @cmember set DBPROP_INIT_LCID
	int Variation_66();
	// @cmember set DBPROP_INIT_LOCATION
	int Variation_67();
	// @cmember set DBPROP_INIT_MODE
	int Variation_68();
	// @cmember set DBPROP_INIT_PROMPT
	int Variation_69();
	// @cmember set DBPROP_INIT_PROTECTION_LEVEL
	int Variation_70();
	// @cmember set DBPROP_INIT_PROVIDERSTRING
	int Variation_71();
	// @cmember set DBPROP_INIT_TIMEOUT
	int Variation_72();
	// @cmember set DBPROP_COL_AUTOINCREMENT
	int Variation_73();
	// @cmember set DBPROP_COL_DEFAULT
	int Variation_74();
	// @cmember set DBPROP_COL_DESCRIPTION
	int Variation_75();
	// @cmember set DBPROP_COL_FIXEDLENGTH
	int Variation_76();
	// @cmember set DBPROP_COL_NULLABLE
	int Variation_77();
	// @cmember set DBPROP_COL_PRIMARYKEY
	int Variation_78();
	// @cmember set DBPROP_COL_UNIQUE
	int Variation_79();
	// @cmember set DBPROP_INDEX_AUTOUPDATE
	int Variation_80();
	// @cmember set DBPROP_INDEX_CLUSTERED
	int Variation_81();
	// @cmember set DBPROP_INDEX_FILLFACTOR
	int Variation_82();
	// @cmember set DBPROP_INDEX_INITIALSIZE
	int Variation_83();
	// @cmember set DBPROP_INDEX_NULLCOLLATION
	int Variation_84();
	// @cmember set DBPROP_INDEX_NULLS
	int Variation_85();
	// @cmember set DBPROP_INDEX_PRIMARYKEY
	int Variation_86();
	// @cmember set DBPROP_INDEX_SORTBOOKMARKS
	int Variation_87();
	// @cmember set DBPROP_INDEX_TEMPINDEX
	int Variation_88();
	// @cmember set DBPROP_INDEX_TYPE
	int Variation_89();
	// @cmember set DBPROP_INDEX_UNIQUE
	int Variation_90();
	// @cmember set DBPROP_SESS_AUTOCOMMITISOLEVELS
	int Variation_91();
	// @cmember set DBPROP_TBL_TEMPTABLE
	int Variation_92();
	// @cmember set DBPROP_ABORTPRESERVE
	int Variation_93();
	// @cmember set DBPROP_APPENDONLY
	int Variation_94();
	// @cmember set DBPROP_BLOCKINGSTORAGEOBJECTS
	int Variation_95();
	// @cmember set DBPROP_BOOKMARKS
	int Variation_96();
	// @cmember set DBPROP_BOOKMARKSKIPPED
	int Variation_97();
	// @cmember set DBPROP_BOOKMARKTYPE
	int Variation_98();
	// @cmember set DBPROP_CACHDEFERRED
	int Variation_99();
	// @cmember set DBPROP_CANFETCHBACKWARDS
	int Variation_100();
	// @cmember set DBPROP_CANHOLDROWS
	int Variation_101();
	// @cmember set DBPROP_CANSCROLLBACKWARDS
	int Variation_102();
	// @cmember set DBPROP_CHANGEINSERTEDROWS
	int Variation_103();
	// @cmember set DBPROP_COLUMNRESTRICT
	int Variation_104();
	// @cmember set DBPROP_COMMANDTIMEOUT
	int Variation_105();
	// @cmember set DBPROP_COMMITPRESERVE
	int Variation_106();
	// @cmember set DBPROP_DEFERRED
	int Variation_107();
	// @cmember set DBPROP_DELAYSTORAGEOBJECTS
	int Variation_108();
	// @cmember set DBPROP_FILTERCOMPAREOPS
	int Variation_109();
	// @cmember set DBPROP_FINDCOMPAREOPS
	int Variation_110();
	// @cmember set DBPROP_IMMOBILEROWS
	int Variation_111();
	// @cmember set DBPROP_LITERALBOOKMARKS
	int Variation_112();
	// @cmember set DBPROP_LITERALIDENTITY
	int Variation_113();
	// @cmember set DBPROP_MAXOPENROWS
	int Variation_114();
	// @cmember set DBPROP_MAXPENDINGROWS
	int Variation_115();
	// @cmember set DBPROP_MAXROWS
	int Variation_116();
	// @cmember set DBPROP_MAYWRITECOLUMN
	int Variation_117();
	// @cmember set DBPROP_MEMORYUSAGE
	int Variation_118();
	// @cmember set DBPROP_NOTIFICATIONPHASES
	int Variation_119();
	// @cmember set DBPROP_NOTIFYCOLUMNSET
	int Variation_120();
	// @cmember set DBPROP_NOTIFYROWDELETE
	int Variation_121();
	// @cmember set DBPROP_NOTIFYROWFIRSTCHANGE
	int Variation_122();
	// @cmember set DBPROP_NOTIFYROWINSERT
	int Variation_123();
	// @cmember set DBPROP_NOTIFYROWRESYNCH
	int Variation_124();
	// @cmember set DBPROP_NOTIFYROWSETRELEASE
	int Variation_125();
	// @cmember set DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE
	int Variation_126();
	// @cmember set DBPROP_NOTIFYROWUNDOCHANGE
	int Variation_127();
	// @cmember set DBPROP_NOTIFYUNDODELETE
	int Variation_128();
	// @cmember set DBPROP_NOTIFYUNDOINSERT
	int Variation_129();
	// @cmember set DBPROP_NOTIFYROWUPDATE
	int Variation_130();
	// @cmember set DBPROP_ORDEREDBOOKMARKS
	int Variation_131();
	// @cmember set DBPROP_OTHERINSERT
	int Variation_132();
	// @cmember set DBPROP_OTHERUPDATEDELETE
	int Variation_133();
	// @cmember set DBPROP_OWNINSERT
	int Variation_134();
	// @cmember set DBPROP_OWNUPDATEDELETE
	int Variation_135();
	// @cmember set DBPROP_QUICKRESTART
	int Variation_136();
	// @cmember set DBPROP_REENTRANTEVENTS
	int Variation_137();
	// @cmember set DBPROP_REMOVEDELETED
	int Variation_138();
	// @cmember set DBPROP_REPORTMULTIPLECHANGES
	int Variation_139();
	// @cmember set DBPROP_RETURNPENDINGINSERTS
	int Variation_140();
	// @cmember set DBPROP_ROWRESTRICT
	int Variation_141();
	// @cmember set DBPROP_ROWSET_ASYNCH
	int Variation_142();
	// @cmember set DBPROP_ROWTHREADMODEL
	int Variation_143();
	// @cmember set DBPROP_SERVERCURSOR
	int Variation_144();
	// @cmember set DBPROP_TRANSACTEDOBJECT
	int Variation_145();
	// @cmember set DBPROP_UPDATABILITY
	int Variation_146();
	// @cmember set DBPROP_STRONGIDENTITY
	int Variation_147();
	// @cmember set IID_IAccessor
	int Variation_148();
	// @cmember set IID_IChapteredRowset
	int Variation_149();
	// @cmember set IID_IColumnsInfo
	int Variation_150();
	// @cmember set IID_IColumnsRowset
	int Variation_151();
	// @cmember set IID_IConnectionPointContainer
	int Variation_152();
	// @cmember set IID_IConvertType
	int Variation_153();
	// @cmember set IID_IDBAsynchStatus
	int Variation_154();
	// @cmember set IID_IRowset
	int Variation_155();
	// @cmember set IID_IRowsetChange
	int Variation_156();
	// @cmember set IID_IRowsetFind
	int Variation_157();
	// @cmember set IID_IRowsetIdentity
	int Variation_158();
	// @cmember set IID_IRowsetIndex
	int Variation_159();
	// @cmember set IID_IRowsetInfo
	int Variation_160();
	// @cmember set IID_IRowsetLocate
	int Variation_161();
	// @cmember set IID_IRowsetResynch
	int Variation_162();
	// @cmember set IID_IRowsetScroll
	int Variation_163();
	// @cmember set IID_IRowsetUpdate
	int Variation_164();
	// @cmember set IID_IRowsetView
	int Variation_165();
	// @cmember set IID_IViewChapter
	int Variation_166();
	// @cmember set IID_IViewFilter
	int Variation_167();
	// @cmember set IID_IViewRowset
	int Variation_168();
	// @cmember set IID_IViewSort
	int Variation_169();
	// @cmember set IID_ILockBytes
	int Variation_170();
	// @cmember set IID_ISequentialStream
	int Variation_171();
	// @cmember set IID_IStorage
	int Variation_172();
	// @cmember set IID_IStream
	int Variation_173();
	// @cmember set IID_ISupportErrorInfo
	int Variation_174();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_SetProperties)
#define THE_CLASS TCICMDPRPT_SetProperties
BEG_TEST_CASE(TCICMDPRPT_SetProperties, TCICMDPRPT_ChangeProperties, L"Set all interface and rowset properties")
	TEST_VARIATION(1,		L"set DBPROP_ACTIVESESSIONS")
	TEST_VARIATION(2,		L"set DBPROP_ASYNCTXNABORT")
	TEST_VARIATION(3,		L"set DBPROP_ASYNCTXNCOMMIT")
	TEST_VARIATION(4,		L"set DBPROP_BYREFACCESSORS")
	TEST_VARIATION(5,		L"set DBPROP_CATALOGLOCATION")
	TEST_VARIATION(6,		L"set DBPROP_CATALOGTERM")
	TEST_VARIATION(7,		L"set DBPROP_CATALOGUSAGE")
	TEST_VARIATION(8,		L"set DBPROP_COLUMNDEFINITION")
	TEST_VARIATION(9,		L"set DBPROP_CONCATNULLBEHAVIOR")
	TEST_VARIATION(10,		L"set DBPROP_DATASOURCENAME")
	TEST_VARIATION(11,		L"set DBPROP_DATASOURCEREADONLY")
	TEST_VARIATION(12,		L"set DBPROP_DBMSNAME")
	TEST_VARIATION(13,		L"set DBPROP_DBMSVER")
	TEST_VARIATION(14,		L"set DBPROP_DSOTHREADMODEL")
	TEST_VARIATION(15,		L"set DBPROP_GROUPBY")
	TEST_VARIATION(16,		L"set DBPROP_HETEROGENEOUSTABLES")
	TEST_VARIATION(17,		L"set DBPROP_IDENTIFIERCASE")
	TEST_VARIATION(18,		L"set DBPROP_MAXINDEXSIZE")
	TEST_VARIATION(19,		L"set DBPROP_MAXOPENCHAPTERS")
	TEST_VARIATION(20,		L"set DBPROP_MAXORSINFILTER")
	TEST_VARIATION(21,		L"set DBPROP_MAXROWSIZE")
	TEST_VARIATION(22,		L"set DBPROP_MAXROWSIZEINCLUDESBLOB")
	TEST_VARIATION(23,		L"set DBPROP_MAXSORTCOLUMNS")
	TEST_VARIATION(24,		L"set DBPROP_MAXTABLESINSELECT")
	TEST_VARIATION(25,		L"set DBPROP_MULTIPLEPARAMSETS")
	TEST_VARIATION(26,		L"set DBPROP_MULTIPLERESULTS")
	TEST_VARIATION(27,		L"set DBPROP_MULTIPLESTORAGEOBJECTS")
	TEST_VARIATION(28,		L"set DBPROP_MULTITABLEUPDATE")
	TEST_VARIATION(29,		L"set DBPROP_NULLCOLLATION")
	TEST_VARIATION(30,		L"set DBPROP_OLEOBJECTS")
	TEST_VARIATION(31,		L"set DBPROP_ORDERBYCOLUMNSINSELECT")
	TEST_VARIATION(32,		L"set DBPROP_OUTPUTPARAMETERAVAILABILITY")
	TEST_VARIATION(33,		L"set DBPROP_PERSISTENTIDTYPE")
	TEST_VARIATION(34,		L"set DBPROP_PREPAREABORTBEHAVIOR")
	TEST_VARIATION(35,		L"set DBPROP_PREPARECOMMITBEHAVIOR")
	TEST_VARIATION(36,		L"set DBPROP_PROCEDURETERM")
	TEST_VARIATION(37,		L"set DBPROP_PROVIDERNAME")
	TEST_VARIATION(38,		L"set DBPROP_PROVIDEROLEDBVER")
	TEST_VARIATION(39,		L"set DBPROP_PROVIDERVER")
	TEST_VARIATION(40,		L"set DBPROP_QUOTEDIDENTIFIERCASE")
	TEST_VARIATION(41,		L"set DBPROP_ROWSETCONVERSIONSONCOMMAND")
	TEST_VARIATION(42,		L"set DBPROP_SCHEMATERM")
	TEST_VARIATION(43,		L"set DBPROP_SCHEMAUSAGE")
	TEST_VARIATION(44,		L"set DBPROP_SORTONINDEX")
	TEST_VARIATION(45,		L"set DBPROP_SQLSUPPORT")
	TEST_VARIATION(46,		L"set DBPROP_STRUCTUREDSTORAGE")
	TEST_VARIATION(47,		L"set DBPROP_SUBQUERIES")
	TEST_VARIATION(48,		L"set DBPROP_SUPPORTEDTXNDDL")
	TEST_VARIATION(49,		L"set DBPROP_SUPPORTEDTXNISOLEVELS")
	TEST_VARIATION(50,		L"set DBPROP_SUPPORTEDTXNISORETAIN")
	TEST_VARIATION(51,		L"set DBPROP_TABLETERM")
	TEST_VARIATION(52,		L"set DBPROP_USERNAME")
	TEST_VARIATION(53,		L"set DBPROP_CURRENTCATALOG")
	TEST_VARIATION(54,		L"set DBPROP_AUTH_CACHE_AUTHINFO")
	TEST_VARIATION(55,		L"set DBPROP_AUTH_ENCRYPT_PASSWORD")
	TEST_VARIATION(56,		L"set DBPROP_AUTH_INTEGRATED")
	TEST_VARIATION(57,		L"set DBPROP_AUTH_MASK_PASSWORD")
	TEST_VARIATION(58,		L"set DBPROP_AUTH_PASSWORD")
	TEST_VARIATION(59,		L"set DBPROP_AUTH_PERSIST_ENCRYPTED")
	TEST_VARIATION(60,		L"set DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO")
	TEST_VARIATION(61,		L"set DBPROP_AUTH_USERID")
	TEST_VARIATION(62,		L"set DBPROP_INIT_ASYNCH")
	TEST_VARIATION(63,		L"set DBPROP_INIT_DATASOURCE")
	TEST_VARIATION(64,		L"set DBPROP_INIT_HWND")
	TEST_VARIATION(65,		L"set DBPROP_INIT_IMPERSONATION_LEVEL")
	TEST_VARIATION(66,		L"set DBPROP_INIT_LCID")
	TEST_VARIATION(67,		L"set DBPROP_INIT_LOCATION")
	TEST_VARIATION(68,		L"set DBPROP_INIT_MODE")
	TEST_VARIATION(69,		L"set DBPROP_INIT_PROMPT")
	TEST_VARIATION(70,		L"set DBPROP_INIT_PROTECTION_LEVEL")
	TEST_VARIATION(71,		L"set DBPROP_INIT_PROVIDERSTRING")
	TEST_VARIATION(72,		L"set DBPROP_INIT_TIMEOUT")
	TEST_VARIATION(73,		L"set DBPROP_COL_AUTOINCREMENT")
	TEST_VARIATION(74,		L"set DBPROP_COL_DEFAULT")
	TEST_VARIATION(75,		L"set DBPROP_COL_DESCRIPTION")
	TEST_VARIATION(76,		L"set DBPROP_COL_FIXEDLENGTH")
	TEST_VARIATION(77,		L"set DBPROP_COL_NULLABLE")
	TEST_VARIATION(78,		L"set DBPROP_COL_PRIMARYKEY")
	TEST_VARIATION(79,		L"set DBPROP_COL_UNIQUE")
	TEST_VARIATION(80,		L"set DBPROP_INDEX_AUTOUPDATE")
	TEST_VARIATION(81,		L"set DBPROP_INDEX_CLUSTERED")
	TEST_VARIATION(82,		L"set DBPROP_INDEX_FILLFACTOR")
	TEST_VARIATION(83,		L"set DBPROP_INDEX_INITIALSIZE")
	TEST_VARIATION(84,		L"set DBPROP_INDEX_NULLCOLLATION")
	TEST_VARIATION(85,		L"set DBPROP_INDEX_NULLS")
	TEST_VARIATION(86,		L"set DBPROP_INDEX_PRIMARYKEY")
	TEST_VARIATION(87,		L"set DBPROP_INDEX_SORTBOOKMARKS")
	TEST_VARIATION(88,		L"set DBPROP_INDEX_TEMPINDEX")
	TEST_VARIATION(89,		L"set DBPROP_INDEX_TYPE")
	TEST_VARIATION(90,		L"set DBPROP_INDEX_UNIQUE")
	TEST_VARIATION(91,		L"set DBPROP_SESS_AUTOCOMMITISOLEVELS")
	TEST_VARIATION(92,		L"set DBPROP_TBL_TEMPTABLE")
	TEST_VARIATION(93,		L"set DBPROP_ABORTPRESERVE")
	TEST_VARIATION(94,		L"set DBPROP_APPENDONLY")
	TEST_VARIATION(95,		L"set DBPROP_BLOCKINGSTORAGEOBJECTS")
	TEST_VARIATION(96,		L"set DBPROP_BOOKMARKS")
	TEST_VARIATION(97,		L"set DBPROP_BOOKMARKSKIPPED")
	TEST_VARIATION(98,		L"set DBPROP_BOOKMARKTYPE")
	TEST_VARIATION(99,		L"set DBPROP_CACHDEFERRED")
	TEST_VARIATION(100,		L"set DBPROP_CANFETCHBACKWARDS")
	TEST_VARIATION(101,		L"set DBPROP_CANHOLDROWS")
	TEST_VARIATION(102,		L"set DBPROP_CANSCROLLBACKWARDS")
	TEST_VARIATION(103,		L"set DBPROP_CHANGEINSERTEDROWS")
	TEST_VARIATION(104,		L"set DBPROP_COLUMNRESTRICT")
	TEST_VARIATION(105,		L"set DBPROP_COMMANDTIMEOUT")
	TEST_VARIATION(106,		L"set DBPROP_COMMITPRESERVE")
	TEST_VARIATION(107,		L"set DBPROP_DEFERRED")
	TEST_VARIATION(108,		L"set DBPROP_DELAYSTORAGEOBJECTS")
	TEST_VARIATION(109,		L"set DBPROP_FILTERCOMPAREOPS")
	TEST_VARIATION(110,		L"set DBPROP_FINDCOMPAREOPS")
	TEST_VARIATION(111,		L"set DBPROP_IMMOBILEROWS")
	TEST_VARIATION(112,		L"set DBPROP_LITERALBOOKMARKS")
	TEST_VARIATION(113,		L"set DBPROP_LITERALIDENTITY")
	TEST_VARIATION(114,		L"set DBPROP_MAXOPENROWS")
	TEST_VARIATION(115,		L"set DBPROP_MAXPENDINGROWS")
	TEST_VARIATION(116,		L"set DBPROP_MAXROWS")
	TEST_VARIATION(117,		L"set DBPROP_MAYWRITECOLUMN")
	TEST_VARIATION(118,		L"set DBPROP_MEMORYUSAGE")
	TEST_VARIATION(119,		L"set DBPROP_NOTIFICATIONPHASES")
	TEST_VARIATION(120,		L"set DBPROP_NOTIFYCOLUMNSET")
	TEST_VARIATION(121,		L"set DBPROP_NOTIFYROWDELETE")
	TEST_VARIATION(122,		L"set DBPROP_NOTIFYROWFIRSTCHANGE")
	TEST_VARIATION(123,		L"set DBPROP_NOTIFYROWINSERT")
	TEST_VARIATION(124,		L"set DBPROP_NOTIFYROWRESYNCH")
	TEST_VARIATION(125,		L"set DBPROP_NOTIFYROWSETRELEASE")
	TEST_VARIATION(126,		L"set DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE")
	TEST_VARIATION(127,		L"set DBPROP_NOTIFYROWUNDOCHANGE")
	TEST_VARIATION(128,		L"set DBPROP_NOTIFYUNDODELETE")
	TEST_VARIATION(129,		L"set DBPROP_NOTIFYUNDOINSERT")
	TEST_VARIATION(130,		L"set DBPROP_NOTIFYROWUPDATE")
	TEST_VARIATION(131,		L"set DBPROP_ORDEREDBOOKMARKS")
	TEST_VARIATION(132,		L"set DBPROP_OTHERINSERT")
	TEST_VARIATION(133,		L"set DBPROP_OTHERUPDATEDELETE")
	TEST_VARIATION(134,		L"set DBPROP_OWNINSERT")
	TEST_VARIATION(135,		L"set DBPROP_OWNUPDATEDELETE")
	TEST_VARIATION(136,		L"set DBPROP_QUICKRESTART")
	TEST_VARIATION(137,		L"set DBPROP_REENTRANTEVENTS")
	TEST_VARIATION(138,		L"set DBPROP_REMOVEDELETED")
	TEST_VARIATION(139,		L"set DBPROP_REPORTMULTIPLECHANGES")
	TEST_VARIATION(140,		L"set DBPROP_RETURNPENDINGINSERTS")
	TEST_VARIATION(141,		L"set DBPROP_ROWRESTRICT")
	TEST_VARIATION(142,		L"set DBPROP_ROWSET_ASYNCH")
	TEST_VARIATION(143,		L"set DBPROP_ROWTHREADMODEL")
	TEST_VARIATION(144,		L"set DBPROP_SERVERCURSOR")
	TEST_VARIATION(145,		L"set DBPROP_TRANSACTEDOBJECT")
	TEST_VARIATION(146,		L"set DBPROP_UPDATABILITY")
	TEST_VARIATION(147,		L"set DBPROP_STRONGIDENTITY")
	TEST_VARIATION(148,		L"set IID_IAccessor")
	TEST_VARIATION(149,		L"set IID_IChapteredRowset")
	TEST_VARIATION(150,		L"set IID_IColumnsInfo")
	TEST_VARIATION(151,		L"set IID_IColumnsRowset")
	TEST_VARIATION(152,		L"set IID_IConnectionPointContainer")
	TEST_VARIATION(153,		L"set IID_IConvertType")
	TEST_VARIATION(154,		L"set IID_IDBAsynchStatus")
	TEST_VARIATION(155,		L"set IID_IRowset")
	TEST_VARIATION(156,		L"set IID_IRowsetChange")
	TEST_VARIATION(157,		L"set IID_IRowsetFind")
	TEST_VARIATION(158,		L"set IID_IRowsetIdentity")
	TEST_VARIATION(159,		L"set IID_IRowsetIndex")
	TEST_VARIATION(160,		L"set IID_IRowsetInfo")
	TEST_VARIATION(161,		L"set IID_IRowsetLocate")
	TEST_VARIATION(162,		L"set IID_IRowsetResynch")
	TEST_VARIATION(163,		L"set IID_IRowsetScroll")
	TEST_VARIATION(164,		L"set IID_IRowsetUpdate")
	TEST_VARIATION(165,		L"set IID_IRowsetView")
	TEST_VARIATION(166,		L"set IID_IViewChapter")
	TEST_VARIATION(167,		L"set IID_IViewFilter")
	TEST_VARIATION(168,		L"set IID_IViewRowset")
	TEST_VARIATION(169,		L"set IID_IViewSort")
	TEST_VARIATION(170,		L"set IID_ILockBytes")
	TEST_VARIATION(171,		L"set IID_ISequentialStream")
	TEST_VARIATION(172,		L"set IID_IStorage")
	TEST_VARIATION(173,		L"set IID_IStream")
	TEST_VARIATION(174,		L"set IID_ISupportErrorInfo")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_UnsetProperties)
//--------------------------------------------------------------------
// @class Unset all interface and rowset properties
//
class TCICMDPRPT_UnsetProperties : public TCICMDPRPT_ChangeProperties {
private:
	//@cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	//{{ TCW_DECLARE_FUNCS
	//@cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_UnsetProperties,TCICMDPRPT_ChangeProperties);
	// }}
 
	//@cmember Initialization Routine
	virtual BOOL Init();

	//@cmember Termination Routine
	virtual BOOL Terminate();
	
	//@cmember Verify the impled properties are unset correctly
	virtual BOOL VerifyImpliedProperties(ULONG cImpPrpt,ULONG rgIDXPrpt[]);	

	//@mfunc: Verify the attrbute of the property
	virtual BOOL VerifyProperty(ULONG cPrpt,BOOL fIReadData=FALSE,ULONG cImpPrpt=0,
						ULONG rgIDXPrpt[]=NULL);
	// {{ TCW_TESTVARS()
	// @cmember unset DBPROP_ABORTPRESERVE
	int Variation_1();
	// @cmember unset DBPROP_APPENDONLY
	int Variation_2();
	// @cmember unset DBPROP_BLOCKINGSTORAGEOBJECTS
	int Variation_3();
	// @cmember unset DBPROP_BOOKMARKS
	int Variation_4();
	// @cmember unset DBPROP_BOOKMARKSKIPPED
	int Variation_5();
	// @cmember unset DBPROP_BOOKMARKTYPE
	int Variation_6();
	// @cmember unset DBPROP_CACHDEFERRED
	int Variation_7();
	// @cmember unset DBPROP_CANFETCHBACKWARDS
	int Variation_8();
	// @cmember unset DBPROP_CANHOLDROWS
	int Variation_9();
	// @cmember unset DBPROP_CANSCROLLBACKWARDS
	int Variation_10();
	// @cmember unset DBPROP_CHANGEINSERTEDROWS
	int Variation_11();
	// @cmember unset DBPROP_COLUMNRESTRICT
	int Variation_12();
	// @cmember unset DBPROP_COMMANDTIMEOUT
	int Variation_13();
	// @cmember unset DBPROP_COMMITPRESERVE
	int Variation_14();
	// @cmember unset DBPROP_DEFERRED
	int Variation_15();
	// @cmember unset DBPROP_DELAYSTORAGEOBJECTS
	int Variation_16();
	// @cmember unset DBPROP_FILTERCOMPAREOPS
	int Variation_17();
	// @cmember unset DBPROP_FINDCOMPAREOPS
	int Variation_18();
	// @cmember unset DBPROP_IMMOBILEROWS
	int Variation_19();
	// @cmember unset DBPROP_LITERALBOOKMARKS
	int Variation_20();
	// @cmember unset DBPROP_LITERALIDENTITY
	int Variation_21();
	// @cmember unset DBPROP_MAXOPENROWS
	int Variation_22();
	// @cmember unset DBPROP_MAXPENDINGROWS
	int Variation_23();
	// @cmember unset DBPROP_MAXROWS
	int Variation_24();
	// @cmember unset DBPROP_MAYWRITECOLUMN
	int Variation_25();
	// @cmember unset DBPROP_MEMORYUSAGE
	int Variation_26();
	// @cmember unset DBPROP_NOTIFICATIONPHASES
	int Variation_27();
	// @cmember unset DBPROP_NOTIFYCOLUMNSET
	int Variation_28();
	// @cmember unset DBPROP_NOTIFYROWDELETE
	int Variation_29();
	// @cmember unset DBPROP_NOTIFYROWFIRSTCHANGE
	int Variation_30();
	// @cmember unset DBPROP_NOTIFYROWINSERT
	int Variation_31();
	// @cmember unset DBPROP_NOTIFYROWRESYNCH
	int Variation_32();
	// @cmember unset DBPROP_NOTIFYROWSETRELEASE
	int Variation_33();
	// @cmember unset DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE
	int Variation_34();
	// @cmember unset DBPROP_NOTIFYROWUNDOCHANGE
	int Variation_35();
	// @cmember unset DBPROP_NOTIFYUNDODELETE
	int Variation_36();
	// @cmember unset DBPROP_NOTIFYUNDOINSERT
	int Variation_37();
	// @cmember unset DBPROP_NOTIFYROWUPDATE
	int Variation_38();
	// @cmember unset DBPROP_ORDEREDBOOKMARKS
	int Variation_39();
	// @cmember unset DBPROP_OTHERINSERT
	int Variation_40();
	// @cmember unset DBPROP_OTHERUPDATEDELETE
	int Variation_41();
	// @cmember unset DBPROP_OWNINSERT
	int Variation_42();
	// @cmember unset DBPROP_OWNUPDATEDELETE
	int Variation_43();
	// @cmember unset DBPROP_QUICKRESTART
	int Variation_44();
	// @cmember unset DBPROP_REENTRANTEVENTS
	int Variation_45();
	// @cmember unset DBPROP_REMOVEDELETED
	int Variation_46();
	// @cmember unset DBPROP_REPORTMULTIPLECHANGES
	int Variation_47();
	// @cmember unset DBPROP_RETURNPENDINGINSERTS
	int Variation_48();
	// @cmember unset DBPROP_ROWRESTRICT
	int Variation_49();
	// @cmember unset DBPROP_ROWSET_ASYNCH
	int Variation_50();
	// @cmember unset DBPROP_ROWTHREADMODEL
	int Variation_51();
	// @cmember unset DBPROP_SERVERCURSOR
	int Variation_52();
	// @cmember unset DBPROP_TRANSACTEDOBJECT
	int Variation_53();
	// @cmember unset DBPROP_UPDATABILITY
	int Variation_54();
	// @cmember unset DBPROP_STRONGIDENTITY
	int Variation_55();
	// @cmember unset IID_IAccessor
	int Variation_56();
	// @cmember unset IID_IChapteredRowset
	int Variation_57();
	// @cmember unset IID_IColumnsInfo
	int Variation_58();
	// @cmember unset IID_IColumnsRowset
	int Variation_59();
	// @cmember unset IID_IConnectionPointContainer
	int Variation_60();
	// @cmember unset IID_IConvertType
	int Variation_61();
	// @cmember unset IID_IDBAsynchStatus
	int Variation_62();
	// @cmember unset IID_IRowset
	int Variation_63();
	// @cmember unset IID_IRowsetChange
	int Variation_64();
	// @cmember unset IID_IRowsetIdentity
	int Variation_65();
	// @cmember unset IID_IRowsetIndex
	int Variation_66();
	// @cmember unset IID_IRowsetInfo
	int Variation_67();
	// @cmember unset IID_IRowsetLocate
	int Variation_68();
	// @cmember unset IID_IRowsetResynch
	int Variation_69();
	// @cmember unset IID_IRowsetScroll
	int Variation_70();
	// @cmember unset IID_IRowsetUpdate
	int Variation_71();
	// @cmember unset IID_IRowsetView
	int Variation_72();
	// @cmember unset IID_IViewChapter
	int Variation_73();
	// @cmember unset IID_IViewFilter
	int Variation_74();
	// @cmember unset IID_IViewRowset
	int Variation_75();
	// @cmember unset IID_IViewSort
	int Variation_76();
	// @cmember unset IID_ILockBytes
	int Variation_77();
	// @cmember unset IID_ISequentialStream
	int Variation_78();
	// @cmember unset IID_IStorage
	int Variation_79();
	// @cmember unset IID_IStream
	int Variation_80();
	// @cmember unset IID_ISupportErrorInfo
	int Variation_81();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_UnsetProperties)
#define THE_CLASS TCICMDPRPT_UnsetProperties
BEG_TEST_CASE(TCICMDPRPT_UnsetProperties, TCICMDPRPT_ChangeProperties, L"Unset all interface and rowset properties")
	TEST_VARIATION(1,		L"unset DBPROP_ABORTPRESERVE")
	TEST_VARIATION(2,		L"unset DBPROP_APPENDONLY")
	TEST_VARIATION(3,		L"unset DBPROP_BLOCKINGSTORAGEOBJECTS")
	TEST_VARIATION(4,		L"unset DBPROP_BOOKMARKS")
	TEST_VARIATION(5,		L"unset DBPROP_BOOKMARKSKIPPED")
	TEST_VARIATION(6,		L"unset DBPROP_BOOKMARKTYPE")
	TEST_VARIATION(7,		L"unset DBPROP_CACHDEFERRED")
	TEST_VARIATION(8,		L"unset DBPROP_CANFETCHBACKWARDS")
	TEST_VARIATION(9,		L"unset DBPROP_CANHOLDROWS")
	TEST_VARIATION(10,		L"unset DBPROP_CANSCROLLBACKWARDS")
	TEST_VARIATION(11,		L"unset DBPROP_CHANGEINSERTEDROWS")
	TEST_VARIATION(12,		L"unset DBPROP_COLUMNRESTRICT")
	TEST_VARIATION(13,		L"unset DBPROP_COMMANDTIMEOUT")
	TEST_VARIATION(14,		L"unset DBPROP_COMMITPRESERVE")
	TEST_VARIATION(15,		L"unset DBPROP_DEFERRED")
	TEST_VARIATION(16,		L"unset DBPROP_DELAYSTORAGEOBJECTS")
	TEST_VARIATION(17,		L"unset DBPROP_IMMOBILEROWS")
	TEST_VARIATION(18,		L"unset DBPROP_LITERALBOOKMARKS")
	TEST_VARIATION(19,		L"unset DBPROP_IMMOBILEROWS")
	TEST_VARIATION(20,		L"unset DBPROP_FILTERCOMPAREOPS")
	TEST_VARIATION(21,		L"unset DBPROP_FINDCOMPAREOPS")
	TEST_VARIATION(22,		L"unset DBPROP_MAXOPENROWS")
	TEST_VARIATION(23,		L"unset DBPROP_MAXPENDINGROWS")
	TEST_VARIATION(24,		L"unset DBPROP_MAXROWS")
	TEST_VARIATION(25,		L"unset DBPROP_MAYWRITECOLUMN")
	TEST_VARIATION(26,		L"unset DBPROP_MEMORYUSAGE")
	TEST_VARIATION(27,		L"unset DBPROP_NOTIFICATIONPHASES")
	TEST_VARIATION(28,		L"unset DBPROP_NOTIFYCOLUMNSET")
	TEST_VARIATION(29,		L"unset DBPROP_NOTIFYROWDELETE")
	TEST_VARIATION(30,		L"unset DBPROP_NOTIFYROWFIRSTCHANGE")
	TEST_VARIATION(31,		L"unset DBPROP_NOTIFYROWINSERT")
	TEST_VARIATION(32,		L"unset DBPROP_NOTIFYROWRESYNCH")
	TEST_VARIATION(33,		L"unset DBPROP_NOTIFYROWSETRELEASE")
	TEST_VARIATION(34,		L"unset DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE")
	TEST_VARIATION(35,		L"unset DBPROP_NOTIFYROWUNDOCHANGE")
	TEST_VARIATION(36,		L"unset DBPROP_NOTIFYUNDODELETE")
	TEST_VARIATION(37,		L"unset DBPROP_NOTIFYUNDOINSERT")
	TEST_VARIATION(38,		L"unset DBPROP_NOTIFYROWUPDATE")
	TEST_VARIATION(39,		L"unset DBPROP_ORDEREDBOOKMARKS")
	TEST_VARIATION(40,		L"unset DBPROP_OTHERINSERT")
	TEST_VARIATION(41,		L"unset DBPROP_OTHERUPDATEDELETE")
	TEST_VARIATION(42,		L"unset DBPROP_OWNINSERT")
	TEST_VARIATION(43,		L"unset DBPROP_OWNUPDATEDELETE")
	TEST_VARIATION(44,		L"unset DBPROP_QUICKRESTART")
	TEST_VARIATION(45,		L"unset DBPROP_REENTRANTEVENTS")
	TEST_VARIATION(46,		L"unset DBPROP_REMOVEDELETED")
	TEST_VARIATION(47,		L"unset DBPROP_REPORTMULTIPLECHANGES")
	TEST_VARIATION(48,		L"unset DBPROP_RETURNPENDINGINSERTS")
	TEST_VARIATION(49,		L"unset DBPROP_ROWRESTRICT")
	TEST_VARIATION(50,		L"unset DBPROP_ROWSET_ASYNCH")
	TEST_VARIATION(51,		L"unset DBPROP_ROWTHREADMODEL")
	TEST_VARIATION(52,		L"unset DBPROP_SERVERCURSOR")
	TEST_VARIATION(53,		L"unset DBPROP_TRANSACTEDOBJECT")
	TEST_VARIATION(54,		L"unset DBPROP_UPDATABILITY")
	TEST_VARIATION(55,		L"unset DBPROP_STRONGIDENTITY")
	TEST_VARIATION(56,		L"unset IID_IAccessor")
	TEST_VARIATION(57,		L"unset IID_IChapteredRowset")
	TEST_VARIATION(58,		L"unset IID_IColumnsInfo")
	TEST_VARIATION(59,		L"unset IID_IColumnsRowset")
	TEST_VARIATION(60,		L"unset IID_IConnectionPointContainer")
	TEST_VARIATION(61,		L"unset IID_IConvertType")
	TEST_VARIATION(62,		L"unset IID_IDBAsynchStatus")
	TEST_VARIATION(63,		L"unset IID_IRowset")
	TEST_VARIATION(64,		L"unset IID_IRowsetChange")
	TEST_VARIATION(65,		L"unset IID_IRowsetIdentity")
	TEST_VARIATION(66,		L"unset IID_IRowsetIndex")
	TEST_VARIATION(67,		L"unset IID_IRowsetInfo")
	TEST_VARIATION(68,		L"unset IID_IRowsetLocate")
	TEST_VARIATION(69,		L"unset IID_IRowsetResynch")
	TEST_VARIATION(70,		L"unset IID_IRowsetScroll")
	TEST_VARIATION(71,		L"unset IID_IRowsetUpdate")
	TEST_VARIATION(72,		L"unset IID_IRowsetView")
	TEST_VARIATION(73,		L"unset IID_IViewChapter")
	TEST_VARIATION(74,		L"unset IID_IViewFilter")
	TEST_VARIATION(75,		L"unset IID_IViewRowset")
	TEST_VARIATION(76,		L"unset IID_IViewSort")
	TEST_VARIATION(77,		L"unset IID_ILockBytes")
	TEST_VARIATION(78,		L"unset IID_ISequentialStream")
	TEST_VARIATION(79,		L"unset IID_IStorage")
	TEST_VARIATION(80,		L"unset IID_IStream")
	TEST_VARIATION(81,		L"unset IID_ISupportErrorInfo")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Boundary_Set)
//--------------------------------------------------------------------
// @class Boundary conditions for SetProperties
//
class TCICMDPRPT_Boundary_Set : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Boundary_Set,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember cPropertySets=0, SetProperties does not do anything
	int Variation_1();
	// @cmember cPropertySets=0 and rgPropertySets=NULL, SetProperties does not do anything
	int Variation_2();
	// @cmember cPropertySets>0 and rgPropertySets=NULL, E_INVALIDARG returned
	int Variation_3();
	// @cmember cProperties=0, SetProperties does not do anything
	int Variation_4();
	// @cmember cProperties=0 and rgProperties=NULL, SetProperties does not do anything
	int Variation_5();
	// @cmember cProperties>0 and rgProperties=NULL, E_INVALIDARG returned
	int Variation_6();
	// @cmember cPropertySets=0 and rgPropertySets is invalid, return S_OK
	int Variation_7();
	// @cmember cProperties=0 and guidPropertySet=invalid GUID, SetProperties does not do anything
	int Variation_8();
	// @cmember guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned
	int Variation_9();
	// @cmember guidPropertySet=invalid GUID and rgProperties=NULL, E_INVALIDARG returned
	int Variation_10();
	// @cmember Open a rowset and try to set a property, DB_E_OBJECTOPEN returned
	int Variation_11();
	// @cmember Set a good Propset and 0, NULL Propsets
	int Variation_12();
	// @cmember Set a 0, NULL Propsets with a DBINIT Propset
	int Variation_13();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Boundary_Set)
#define THE_CLASS TCICMDPRPT_Boundary_Set
BEG_TEST_CASE(TCICMDPRPT_Boundary_Set, TCICMDPRPT, L"Boundary conditions for SetProperties")
	TEST_VARIATION(1,		L"cPropertySets=0, SetProperties does not do anything")
	TEST_VARIATION(2,		L"cPropertySets=0 and rgPropertySets=NULL, SetProperties does not do anything")
	TEST_VARIATION(3,		L"cPropertySets>0 and rgPropertySets=NULL, E_INVALIDARG returned")
	TEST_VARIATION(4,		L"cProperties=0, SetProperties does not do anything")
	TEST_VARIATION(5,		L"cProperties=0 and rgProperties=NULL, SetProperties does not do anything")
	TEST_VARIATION(6,		L"cProperties>0 and rgProperties=NULL, E_INVALIDARG returned")
	TEST_VARIATION(7,		L"cPropertySets=0 and rgPropertySets is invalid, return S_OK")
	TEST_VARIATION(8,		L"cProperties=0 and guidPropertySet=invalid GUID, SetProperties does not do anything")
	TEST_VARIATION(9,		L"guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned")
	TEST_VARIATION(10,		L"guidPropertySet=invalid GUID and rgProperties=NULL, E_INVALIDARG returned")
	TEST_VARIATION(11,		L"Open a rowset and try to set a property, DB_E_OBJECTOPEN returned")
	TEST_VARIATION(12,		L"Set a good Propset and 0, NULL Propsets")
	TEST_VARIATION(13,		L"Set a 0, NULL Propsets with a DBINIT Propset")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Boundary_Get)
//--------------------------------------------------------------------
// @class Boundary conditions for GetProperties
//
class TCICMDPRPT_Boundary_Get : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Boundary_Get,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember cPropertyIDSets>0, rgPropertyIDSets=NULL, return E_INVALIDARG
	int Variation_1();
	// @cmember cPropertyIDs>0, rgPropertyIDs=NULL, return E_INVALIDARG
	int Variation_2();
	// @cmember pcPropertySets=NULL, return E_INVALIDARG
	int Variation_3();
	// @cmember prgPropertySets=NULL, return E_INVALIDARG
	int Variation_4();
	// @cmember cPropertyIDSets>0, rgPropertyIDSets=NULL, pcPropertySets=NULL, prgPropertySets=NULL, E_INVALIDARG
	int Variation_5();
	// @cmember guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned
	int Variation_6();
	// @cmember rgPropertyIDs=invalid DBPROPID, DB_E_ERRORSOCCURRED returned
	int Variation_7();
	// @cmember DBPROPSET_ROWSET with 0, NULL
	int Variation_8();
	// @cmember DBPROPSET_ROWSET with 0, NULL twice
	int Variation_9();
	// @cmember DBPROPSET_ROWSET with 0, NULL and a single property
	int Variation_10();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Boundary_Get)
#define THE_CLASS TCICMDPRPT_Boundary_Get
BEG_TEST_CASE(TCICMDPRPT_Boundary_Get, TCICMDPRPT, L"Boundary conditions for GetProperties")
	TEST_VARIATION(1,		L"cPropertyIDSets>0, rgPropertyIDSets=NULL, return E_INVALIDARG")
	TEST_VARIATION(2,		L"cPropertyIDs>0, rgPropertyIDs=NULL, return E_INVALIDARG")
	TEST_VARIATION(3,		L"pcPropertySets=NULL, return E_INVALIDARG")
	TEST_VARIATION(4,		L"prgPropertySets=NULL, return E_INVALIDARG")
	TEST_VARIATION(5,		L"cPropertyIDSets>0, rgPropertyIDSets=NULL, pcPropertySets=NULL, prgPropertySets=NULL, E_INVALIDARG")
	TEST_VARIATION(6,		L"guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned")
	TEST_VARIATION(7,		L"rgPropertyIDs=invalid DBPROPID, DB_E_ERRORSOCCURRED returned")
	TEST_VARIATION(8,		L"DBPROPSET_ROWSET with 0, NULL")
	TEST_VARIATION(9,		L"DBPROPSET_ROWSET with 0, NULL twice")
	TEST_VARIATION(10,		L"DBPROPSET_ROWSET with 0, NULL and a single property")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}

// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Parameters)
//--------------------------------------------------------------------
// @class Test parameters
//
class TCICMDPRPT_Parameters : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	// @cmember
	ULONG					m_cPrpt;
	// @cmember
	DBPROPSET				m_DBPrpt;
	// @cmember
	DBPROP					m_DBProp;
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Parameters,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember Set MAXROWS to 0
	int Variation_1();
	// @cmember Set MAXROWS to -1
	int Variation_2();
	// @cmember Set MaxOpenRows to 0
	int Variation_3();
	// @cmember Set MaxOpenRows to -1
	int Variation_4();
	// @cmember Set MAXROWS to 55
	int Variation_5();
	// @cmember Set MAXROWS to 99999999
	int Variation_6();
	// @cmember Set DBPROPSET_PROPERTYIESINERROR
	int Variation_7();
	// @cmember Set by ICommand::Execute
	int Variation_8();
	// @cmember SetCheap
	int Variation_9();
	// @cmember Set dwOptions to an invalid value. Return DBPROPSTATUS_BADOPTION
	int Variation_10();
	// @cmember Set colid on a property that only supports all columns
	int Variation_11();
	// @cmember Set an invalid colid on a property that supports colid
	int Variation_12();
	// @cmember Set DBPROP_APPENDONLY and DBPROP_OTHERINSERT to VARIANT_TRUE
	int Variation_13();
	// @cmember Set the same property twice in one call to SetProperties
	int Variation_14();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0
	int Variation_15();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0, rgPropertyIDs=NULL
	int Variation_16();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR with rgPropertyIDs!=NULL
	int Variation_17();
	// @cmember Get DBPROPSET_ROWSET and DBPROPSET_PROPERTYIESINERROR
	int Variation_18();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR after successful ICommand::Execute
	int Variation_19();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR after ICommand::Execute fails
	int Variation_20();
	// @cmember Get DBPROPSET_PROPERTYIESINERROR twice in a row
	int Variation_21();
	// @cmember GetProperties with DBPROPSET_PROPERTYIESINERROR
	int Variation_22();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Parameters)
#define THE_CLASS TCICMDPRPT_Parameters
BEG_TEST_CASE(TCICMDPRPT_Parameters, TCICMDPRPT, L"Test parameters")
	TEST_VARIATION(1,		L"Set MAXROWS to 0")
	TEST_VARIATION(2,		L"Set MAXROWS to -1")
	TEST_VARIATION(3,		L"Set MaxOpenRows to 0")
	TEST_VARIATION(4,		L"Set MaxOpenRows to -1")
	TEST_VARIATION(5,		L"Set MAXROWS to 55")
	TEST_VARIATION(6,		L"Set MAXROWS to 99999999")
	TEST_VARIATION(7,		L"Set DBPROPSET_PROPERTYIESINERROR")
	TEST_VARIATION(8,		L"Set by ICommand::Execute")
	TEST_VARIATION(9,		L"SetCheap")
	TEST_VARIATION(10,		L"Set dwOptions to an invalid value. Return DBPROPSTATUS_BADOPTION")
	TEST_VARIATION(11,		L"Set colid on a property that only supports all columns")
	TEST_VARIATION(12,		L"Set an invalid colid on a property that supports colid")
	TEST_VARIATION(13,		L"Set DBPROP_APPENDONLY and DBPROP_OTHERINSERT to VARIANT_TRUE")
	TEST_VARIATION(14,		L"Set the same property twice in one call to SetProperties")
	TEST_VARIATION(15,		L"Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0")
	TEST_VARIATION(16,		L"Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0, rgPropertyIDs=NULL")
	TEST_VARIATION(17,		L"Get DBPROPSET_PROPERTYIESINERROR with rgPropertyIDs!=NULL")
	TEST_VARIATION(18,		L"Get DBPROPSET_ROWSET and DBPROPSET_PROPERTYIESINERROR")
	TEST_VARIATION(19,		L"Get DBPROPSET_PROPERTYIESINERROR after successful ICommand::Execute")
	TEST_VARIATION(20,		L"Get DBPROPSET_PROPERTYIESINERROR after ICommand::Execute fails")
	TEST_VARIATION(21,		L"Get DBPROPSET_PROPERTYIESINERROR twice in a row")
	TEST_VARIATION(22,		L"GetProperties with DBPROPSET_PROPERTYIESINERROR")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_SequenceBeforeRowset)
//--------------------------------------------------------------------
// @class sequence test before a rowset is open
//
class TCICMDPRPT_SequenceBeforeRowset : public TCICMDPRPT_ChangeProperties {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();

	// @cmember
	ULONG			m_cDBPrptGet;
	// @cmember
	BOOL			m_fGet;
	// @cmember
	BOOL			m_fSet;
	// @cmember
	IUnknown		*m_pICommandInterface;
	// @cmember
	DBPROPSET		*m_pDBPrpt;	
	// @cmember
	DBPROPIDSET		m_pDBPrptIDSet;	
	// @cmember
	DBPROPID		m_pDBPrptID;	

public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_SequenceBeforeRowset,TCICMDPRPT_ChangeProperties);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	// @cmember Return the requested interface pointer
	BOOL GetInterface(REFIID riid, BOOL fRequried);
	
	// {{ TCW_TESTVARS()
	// @cmember After IAccessor
	int Variation_1();
	// @cmember After IColumnsInfo
	int Variation_2();
	// @cmember After IColumnsRowset
	int Variation_3();
	// @cmember After ICommand
	int Variation_4();
	// @cmember After ICommandCost
	int Variation_5();
	// @cmember After ICommandPrepare
	int Variation_6();
	// @cmember After ICommandQuery
	int Variation_7();
	// @cmember After ICommandTree
	int Variation_8();
	// @cmember After ICommandText
	int Variation_9();
	// @cmember After ICommandValidate
	int Variation_10();
	// @cmember After ICommandWithParameters
	int Variation_11();
	// @cmember After IQuery
	int Variation_12();
	// @cmember After IPersistStream
	int Variation_13();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_SequenceBeforeRowset)
#define THE_CLASS TCICMDPRPT_SequenceBeforeRowset
BEG_TEST_CASE(TCICMDPRPT_SequenceBeforeRowset, TCICMDPRPT, L"sequence test before a rowset is open")
	TEST_VARIATION(1,		L"After IAccessor")
	TEST_VARIATION(2,		L"After IColumnsInfo")
	TEST_VARIATION(3,		L"After IColumnsRowset")
	TEST_VARIATION(4,		L"After ICommand")
	TEST_VARIATION(5,		L"After ICommandCost")
	TEST_VARIATION(6,		L"After ICommandPrepare")
	TEST_VARIATION(7,		L"After ICommandQuery")
	TEST_VARIATION(8,		L"After ICommandTree")
	TEST_VARIATION(9,		L"After ICommandText")
	TEST_VARIATION(10,		L"After ICommandValidate")
	TEST_VARIATION(11,		L"After ICommandWithParameters")
	TEST_VARIATION(12,		L"After IQuery")
	TEST_VARIATION(13,		L"After IPersistStream")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_SequenceAfterRowset)
//--------------------------------------------------------------------
// @class sequence test after a rowset is open
//
class TCICMDPRPT_SequenceAfterRowset : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_SequenceAfterRowset,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember Call SetProperties after a rowset is open, DB_E_OPENOBJECT
	int Variation_1();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_SequenceAfterRowset)
#define THE_CLASS TCICMDPRPT_SequenceAfterRowset
BEG_TEST_CASE(TCICMDPRPT_SequenceAfterRowset, TCICMDPRPT, L"sequence test after a rowset is open")
	TEST_VARIATION(1,		L"Call SetProperties after a rowset is open, DB_E_OPENOBJECT")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Zombie)
//--------------------------------------------------------------------
// @class Test zombie state for command object
//
class TCICMDPRPT_Zombie : public CTransaction {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();

protected:	
	//@cmember: Get a supported interface property
	BOOL	InterfaceSupported(DBPROPID *dwPropertyID);

public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Zombie,CTransaction);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();

	// {{ TCW_TESTVARS()
	// @cmember S_OK - Abort ICommandProperties::GetProperties with fRetaining=TRUE
	int Variation_1();
	// @cmember S_OK - Abort ICommandProperties::GetProperties with fRetaining=FALSE
	int Variation_2();
	// @cmember S_OK - Commit ICommandProperties::GetProperties with fRetaining=TRUE
	int Variation_3();
	// @cmember S_OK - Commit ICommandProperties::GetProperties with fRetaining=FALSE
	int Variation_4();
	// @cmember DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=TRUE
	int Variation_5();
	// @cmember DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=FALSE
	int Variation_6();
	// @cmember DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=TRUE
	int Variation_7();
	// @cmember DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=FALSE
	int Variation_8();
	// @cmember S_OK - Abort ICommandProperties::SetProperties with fRetaining=TRUE
	int Variation_9();
	// @cmember S_OK - Abort ICommandProperties::SetProperties with fRetaining=FALSE
	int Variation_10();
	// @cmember S_OK - Commit ICommandProperties::SetProperties with fRetaining=TRUE
	int Variation_11();
	// @cmember S_OK - Commit ICommandProperties::SetProperties with fRetaining=FALSE
	int Variation_12();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Zombie)
#define THE_CLASS TCICMDPRPT_Zombie
BEG_TEST_CASE(TCICMDPRPT_Zombie, CTransaction, L"Test zombie state for command object")
	TEST_VARIATION(1,		L"S_OK - Abort ICommandProperties::GetProperties with fRetaining=TRUE")
	TEST_VARIATION(2,		L"S_OK - Abort ICommandProperties::GetProperties with fRetaining=FALSE")
	TEST_VARIATION(3,		L"S_OK - Commit ICommandProperties::GetProperties with fRetaining=TRUE")
	TEST_VARIATION(4,		L"S_OK - Commit ICommandProperties::GetProperties with fRetaining=FALSE")
	TEST_VARIATION(5,		L"DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=TRUE")
	TEST_VARIATION(6,		L"DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=FALSE")
	TEST_VARIATION(7,		L"DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=TRUE")
	TEST_VARIATION(8,		L"DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=FALSE")
	TEST_VARIATION(9,		L"S_OK - Abort ICommandProperties::SetProperties with fRetaining=TRUE")
	TEST_VARIATION(10,		L"S_OK - Abort ICommandProperties::SetProperties with fRetaining=FALSE")
	TEST_VARIATION(11,		L"S_OK - Commit ICommandProperties::SetProperties with fRetaining=TRUE")
	TEST_VARIATION(12,		L"S_OK - Commit ICommandProperties::SetProperties with fRetaining=FALSE")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Stress)
//--------------------------------------------------------------------
// @class Stress testing for memory leak
//
class TCICMDPRPT_Stress : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Stress,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember Free Memory for GetProperties, check for memory leak
	int Variation_1();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Stress)
#define THE_CLASS TCICMDPRPT_Stress
BEG_TEST_CASE(TCICMDPRPT_Stress, TCICMDPRPT, L"Stress testing for memory leak")
	TEST_VARIATION(1,		L"Free Memory for GetProperties, check for memory leak")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_Sequence)
//--------------------------------------------------------------------
// @class test calling sequence
//
class TCICMDPRPT_Sequence : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_Sequence,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember Set, Unset, and Unset
	int Variation_1();
	// @cmember Unset, Set, Set
	int Variation_2();
	// @cmember Multiple rowset objects open on the same command object
	int Variation_3();
	// @cmember Set IReadData, unset IReadData, call Execute()
	int Variation_4();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_Sequence)
#define THE_CLASS TCICMDPRPT_Sequence
BEG_TEST_CASE(TCICMDPRPT_Sequence, TCICMDPRPT, L"test calling sequence")
	TEST_VARIATION(1,		L"Set, Unset, and Unset")
	TEST_VARIATION(2,		L"Unset, Set, Set")
	TEST_VARIATION(3,		L"Multiple rowset objects open on the same command object")
	TEST_VARIATION(4,		L"Set IReadData, unset IReadData, call Execute()")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCICMDPRPT_KAGERA)
//--------------------------------------------------------------------
// @class Kagera specific test case
//
class TCICMDPRPT_KAGERA : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();
	
public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCICMDPRPT_KAGERA,TCICMDPRPT);
	// }}
 
	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember A table without index only has forward only behavior
	int Variation_1();
	// }}
};
// {{ TCW_TESTCASE(TCICMDPRPT_KAGERA)
#define THE_CLASS TCICMDPRPT_KAGERA
BEG_TEST_CASE(TCICMDPRPT_KAGERA, TCICMDPRPT, L"Kagera specific test case")
	TEST_VARIATION(1,		L"A table without index only has forward only behavior")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// {{ TCW_TEST_CASE_MAP(TCExtendedErrors)
//--------------------------------------------------------------------
// @class Extended Errors
//
class TCExtendedErrors : public TCICMDPRPT {
private:
	// @cmember Static array of variations
	DECLARE_TEST_CASE_DATA();

public:
	// {{ TCW_DECLARE_FUNCS
	// @cmember Execution Routine
	DECLARE_TEST_CASE_FUNCS(TCExtendedErrors,TCICMDPRPT);
	// }}

	// @cmember Initialization Routine
	virtual BOOL Init();
	// @cmember Termination Routine
	virtual BOOL Terminate();
	
	// {{ TCW_TESTVARS()
	// @cmember Valid ICommandProperties calls with previous error object existing.
	int Variation_1();
	// @cmember Invalid SetProperties call with previous error object existing
	int Variation_2();
	// @cmember Invalid SetProperties calls with no previous error object existing
	int Variation_3();
	// @cmember Invalid GetProperties calls with previous error object existing.
	int Variation_4();
	// @cmember Invalid GetProperties calls with no previous error object existing
	int Variation_5();
	// }}
};
// {{ TCW_TESTCASE(TCExtendedErrors)
#define THE_CLASS TCExtendedErrors
BEG_TEST_CASE(TCExtendedErrors, TCICMDPRPT, L"Extended Errors")
	TEST_VARIATION(1,		L"Valid ICommandProperties calls with previous error object existing.")
	TEST_VARIATION(2,		L"Invalid SetProperties calls with previous error object existing")
	TEST_VARIATION(3,		L"Invalid SetProperties calls with no previous error object existing")
	TEST_VARIATION(4,		L"Invalid GetProperties calls with previous error object existing")
	TEST_VARIATION(5,		L"Invalid GetProperties calls with no previous error object existing")
END_TEST_CASE()
#undef THE_CLASS
// }}
// }}


// }} END_DECLARE_TEST_CASES()

// {{ TCW_TESTMODULE(ThisModule)
TEST_MODULE(13, ThisModule, gwszModuleDescrip)
	TEST_CASE(1, TCICMDPRPT_BulkProcess)
	TEST_CASE(2, TCICMDPRPT_SetProperties)
	TEST_CASE(3, TCICMDPRPT_UnsetProperties)
	TEST_CASE(4, TCICMDPRPT_Boundary_Set)
	TEST_CASE(5, TCICMDPRPT_Boundary_Get)
	TEST_CASE(6, TCICMDPRPT_Parameters)
	TEST_CASE(7, TCICMDPRPT_SequenceBeforeRowset)
	TEST_CASE(8, TCICMDPRPT_SequenceAfterRowset)
	TEST_CASE(9, TCICMDPRPT_Zombie)
	TEST_CASE(10, TCICMDPRPT_Stress)
	TEST_CASE(11, TCICMDPRPT_Sequence)
	TEST_CASE(12, TCICMDPRPT_KAGERA)
	TEST_CASE(13, TCExtendedErrors)
END_TEST_MODULE()
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_BulkProcess)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_BulkProcess - Use array of GUIDs and DBProperties
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_BulkProcess::Init()
{
	if(TCICMDPRPT::Init())
		return TRUE;
	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a settable rowset property
//
BOOL TCICMDPRPT_BulkProcess::RowsetSettable(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_ROWSET_START;cPrpt<(ULONG)IDX_ROWSET_END;cPrpt++)
	{
		if( g_rgDBProperties[cPrpt].fSettable && 
			g_rgDBProperties[cPrpt].fSupported &&
			g_rgDBProperties[cPrpt].vtType == VT_BOOL )
		{
			*dwPropertyID=g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a not settable rowset property
//
BOOL TCICMDPRPT_BulkProcess::RowsetNotSettable(DBPROPID *dwPropertyID, ULONG *ulPropIdx)
{
	ULONG cPrpt;

	for(cPrpt=IDX_ROWSET_START;cPrpt<(ULONG)IDX_ROWSET_END;cPrpt++)
	{
		if(!(g_rgDBProperties[cPrpt].fSettable) && (g_rgDBProperties[cPrpt].fSupported) )
		{
			*dwPropertyID=g_rgDBProperties[cPrpt].dwPropertyID;
			*ulPropIdx=cPrpt; 
			return TRUE;
		}
	}

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a not supported rowset property
//
BOOL TCICMDPRPT_BulkProcess::RowsetNotSupported(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_ROWSET_START;cPrpt<(ULONG)IDX_ROWSET_END;cPrpt++)
	{
		if(!(g_rgDBProperties[cPrpt].fSupported) && 
			(g_rgDBProperties[cPrpt].vtType==VT_BOOL)
			)
		{
			*dwPropertyID=g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a not supported interface property
//
BOOL TCICMDPRPT_BulkProcess::InterfaceNotSupported(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_INTERFACE_START;cPrpt<=(ULONG)IDX_INTERFACE_END;cPrpt++)
	{
		if(!(g_rgDBProperties[cPrpt].fSupported))
		{
			*dwPropertyID=g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a supported interface property
//
BOOL TCICMDPRPT_BulkProcess::InterfaceSupported(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_INTERFACE_START;cPrpt<=(ULONG)IDX_INTERFACE_END;cPrpt++)
	{
		if((g_rgDBProperties[cPrpt].fSupported) && (g_rgDBProperties[cPrpt].fSettable))
		{
			*dwPropertyID = g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a supported Kagera property
//
BOOL TCICMDPRPT_BulkProcess::KageraSupported(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_KAGERA_START;cPrpt<=(ULONG)IDX_KAGERA_END;cPrpt++)
	{
		if((g_rgDBProperties[cPrpt].fSupported) && (g_rgDBProperties[cPrpt].fSettable))
		{
			*dwPropertyID = g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc cProperties==0
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_1()
{
	BOOL		fPass			= FALSE;
	HRESULT		Exphr			= S_OK;
	ULONG		cCount			= 0;
	ULONG		cDefault		= 0;
	ULONG		cPropertySets	= 0;
	DBPROPSET	*pPropertySets	= NULL;
	DBPROPSET	DBPrptSet;
	DBPROP		DBPrpt;

	// Fixup HResult
	if( !g_rgDBProperties[IDX_CANHOLDROWS].fSupported )
		Exphr = DB_E_ERRORSOCCURRED;

	// Set a rowset property DBPROP_CANHOLDROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet = *(g_rgDBProperties[IDX_CANHOLDROWS].pGuidPropertySet);
	DBPrptSet.cProperties	  = 1;
	DBPrpt.dwPropertyID		  = DBPROP_CANHOLDROWS;
	DBPrpt.dwOptions		  = DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt		  = VT_EMPTY;
   	DBPrptSet.rgProperties	  = &DBPrpt;

	TESTC_(m_pICommandProperties->SetProperties(1,&DBPrptSet),Exphr);

	// Open a rowset
	TESTC(OpenRowset());

	// GetProperties with cPropertyIDSets==0
	TESTC_(m_pICommandProperties->GetProperties(0,NULL,&cPropertySets,&pPropertySets),S_OK);

	// Make sure two property sets are returned
	COMPARE(cPropertySets, 1+g_ulExtraROWProp);

	// Find the DBPROPSET_ROWSET group
	for(cCount=0; cCount < cPropertySets; cCount++)
	{
		if(pPropertySets[cCount].guidPropertySet == DBPROPSET_ROWSET)
		{
			// In no restriction case, GetProperties returns the properties that have been set and
			// values of properties that have not been set but have default values
			for(ULONG cIDX=IDX_ROWSET_START; cIDX <= (ULONG)IDX_INTERFACE_END; cIDX++)
			{
				if(!COMPARE(CheckSet(cIDX,&(pPropertySets->guidPropertySet),
									pPropertySets->cProperties,pPropertySets->rgProperties),TRUE))
					continue;

				if(!(g_rgDBProperties[cIDX].fSupported))
					continue;

				// If the property has a default value, it should be returned as well
				if(g_rgDBProperties[cIDX].vDefault.vt!=VT_EMPTY)
					cDefault++;
			}
			
			// The count of cDefault+1; should be equal to cProperties
			TESTC(cDefault == pPropertySets->cProperties);
			
			fPass=TRUE;
		}
	}

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPropertySets,&pPropertySets);
	ReleaseRowset();

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc GetProperties returns correct info for array of properties in the same property set
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_2()
{
	BOOL		fTest				= FALSE;
	DBPROPSET	*pDBPrpts			= NULL;
	ULONG		cPrpt				= 0;
	ULONG		cDBPropertiesCount	= 0;
	ULONG		cCount				= 0;
	ULONG		ulPropIdx			= 0;
	DBPROPIDSET	pPropertyIDSets;
	DBPROPID	rgPropertyIDs[6];
	DBPROPSET	pPropertySets;
	DBPROP		rgProperties;
	
	// Go back to initial state
	TESTC(ResetProperties());

	// Make sure the rgProperties and rgguidPropertySet contain the same # of elements
	cDBPropertiesCount = sizeof(rgPropertyIDs)/sizeof(rgPropertyIDs[0]);

	// Set an interface property
	memset(&rgProperties ,0,sizeof(DBPROP));
	pPropertySets.guidPropertySet = DBPROPSET_ROWSET;
	pPropertySets.cProperties	  = 1;
   	pPropertySets.rgProperties	  = &rgProperties;

	rgProperties.dwPropertyID	  = DBPROP_IRowset;
	rgProperties.dwOptions		  = DBPROPOPTIONS_REQUIRED;
	rgProperties.vValue.vt		  = VT_BOOL;
	V_BOOL(&rgProperties.vValue)  = VARIANT_FALSE;

	// We expect the following to fail because you can not set DBPROP_IRowset
	TESTC_(m_pICommandProperties->SetProperties(1,&pPropertySets),DB_E_ERRORSOCCURRED);

	// IID_IRowsetInfo should always be set
	rgPropertyIDs[0] = DBPROP_IRowset;
	rgPropertyIDs[1] = DBPROP_IRowsetInfo;
	
	// Get a not supported interface
	if(!InterfaceNotSupported(&(rgPropertyIDs[2])))
		rgPropertyIDs[2] = 0;

	// Get a settable interface property, set it
	if(!InterfaceSupported(&rgPropertyIDs[3]))
		rgPropertyIDs[3] = DBPROP_IRowset;

   	pPropertySets.rgProperties	 = &rgProperties;

	rgProperties.dwPropertyID	 = rgPropertyIDs[3];
   	rgProperties.dwOptions		 = DBPROPOPTIONS_REQUIRED;
	rgProperties.vValue.vt		 = VT_BOOL;
	V_BOOL(&rgProperties.vValue) = VARIANT_TRUE;

	// Set the interface property
	TESTC_(m_pICommandProperties->SetProperties(1,&pPropertySets),S_OK);

	// Get an unsettable rowset property
	if(!RowsetNotSettable(&rgPropertyIDs[4],&ulPropIdx))
		return TEST_SKIPPED;

	// Get a not supported property
	if(!RowsetNotSupported(&(rgPropertyIDs[5])))
		rgPropertyIDs[5]=0;

	// Set up for GetProperties.
	pPropertyIDSets.cPropertyIDs	= cDBPropertiesCount;
	pPropertyIDSets.rgPropertyIDs	= rgPropertyIDs;
	pPropertyIDSets.guidPropertySet	= DBPROPSET_ROWSET;

	TESTC_(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
										&cPrpt,&pDBPrpts),DB_S_ERRORSOCCURRED);

	// Make sure GetProperties return correct infomation
	TESTC(cPrpt == 1);
	TESTC(pDBPrpts->cProperties == cDBPropertiesCount);

	for(cCount=0; cCount < cDBPropertiesCount; cCount++) {
		// If DBPROPSTATUS_NOTSUPPORTED dwOption is undefined
		if(pDBPrpts->rgProperties[cCount].dwStatus != DBPROPSTATUS_NOTSUPPORTED)
		{
			if(pDBPrpts->rgProperties[cCount].dwPropertyID == rgPropertyIDs[3])
				TESTC(pDBPrpts->rgProperties[cCount].dwOptions == DBPROPOPTIONS_REQUIRED);
		}
		TESTC(rgPropertyIDs[cCount] == pDBPrpts->rgProperties[cCount].dwPropertyID);
	}

	// The first inteface property should always be true
	// IID_IRowsetInfo should always return TRUE and it is the default
	TESTC(pDBPrpts->rgProperties[0].dwStatus == DBPROPSTATUS_OK);
	TESTC(V_BOOL(&pDBPrpts->rgProperties[0].vValue) == VARIANT_TRUE);
	
	TESTC(pDBPrpts->rgProperties[1].dwStatus == DBPROPSTATUS_OK);
	TESTC(V_BOOL(&pDBPrpts->rgProperties[1].vValue) == VARIANT_TRUE);

	// The third interface property is not supported
	TESTC(pDBPrpts->rgProperties[2].dwStatus == DBPROPSTATUS_NOTSUPPORTED);

	// The 4th property should be set to true
	TESTC(V_BOOL(&pDBPrpts->rgProperties[3].vValue) == VARIANT_TRUE);
	
	// The 5th property should return default value
	TESTC(pDBPrpts->rgProperties[4].dwStatus == DBPROPSTATUS_OK);

	// The 6th property should return not supported
	TESTC(pDBPrpts->rgProperties[5].dwStatus == DBPROPSTATUS_NOTSUPPORTED);

	fTest=TRUE;

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc SetProperties set array of properties in the same property set
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_3()
{
	BOOL		fTest=FALSE;
	DBPROPSET	pPropertySets;
	DBPROP		rgProperties[6];
	DBPROPSET	*pDBPrpts=NULL;
	ULONG		cPrpt=0;
	ULONG		cDBPropertiesCount=0;
	ULONG		ulPropIdx=0;
	DBPROPIDSET	pPropertyIDSets;
	DBPROPID	rgPropertyIDs[3];

	// Go back to initial state
	TESTC(ResetProperties());
	
	// Make sure the rgProperties and rgguidPropertySet contain the same # of elements
	cDBPropertiesCount = sizeof(rgProperties)/sizeof(rgProperties[0]);

	memset(&rgProperties ,0,(sizeof(DBPROP)*cDBPropertiesCount));
	pPropertySets.cProperties	 = cDBPropertiesCount;
   	pPropertySets.rgProperties	 = rgProperties;
	pPropertySets.guidPropertySet= DBPROPSET_ROWSET;

	// Get an settable interface
	if(!InterfaceSupported(&(rgPropertyIDs[0]))) 
	{
		rgPropertyIDs[0] = DBPROP_IRowset;
		V_BOOL(&rgProperties[0].vValue) = VARIANT_TRUE;
	}
	else
		V_BOOL(&rgProperties[0].vValue) = VARIANT_FALSE;

	rgProperties[0].dwPropertyID = rgPropertyIDs[0];
	rgProperties[0].dwOptions	 = DBPROPOPTIONS_REQUIRED;
	rgProperties[0].vValue.vt	 = VT_BOOL;

	// Get an unsettable interface
	rgPropertyIDs[1]				= DBPROP_IAccessor;
	rgProperties[1].dwPropertyID	= DBPROP_IAccessor;
	rgProperties[1].dwOptions		= DBPROPOPTIONS_REQUIRED;
	rgProperties[1].vValue.vt		= VT_BOOL;
	V_BOOL(&rgProperties[1].vValue) = VARIANT_FALSE;

	// Get a not supported interface
	if(!InterfaceNotSupported(&(rgProperties[2].dwPropertyID)))
		rgProperties[2].dwPropertyID = 0;

	rgPropertyIDs[2]		  = rgProperties[2].dwPropertyID;
	rgProperties[2].dwOptions = DBPROPOPTIONS_REQUIRED;

	// Get an unsettable rowset property
	if(!RowsetNotSettable(&rgProperties[3].dwPropertyID,&ulPropIdx))
		return TEST_SKIPPED;

	rgProperties[3].dwOptions		= DBPROPOPTIONS_REQUIRED;
	rgProperties[3].vValue.vt		= g_rgDBProperties[ulPropIdx].vtType;
	
	if( g_rgDBProperties[ulPropIdx].vtType == VT_BOOL )
	{
		if( g_rgDBProperties[ulPropIdx].vDefault.boolVal == VARIANT_TRUE )
			V_BOOL(&rgProperties[3].vValue)	= VARIANT_FALSE;
		else
			V_BOOL(&rgProperties[3].vValue) = VARIANT_TRUE;
	}
	else
		V_I4(&rgProperties[3].vValue) = g_rgDBProperties[ulPropIdx].vDefault.lVal+1;

	// Get a not supported property
	if(!RowsetNotSupported(&(rgProperties[4].dwPropertyID)))
		rgProperties[4].dwPropertyID = 0;

	rgProperties[4].dwOptions = DBPROPOPTIONS_REQUIRED;

	// Get a settable interface property
	if(!InterfaceSupported(&(rgProperties[5].dwPropertyID)))
		rgProperties[5].dwPropertyID = DBPROP_IRowset;

	rgProperties[5].dwOptions		= DBPROPOPTIONS_REQUIRED;
	rgProperties[5].vValue.vt		= VT_BOOL;
	V_BOOL(&rgProperties[5].vValue)	= VARIANT_TRUE;

	// Set the array of properties
	TESTC_(m_pICommandProperties->SetProperties(1,&pPropertySets),DB_S_ERRORSOCCURRED);

	// Make sure dwStatus returns the correct error information
	TESTC(rgProperties[0].dwStatus == DBPROPSTATUS_OK);

	// 2nd interface is not settable
	TESTC(rgProperties[1].dwStatus == DBPROPSTATUS_NOTSETTABLE);

	// 3rd interface is not supported
	TESTC(rgProperties[2].dwStatus == DBPROPSTATUS_NOTSUPPORTED);

	// 4th rowset property is not settable
	TESTC(rgProperties[3].dwStatus == DBPROPSTATUS_NOTSETTABLE);

	// 5th rowset property is not supported
	TESTC(rgProperties[4].dwStatus == DBPROPSTATUS_NOTSUPPORTED);

	// 6th property should be set
	TESTC(rgProperties[5].dwStatus == DBPROPSTATUS_OK);

	// Set up for GetProperties.
	pPropertyIDSets.cPropertyIDs	= 2;
	pPropertyIDSets.guidPropertySet = DBPROPSET_ROWSET;
	pPropertyIDSets.rgPropertyIDs	= rgPropertyIDs;

	TESTC_(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK);

	TESTC(V_BOOL(&pDBPrpts->rgProperties[0].vValue) == VARIANT_TRUE);
	TESTC(V_BOOL(&pDBPrpts->rgProperties[1].vValue) == VARIANT_TRUE);

    fTest=TRUE;
	
CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc Duplicated property IDs
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_4()
{
	BOOL		fTest=FALSE;
	DBPROPSET	pPropertySets;
	DBPROP		rgProperties[2];
	DBPROPSET	*pDBPrpts=NULL;
	ULONG		cPrpt=0;
	ULONG		cCount=0;
	DBPROPIDSET	pPropertyIDSets;
	DBPROPID	rgPropertyIDs[2];

	// Go back to initial state
	TESTC(ResetProperties());

	// Find a supported interface
	if(VerifySupported(IDX_IROWSETLOCATE))
		rgPropertyIDs[0] = DBPROP_IRowsetLocate;
	else if(!InterfaceSupported(&(rgPropertyIDs[0])))
		return TEST_SKIPPED;

	memset(&rgProperties ,0,(sizeof(DBPROP)*2));
	pPropertySets.cProperties	 = 2;
   	pPropertySets.rgProperties	 = rgProperties;
	pPropertySets.guidPropertySet= DBPROPSET_ROWSET;
	
	rgProperties[0].dwPropertyID	= rgPropertyIDs[0];
	rgProperties[0].dwOptions		= DBPROPOPTIONS_REQUIRED;
	rgProperties[0].vValue.vt		= VT_BOOL;
	V_BOOL(&rgProperties[0].vValue) = VARIANT_TRUE;

	// Copy the same info 
	rgProperties[1] = rgProperties[0];
	rgPropertyIDs[1]= rgPropertyIDs[0];

	// Set duplicate properties
	TESTC_(m_pICommandProperties->SetProperties(1,&pPropertySets),S_OK);

	// Set up for GetProperties.
	pPropertyIDSets.cPropertyIDs	= 2;
	pPropertyIDSets.guidPropertySet	= DBPROPSET_ROWSET;
	pPropertyIDSets.rgPropertyIDs	= rgPropertyIDs;

	// Get duplicate properties
	TESTC_(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,&cPrpt,&pDBPrpts),S_OK);

	// Count of property sets
	TESTC(cPrpt == 1);

	// Count of properties in the property set
	TESTC(pDBPrpts->cProperties == 2);

	// Verify we get the same property
	for(cCount=0; cCount< pDBPrpts->cProperties; cCount++) {
		TESTC(pDBPrpts->rgProperties[cCount].dwPropertyID == rgProperties[0].dwPropertyID);
		TESTC(V_BOOL(&pDBPrpts->rgProperties[cCount].vValue) == V_BOOL(&rgProperties[0].vValue));
	}

	fTest=TRUE;

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc MAXROWS >= MAXOPENROWS verified with two GetProperties calls
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_5()
{
	BOOL		fTest=FALSE;
	HRESULT		ExpHR=S_OK;
	DBPROPSET	*pDBPrpts=NULL;
	DBPROPSET	*pDBPrpts2=NULL;
	ULONG		cPrpt=0;
	ULONG		cPrpt2=0;
	DBPROPIDSET	pPropertyIDSets;
	DBPROPID	rgPropertyIDs;
	DBPROPIDSET	pPropertyIDSets2;
	DBPROPID	rgPropertyIDs2;

	// Go back to initial state
	TESTC(ResetProperties());

	// The two properies have to be supported
	if(!VerifySupported(IDX_MAXROWS))
		ExpHR = DB_S_ERRORSOCCURRED;
	
	if(!VerifySupported(IDX_MAXOPENROWS))
		ExpHR = DB_E_ERRORSOCCURRED;

	// Verify MAXROWS >= MAXOPENROWS
	pPropertyIDSets.cPropertyIDs	= 1;
	pPropertyIDSets.rgPropertyIDs	= &rgPropertyIDs;
	pPropertyIDSets.guidPropertySet	= DBPROPSET_ROWSET;
	rgPropertyIDs					= DBPROP_MAXROWS;

	pPropertyIDSets2.cPropertyIDs	= 1;
	pPropertyIDSets2.rgPropertyIDs	= &rgPropertyIDs2;
	pPropertyIDSets2.guidPropertySet= DBPROPSET_ROWSET;
	rgPropertyIDs2					= DBPROP_MAXOPENROWS;

	TESTC_(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),ExpHR);

	TESTC_(m_pICommandProperties->GetProperties(1,&pPropertyIDSets2,
													&cPrpt2,&pDBPrpts2),ExpHR);

	// Make sure that MAXROWS is greater than MAXOPENROWS
	if(pDBPrpts->rgProperties->vValue.lVal)
	{
		TESTC((pDBPrpts->rgProperties->vValue.lVal >= pDBPrpts2->rgProperties->vValue.lVal) == TRUE);
	}
	else
	{
		TESTC((pDBPrpts2->rgProperties->vValue.lVal >= 0) == TRUE);
	}
		
	fTest=TRUE;

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);
	FreeProperties(&cPrpt2,&pDBPrpts2);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc GetProperties returns correct info for array of properties in different property sets
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_6()
{
	BOOL		fTest=FALSE;
	HRESULT		ExpHR=S_OK;
	DBPROPSET	*pDBPrpts=NULL;
	ULONG		cPrpt=0;
	DBPROPIDSET	pPropertyIDSets[2];
	DBPROPID	rgPropertyIDs[2];
	DBPROPID	rgPropertyIDs2;

	// Go back to initial state
	TESTC(ResetProperties());

	// The properies have to be supported
	// Get a setttable interface
	if(!InterfaceSupported(&(rgPropertyIDs[0])))
		rgPropertyIDs[0] = DBPROP_IRowset;

	// Get a settable rowset property 
	if(!RowsetSettable(&(rgPropertyIDs[1])))
		rgPropertyIDs[1] = DBPROP_IRowsetInfo;

	// Get a settable rowset property 
	if(!KageraSupported(&rgPropertyIDs2)) {
		ExpHR = DB_S_ERRORSOCCURRED;
		rgPropertyIDs2 = 0;
	}

	// Set parameters needed for the GetProperties call
	pPropertyIDSets[0].cPropertyIDs	  = 2;
	pPropertyIDSets[0].rgPropertyIDs  = rgPropertyIDs;
	pPropertyIDSets[0].guidPropertySet= DBPROPSET_ROWSET;

	pPropertyIDSets[1].cPropertyIDs	  = 1;
	pPropertyIDSets[1].rgPropertyIDs  = &rgPropertyIDs2;
	pPropertyIDSets[1].guidPropertySet= DBPROPSET_PROVIDERROWSET;

	TESTC_(m_pICommandProperties->GetProperties(2,pPropertyIDSets,
													&cPrpt,&pDBPrpts),ExpHR);

	// Count of property sets
	TESTC(cPrpt == 2);

	// Verify that the elements of each array (guidPropertySets and property IDs)
	// are returned in the same order.
	TESTC(pDBPrpts[0].rgProperties[0].dwPropertyID == rgPropertyIDs[0]);
	TESTC(pDBPrpts[0].rgProperties[1].dwPropertyID == rgPropertyIDs[1]);
	TESTC(pDBPrpts[1].rgProperties->dwPropertyID == rgPropertyIDs2);

	fTest=TRUE;

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc SetProperties sets array of properties in different property sets
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_7()
{
	BOOL		fTest=FALSE;
	HRESULT		ExpHR=S_OK;
	DBPROPSET	pPropertySets[2];
	DBPROP		rgProperties[2];
	DBPROP		rgProperties2;
	DBPROPSET	*pDBPrpts=NULL;
	ULONG		cPrpt=0;
	DBPROPIDSET	pPropertyIDSets[2];
	DBPROPID	rgPropertyIDs[2];
	DBPROPID	rgPropertyIDs2;

	// Go back to initial state
	TESTC(ResetProperties());

	// Get a setttable interface
	if(!InterfaceSupported(&(rgPropertyIDs[0])))
		rgPropertyIDs[0]=DBPROP_IRowset;
	
	// Get a settable rowset property 
	if(!RowsetSettable(&(rgPropertyIDs[1])))
		rgPropertyIDs[1] = DBPROP_IRowsetInfo;
	
	// Set parameters needed for the GetProperties call
	memset(&rgProperties ,0,(sizeof(DBPROP)*2));
	memset(&rgProperties2 ,0,sizeof(DBPROP));

	pPropertySets[0].cProperties	 = 2;
   	pPropertySets[0].rgProperties	 = rgProperties;
	pPropertySets[0].guidPropertySet = DBPROPSET_ROWSET;
	
	rgProperties[0].dwPropertyID	 = rgPropertyIDs[0];
	rgProperties[0].dwOptions		 = DBPROPOPTIONS_REQUIRED;
	rgProperties[0].vValue.vt		 = VT_BOOL;
	V_BOOL(&rgProperties[0].vValue)	 = VARIANT_TRUE;

	rgProperties[1].dwPropertyID	 = rgPropertyIDs[1];
	rgProperties[1].dwOptions		 = DBPROPOPTIONS_REQUIRED;
	rgProperties[1].vValue.vt		 = VT_BOOL;
	V_BOOL(&rgProperties[1].vValue)  = VARIANT_FALSE;

	// Get a settable PROVIDERROWSET property 
	if(!KageraSupported(&rgPropertyIDs2)) {
		ExpHR = DB_S_ERRORSOCCURRED;
		rgPropertyIDs2 = 0;
	}

	pPropertySets[1].cProperties	 = 1;
   	pPropertySets[1].rgProperties	 = &rgProperties2;
	pPropertySets[1].guidPropertySet = DBPROPSET_PROVIDERROWSET;

	rgProperties2.dwPropertyID		 = rgPropertyIDs2;
	rgProperties2.dwOptions			 = DBPROPOPTIONS_REQUIRED;
	rgProperties2.vValue.vt			 = VT_BOOL;
	V_BOOL(&rgProperties2.vValue)	 = VARIANT_TRUE;

	// Set the array of properties
	TESTC_(m_pICommandProperties->SetProperties(2,pPropertySets),ExpHR);

	// Set parameters needed for the GetProperties call
	pPropertyIDSets[0].cPropertyIDs		= 2;
	pPropertyIDSets[0].rgPropertyIDs	= rgPropertyIDs;
	pPropertyIDSets[0].guidPropertySet	= DBPROPSET_ROWSET;

	pPropertyIDSets[1].cPropertyIDs		= 1;
	pPropertyIDSets[1].rgPropertyIDs	= &rgPropertyIDs2;
	pPropertyIDSets[1].guidPropertySet	= DBPROPSET_PROVIDERROWSET;

	TESTC_(m_pICommandProperties->GetProperties(2,pPropertyIDSets,
													&cPrpt,&pDBPrpts),ExpHR);

	// Count of property sets
	TESTC(cPrpt == 2);

	// Verify that the elements of each array (guidPropertySets and property IDs)
	// are returned in the same order.
	TESTC(pDBPrpts[0].rgProperties[0].dwPropertyID == rgPropertyIDs[0]);
	TESTC(pDBPrpts[0].rgProperties[1].dwPropertyID == rgPropertyIDs[1]);
	TESTC(pDBPrpts[1].rgProperties->dwPropertyID == rgPropertyIDs2);

	fTest=TRUE;

CLEANUP:

	// Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc Set all Interface properties with DBPROPOPTIONS_OPTIONAL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_BulkProcess::Variation_8()
{
	BOOL		fTest=FALSE;
	DBPROPSET	pPropertySets;
	DBPROP		*prgProperties=NULL;
	DBPROPSET	*pDBPrpts=NULL;
	ULONG		cCount=0;
	ULONG		i=0;
	ULONG		cProperties=(IDX_INTERFACE_END-IDX_INTERFACE_START);

	// Go back to initial state
	TESTC(ResetProperties());

	// Allocate memory for the PropIDs
	prgProperties = (DBPROP *) PROVIDER_ALLOC(cProperties * sizeof(DBPROP));
	ZeroMemory(prgProperties,(sizeof(DBPROP) * cProperties));

	// Set the properties
	for(i=0; i<cProperties; i++)
	{		
		prgProperties[i].dwPropertyID	  = g_rgDBProperties[IDX_INTERFACE_START+i].dwPropertyID;
		prgProperties[i].dwOptions		  = DBPROPOPTIONS_OPTIONAL;
		prgProperties[i].vValue.vt		  = VT_BOOL;
		V_BOOL(&prgProperties[i].vValue) = VARIANT_TRUE;
	}

	pPropertySets.cProperties	 = cProperties;
   	pPropertySets.rgProperties	 = prgProperties;
	pPropertySets.guidPropertySet= DBPROPSET_ROWSET;

	// Set duplicate properties
	TESTC_(m_pICommandProperties->SetProperties(1,&pPropertySets),DB_S_ERRORSOCCURRED);

	fTest=TRUE;

CLEANUP:

	// Free memory from Properties
	PROVIDER_FREE(prgProperties);

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_BulkProcess::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_SetProperties)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_SetProperties - set all interface and rowset properties
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SetProperties::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT_ChangeProperties::Init())
	// }}
	{
		return TRUE;
	}
	return FALSE;
}


//
// @cmember Verify the attribute of the property
//
BOOL TCICMDPRPT_SetProperties::VerifyProperty
(ULONG cPrpt,			//@[in] The index to g_rgDBProperties array
 BOOL  fIReadData,		//@[in] IReadData
 ULONG cImpPrpt,		//@[in] The count of implied properties
 ULONG rgIDXPrpt[])		//@[in] The implied properties array
{
	switch (GetPrptAttr(cPrpt))
	{
		case INTERFACE_MANDATORY:
			return(VerifyInterfaceMandatory(cPrpt,fIReadData));

		case INTERFACE_NOT_SUPPORTED:
			return(VerifyNotSupported(cPrpt,INTERFACE_NOT_SUPPORTED));

		case INTERFACE_SUPPORTED:
			return(VerifyInterfaceSupported(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,TRUE));

		case ROWSET_NOT_SUPPORTED:
			return(VerifyNotSupported(cPrpt,ROWSET_NOT_SUPPORTED));

		case ROWSET_NOT_SETTABLE:
			return(VerifyRowsetNotSettable(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,TRUE));

		case ROWSET_SETTABLE:
			return(VerifyRowsetSettable(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,TRUE));

		case PROPERTY_INVALID:
			odtLog<<wszIndexNotValid;
		default:
			return FALSE;
	}
}


//-------------------------------------------------------------------------------------
// @cmember: Verify the implied properties are supported after the rowset is open
//
BOOL TCICMDPRPT_SetProperties::VerifyImpliedProperties
(
 ULONG cImpPrpt,		//@[in]: The count of implied properties
 ULONG rgIDXPrpt[]		//@[in]: The array of index to the implied properties
)
{
	DBPROPIDSET			pPropertyIDSets;
	DBPROPID			rgPropertyIDs;
	ULONG				cPrpt;
	DBPROPSET			*pDBPrpts=NULL;
	ULONG				cLoop;
	const GUID			*pGuidProperty;
	IUnknown			*pIUnknown;
	BOOL				fTest=FALSE;

	for(cLoop=0;cLoop<cImpPrpt;cLoop++)
	{
		assert(rgIDXPrpt[cLoop]<=(ULONG)IDX_INTERFACE_END);

		pPropertyIDSets.guidPropertySet=*(g_rgDBProperties[rgIDXPrpt[cLoop]].pGuidPropertySet);
		pPropertyIDSets.cPropertyIDs=1;
		rgPropertyIDs=g_rgDBProperties[rgIDXPrpt[cLoop]].dwPropertyID;
   		pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

		//Call GetProperties to verify the property is set
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&pPropertyIDSets,
												&cPrpt,&pDBPrpts),S_OK))
			goto END;

		if(!COMPARE(V_BOOL(&pDBPrpts->rgProperties->vValue), VARIANT_TRUE))
			goto END;

		//Free memory from GetProperties
		FreeProperties(&cPrpt,&pDBPrpts);

		//Call QueryInterface to verify that the property is set
		if(rgIDXPrpt[cLoop]>=(ULONG)IDX_INTERFACE_START)
		{
			//Get the guid for the interface
			pGuidProperty=GetGuidPointer(cPrpt);

			//If the property is an interface property call
			//QueryInterface to verify that the property is set.
			if(!CHECK(m_pIRowsetInfo->QueryInterface(*pGuidProperty,
													(LPVOID *)&pIUnknown),S_OK))
				goto END;

			fTest=TRUE;

			SAFE_RELEASE(pIUnknown);
		}
	}

	//Mark that success 
	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest && (cLoop==cImpPrpt))
		return TRUE;
	else
		return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ACTIVESESSIONS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_1()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ACTIVESESSIONS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ASYNCTXNABORT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_2()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ASYNCTXNABORT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ASYNCTXNCOMMIT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_3()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ASYNCTXNCOMMIT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_BYREFACCESSORS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_4()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BYREFACCESSORS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CATALOGLOCATION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_5()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CATALOGLOCATION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CATALOGTERM
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_6()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CATALOGTERM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CATALOGUSAGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_7()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CATALOGUSAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COLUMNDEFINITION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_8()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COLUMNDEFINITION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CONCATNULLBEHAVIOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_9()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CONCATNULLBEHAVIOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DATASOURCENAME
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_10()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DATASOURCENAME,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DATASOURCEREADONLY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_11()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DATASOURCEREADONLY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DBMSNAME
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_12()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DBMSNAME,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(13)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DBMSVER
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_13()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DBMSVER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(14)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DSOTHREADMODEL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_14()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DSOTHREADMODEL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(15)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_GROUPBY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_15()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_GROUPBY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(16)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_HETEROGENEOUSTABLES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_16()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_HETEROGENEOUSTABLES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(17)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_IDENTIFIERCASE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_17()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IDENTIFIERCASE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(18)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXINDEXSIZE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_18()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXINDEXSIZE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(19)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXOPENCHAPTERS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_19()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXOPENCHAPTERS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(20)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXORSINFILTER
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_20()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXORSINFILTER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(21)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXROWSIZE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_21()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXROWSIZE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(22)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXROWSIZEINCLUDESBLOB
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_22()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXROWSIZEINCLUDESBLOB,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(23)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXSORTCOLUMNS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_23()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXSORTCOLUMNS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(24)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXTABLESINSELECT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_24()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXTABLESINSELECT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(25)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MULTIPLEPARAMSETS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_25()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MULTIPLEPARAMSETS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(26)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MULTIPLERESULTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_26()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MULTIPLERESULTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(27)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MULTIPLESTORAGEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_27()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (!VerifyProperty(IDX_MULTIPLESTORAGEOBJECTS,FALSE,0,NULL))
		return TEST_FAIL;
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(28)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MULTITABLEUPDATE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_28()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MULTITABLEUPDATE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(29)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NULLCOLLATION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_29()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NULLCOLLATION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(30)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OLEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_30()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OLEOBJECTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(31)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ORDERBYCOLUMNSINSELECT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_31()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ORDERBYCOLUMNSINSELECT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(32)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OUTPUTPARAMETERAVAILABILITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_32()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OUTPUTPARAMETERAVAILABILITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(33)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PERSISTENTIDTYPE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_33()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PERSISTENTIDTYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(34)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PREPAREABORTBEHAVIOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_34()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PREPAREABORTBEHAVIOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(35)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PREPARECOMMITBEHAVIOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_35()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PREPARECOMMITBEHAVIOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(36)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PROCEDURETERM
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_36()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PROCEDURETERM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(37)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PROVIDERNAME
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_37()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PROVIDERFILENAME,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(38)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PROVIDEROLEDBVER
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_38()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PROVIDEROLEDBVER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(39)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_PROVIDERVER
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_39()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_PROVIDERVER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(40)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_QUOTEDIDENTIFIERCASE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_40()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_QUOTEDIDENTIFIERCASE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(41)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ROWSETCONVERSIONSONCOMMAND
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_41()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWSETCONVERSIONSONCOMMAND,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(42)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SCHEMATERM
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_42()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SCHEMATERM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(43)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SCHEMAUSAGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_43()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SCHEMAUSAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(44)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SORTONINDEX
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_44()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SORTONINDEX,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(45)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SQLSUPPORT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_45()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SQLSUPPORT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(46)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_STRUCTUREDSTORAGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_46()
{
	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_STRUCTUREDSTORAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(47)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SUBQUERIES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_47()
{
	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_SUBQUERIES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(48)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SUPPORTEDTXNDDL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_48()
{
	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_SUPPORTEDTXNDDL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(49)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SUPPORTEDTXNISOLEVELS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_49()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SUPPORTEDTXNISOLEVELS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(50)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SUPPORTEDTXNISORETAIN
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_50()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SUPPORTEDTXNISORETAIN,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(51)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_TABLETERM
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_51()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_TABLETERM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(52)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_USERNAME
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_52()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_USERNAME,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(53)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CURRENTCATALOG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_53()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CURRENTCATALOG,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(54)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_CACHE_AUTHINFO
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_54()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_CACHE_AUTHINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(55)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_ENCRYPT_PASSWORD
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_55()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_ENCRYPT_PASSWORD,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(56)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_INTEGRATED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_56()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_INTEGRATED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(57)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_MASK_PASSWORD
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_57()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_MASK_PASSWORD,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(58)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_PASSWORD
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_58()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_PASSWORD,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(59)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_PERSIST_ENCRYPTED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_59()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_PERSIST_ENCRYPTED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(60)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_60()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_PERSIST_SENSITIVE_AUTHINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(61)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_AUTH_USERID
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_61()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_AUTH_USERID,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(62)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_ASYNCH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_62()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_ASYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(63)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_DATASOURCE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_63()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_DATASOURCE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(64)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_HWND
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_64()
{
	//For this property, request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_HWND,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(65)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_IMPERSONATION_LEVEL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_65()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_IMPERSONATION_LEVEL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(66)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_LCID
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_66()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_LCID,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(67)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_LOCATION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_67()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_LOCATION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(68)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_MODE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_68()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_MODE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(69)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_PROMPT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_69()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_PROMPT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(70)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_PROTECTION_LEVEL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_70()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_PROTECTION_LEVEL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(71)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_PROVIDERSTRING
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_71()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_PROVIDERSTRING,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(72)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INIT_TIMEOUT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_72()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INIT_TIMEOUT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(73)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_AUTOINCREMENT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_73()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_AUTOINCREMENT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(74)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_DEFAULT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_74()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_DEFAULT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(75)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_DESCRIPTION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_75()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_DESCRIPTION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(76)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_FIXEDLENGTH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_76()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_FIXEDLENGTH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(77)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_NULLABLE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_77()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_NULLABLE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(78)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_PRIMARYKEY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_78()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_PRIMARYKEY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(79)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COL_UNIQUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_79()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COL_UNIQUE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(80)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_AUTOUPDATE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_80()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_AUTOUPDATE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(81)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_CLUSTERED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_81()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_CLUSTERED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(82)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_FILLFACTOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_82()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_FILLFACTOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(83)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_INITIALSIZE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_83()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_INITIALSIZE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(84)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_NULLCOLLATION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_84()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_NULLCOLLATION,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(85)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_NULLS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_85()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_NULLS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(86)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_PRIMARYKEY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_86()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_PRIMARYKEY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(87)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_SORTBOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_87()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_SORTBOOKMARKS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(88)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_TEMPINDEX
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_88()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_TEMPINDEX,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(89)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_TYPE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_89()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_TYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(90)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_INDEX_UNIQUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_90()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_INDEX_UNIQUE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(91)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SESS_AUTOCOMMITISOLEVELS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_91()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SESS_AUTOCOMMITISOLEVELS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(92)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_TBL_TEMPTABLE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_92()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_TBL_TEMPTABLE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(93)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ABORTPRESERVE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_93()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ABORTPRESERVE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(94)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_APPENDONLY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_94()
{
	// DBPROP_APPENDONLY set to VARIANT_TRUE implies:
	// DBPROP_IRowsetChange is VARIANT_TRUE
	// DBPROP_OWNINSERT is VARIANT_TRUE
	ULONG	rgImpPrpt[2]={IDX_IROWSETCHANGE,IDX_OWNINSERT};

	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_APPENDONLY,FALSE,2,rgImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(95)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_BLOCKINGSTORAGEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_95()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BLOCKINGSTORAGEOBJECTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(96)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_BOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_96()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(97)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_BOOKMARKSKIPPED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_97()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKSKIPPED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(98)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_BOOKMARKTYPE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_98()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKTYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(99)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CACHEDEFERRED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_99()
{
	//Setting the value of the DBPROP_CACHEDEFERRED property to VARIANT_TRUE
	//implicitly sets the value of DBPROP_DEFERRED property to VARIANT_TRUE.
	ULONG	uImpPrpt=IDX_DEFERRED;

	//For this property, do not request IReadData on the rowset
	if (VerifyProperty(IDX_CACHEDEFERRED,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(100)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CANFETCHBACKWARDS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_100()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANFETCHBACKWARDS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(101)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CANHOLDROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_101()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANHOLDROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(102)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CANSCROLLBACKWARDS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_102()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANSCROLLBACKWARDS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(103)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_CHANGEINSERTEDROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_103()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CHANGEINSERTEDROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(104)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COLUMNRESTRICT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_104()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COLUMNRESTRICT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(105)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COMMANDTIMEOUT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_105()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COMMANDTIMEOUT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(106)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_COMMITPRESERVE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_106()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COMMITPRESERVE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(107)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DEFERRED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_107()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if(!VerifyProperty(IDX_DEFERRED,FALSE,0,NULL))
		return TEST_FAIL;
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(108)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_DELAYSTORAGEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_108()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DELAYSTORAGEOBJECTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(109)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_FILTERCOMPAREOPS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_109()
{
	//This property can be VARIANT_TRUE only if DBPROP_OWNINSERT is VARIANT_TRUE.

	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_FILTERCOMPAREOPS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(110)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_FINDCOMPAREOPS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_110()
{
	//This property can be VARIANT_TRUE only if DBPROP_OWNINSERT is VARIANT_TRUE.

	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_FINDCOMPAREOPS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(111)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_IMMOBILEROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_111()
{
	//This property can be VARIANT_TRUE only if DBPROP_OWNINSERT is VARIANT_TRUE.

	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IMMOBILEROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(112)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_LITERALBOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_112()
{
	//DBPROP_LITERALBOOKMARKS implies DBPROP_BOOKMARKS.
	ULONG	uImpPrpt=IDX_BOOKMARKS; 

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_LITERALBOOKMARKS,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(113)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_LITERALIDENTITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_113()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_LITERALIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(114)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXOPENROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_114()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXOPENROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(115)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXPENDINGROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_115()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXPENDINGROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(116)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAXROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_116()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(117)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MAYWRITECOLUMN
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_117()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (!VerifyProperty(IDX_MAYWRITECOLUMN,FALSE,0,NULL))
		return TEST_FAIL;
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(118)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_MEMORYUSAGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_118()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MEMORYUSAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(119)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFICATIONPHASES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_119()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFICATIONPHASES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(120)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYCOLUMNSET
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_120()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYCOLUMNSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(121)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_121()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWDELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(122)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWFIRSTCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_122()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWFIRSTCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(123)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_123()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(124)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWRESYNCH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_124()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWRESYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(125)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWSETRELEASE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_125()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWSETRELEASE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(126)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_126()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWSETFETCHPOSITIONCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(127)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWUNDOCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_127()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDOCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(128)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWUNDODELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_128()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDODELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(129)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWUNDOINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_129()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDOINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(130)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_NOTIFYROWUPDATE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_130()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUPDATE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(131)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ORDEREDBOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_131()
{
	//DBPROP_ORDEREDBOOKMARKS implys DBPROP_BOOKMARKS.
	ULONG	uImpPrpt=IDX_BOOKMARKS; 

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_ORDEREDBOOKMARKS,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(132)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OTHERINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_132()
{
	ULONG	rgImpPrpt[3]={IDX_OTHERUPDATEDELETE,IDX_OWNINSERT,IDX_OWNUPDATEDELETE};

	//If running with provider Kagera
	if (*g_pwszProviderName && 
		!(wcscmp(g_pwszProviderName,L"Microsoft OLE DB Provider for ODBC Drivers")))
	{
		//For this property, do not request IReadData on the rowset.
		if (VerifyProperty(IDX_OTHERINSERT,FALSE,3,rgImpPrpt))
			return TEST_PASS;
		else
			return TEST_FAIL;
	}
	else
	{
		//For this property, do not request IReadData on the rowset, there is no
		//implied properties after execution.
		if (VerifyProperty(IDX_OTHERINSERT,FALSE,0,NULL))
			return TEST_PASS;
		else
			return TEST_FAIL;
	}
}
// }}


// {{ TCW_VAR_PROTOTYPE(133)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OTHERUPDATEDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_133()
{
	ULONG	rgImpPrpt[1]={IDX_OWNUPDATEDELETE};

	//If running with provider Kagera
	if (*g_pwszProviderName && 
		!(wcscmp(g_pwszProviderName,L"Microsoft OLE DB Provider for ODBC Drivers")))
	{
		//For this property, do not request IReadData on the rowset.
		if (VerifyProperty(IDX_OTHERUPDATEDELETE,FALSE,1,rgImpPrpt))
			return TEST_PASS;
		else
			return TEST_FAIL;
	}
	else
	{
		//For this property, do not request IReadData on the rowset, there is no
		//implied properties after execution.
		if (VerifyProperty(IDX_OTHERUPDATEDELETE,FALSE,0,NULL))
			return TEST_PASS;
		else
			return TEST_FAIL;
	}
}
// }}


// {{ TCW_VAR_PROTOTYPE(134)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OWNINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_134()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OWNINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(135)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_OWNUPDATEDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_135()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OWNUPDATEDELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(136)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_QUICKRESTART
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_136()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_QUICKRESTART,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(137)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_REENTRANTEVENTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_137()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REENTRANTEVENTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(138)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_REMOVEDELETED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_138()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REMOVEDELETED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(139)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_REPORTMULTIPLECHANGES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_139()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REPORTMULTIPLECHANGES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(140)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_RETURNPENDINGINSERTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_140()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_RETURNPENDINGINSERTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(141)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ROWRESTRICT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_141()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWRESTRICT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(142)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ROWSET_ASYNCH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_142()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWSET_ASYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(143)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_ROWTHREADMODEL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_143()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWTHREADMODEL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(144)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_SERVERCURSOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_144()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SERVERCURSOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(145)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_TRANSACTEDOBJECT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_145()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_TRANSACTEDOBJECT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(146)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_UPDATABILITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_146()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_UPDATABILITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(147)
//*-----------------------------------------------------------------------
// @mfunc set DBPROP_STRONGIDENTITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_147()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_STRONGIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(148)
//*-----------------------------------------------------------------------
// @mfunc set IID_IAccessor
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_148()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IACCESSOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(149)
//*-----------------------------------------------------------------------
// @mfunc set IID_IChapteredRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_149()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICHAPTEREDROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(150)
//*-----------------------------------------------------------------------
// @mfunc set IID_IColumnsInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_150()
{
	//For this property, request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICOLUMNSINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(151)
//*-----------------------------------------------------------------------
// @mfunc set IID_IColumnsRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_151()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICOLUMNSROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(152)
//*-----------------------------------------------------------------------
// @mfunc set IID_IConnectionPointContainer
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_152()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICONNECTIONPOINTCONTAINER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(153)
//*-----------------------------------------------------------------------
// @mfunc set IID_IConvertType
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_153()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICONVERTTYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(154)
//*-----------------------------------------------------------------------
// @mfunc set IID_IDBAsynchStatus
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_154()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IDBASYNCHSTATUS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(155)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_155()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(156)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetChange
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_156()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(157)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetFind
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_157()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETFIND,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(158)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetIdentity
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_158()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(159)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetIndex
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_159()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETINDEX,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(160)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_160()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(161)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetLocate
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_161()
{
	//If a rowset supports IRowsetLocate then the value of the DBPROP_BOOKMARKS 
	//and DBPROP_CANSCROLLBACKWARDS property is VARIANT_TRUE.
	ULONG	rgImpPrpt[2]={IDX_BOOKMARKS,IDX_CANSCROLLBACKWARDS};

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_IROWSETLOCATE,FALSE,2,rgImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(162)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetResynch
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_162()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETRESYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(163)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetScroll
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_163()
{
	//IRowsetScroll implies IRowsetLocate
	ULONG	uImpPrpt=IDX_IROWSETLOCATE;

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_IROWSETSCROLL,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(164)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetUpdate
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_164()
{
	//If DBPROP_IROWSETUPDATE is VARIANT_TRUE, then DBPROP_IROWSETCHANGE is
	//also set to VARIANT_TRUE.
	ULONG	rgImpPrpt[1]={IDX_IROWSETCHANGE};

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_IROWSETUPDATE,FALSE,1,rgImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(165)
//*-----------------------------------------------------------------------
// @mfunc set IID_IRowsetView
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_165()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETVIEW,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(166)
//*-----------------------------------------------------------------------
// @mfunc set IID_IViewChapter
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_166()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWCHAPTER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(167)
//*-----------------------------------------------------------------------
// @mfunc set IID_IViewFilter
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_167()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWFILTER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(168)
//*-----------------------------------------------------------------------
// @mfunc set IID_IViewRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_168()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(169)
//*-----------------------------------------------------------------------
// @mfunc set IID_IViewSort
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_169()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWSORT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(170)
//*-----------------------------------------------------------------------
// @mfunc set IID_ILockBytes
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_170()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ILOCKBYTES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(171)
//*-----------------------------------------------------------------------
// @mfunc set IID_ISequentialStream
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_171()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISEQUENTIALSTREAM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(172)
//*-----------------------------------------------------------------------
// @mfunc set IID_IStorage
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_172()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISTORAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(173)
//*-----------------------------------------------------------------------
// @mfunc set IID_IStream
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_173()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISTREAM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(174)
//*-----------------------------------------------------------------------
// @mfunc set IID_ISupportErrorInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SetProperties::Variation_174()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISUPPORTERRORINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SetProperties::Terminate()
{
	return (TCICMDPRPT_ChangeProperties::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_UnsetProperties)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_UnsetProperties - Unset all interface and rowset properties
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_UnsetProperties::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT_ChangeProperties::Init())
	// }}
	{
		return TRUE;
	}
	return FALSE;
}


//-------------------------------------------------------------------------------------
// @cmember Verify the attribute of the property
//
BOOL TCICMDPRPT_UnsetProperties::VerifyProperty
(ULONG cPrpt,			//@[in] The index to g_DBProperties array
BOOL fIReadData,		//@[in] Whether IReadData is requested
ULONG cImpPrpt,			//@[in] The count of implied properties
ULONG rgIDXPrpt[])		//@[in] The implied properties array
{
	switch (GetPrptAttr(cPrpt))
	{
		//No need to verify mandatory interface as it is verified in SetProperties
		case INTERFACE_MANDATORY:
				return TRUE;

		case INTERFACE_NOT_SUPPORTED:
				return(VerifyNotSupported(cPrpt,INTERFACE_NOT_SUPPORTED));

		case INTERFACE_SUPPORTED:
				return(VerifyInterfaceSupported(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,FALSE));

		case ROWSET_NOT_SUPPORTED:
				return(VerifyNotSupported(cPrpt,ROWSET_NOT_SUPPORTED));

		case ROWSET_NOT_SETTABLE:
				return(VerifyRowsetNotSettable(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,FALSE));

		case ROWSET_SETTABLE:
				return(VerifyRowsetSettable(cPrpt,fIReadData,cImpPrpt,rgIDXPrpt,FALSE));

		case PROPERTY_INVALID:
				odtLog<<wszIndexNotValid;
		default:
				return FALSE;
	}
}


//-------------------------------------------------------------------------------------
// @cmember: Verify the properties are not set
//
BOOL TCICMDPRPT_UnsetProperties::VerifyImpliedProperties
(
 ULONG cImpPrpt,		//@[in]: The count of implied properties
 ULONG rgIDXPrpt[]		//@[in]: The array of index to the implied properties
)
{
	DBPROPIDSET			pPropertyIDSets;
	DBPROPID			rgPropertyIDs;
	ULONG				cPrpt = 0;
	DBPROPSET			*pDBPrpts=NULL;
	ULONG				cLoop;
	BOOL				fTest=FALSE;

	for(cLoop=0;cLoop<cImpPrpt;cLoop++)
	{
		assert(rgIDXPrpt[cLoop]<=(ULONG)IDX_INTERFACE_END);

		//No need to check interface properties
		if(rgIDXPrpt[cLoop]>=(ULONG)IDX_INTERFACE_START)
			continue;

		pPropertyIDSets.guidPropertySet=*(g_rgDBProperties[rgIDXPrpt[cLoop]].pGuidPropertySet);
		pPropertyIDSets.cPropertyIDs=1;
		rgPropertyIDs=g_rgDBProperties[rgIDXPrpt[cLoop]].dwPropertyID;
   		pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

		//Call GetProperties to verify the property is set
		if(!CHECK(m_pIRowsetInfo->GetProperties(1,&pPropertyIDSets,
												&cPrpt,&pDBPrpts),S_OK))
			goto END;

		if(!COMPARE(V_BOOL(&pDBPrpts->rgProperties->vValue), VARIANT_FALSE))
			goto END;

		//Free memory from GetProperties
		FreeProperties(&cPrpt,&pDBPrpts);

		//Call GetProperties to verify the implied property is not visible
		if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
														&cPrpt,&pDBPrpts),S_OK))
			goto END;

		if(!COMPARE(V_BOOL(&pDBPrpts->rgProperties->vValue), VARIANT_FALSE))
			goto END;

		//Free memory from GetProperties
		FreeProperties(&cPrpt,&pDBPrpts);
	}

	//Mark that success 
	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest && (cLoop==cImpPrpt))
		return TRUE;
	else
		return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_ABORTPRESERVE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_1()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ABORTPRESERVE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_APPENDONLY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_2()
{
	//For this property, do not request IReadData on the rowset
	if (VerifyProperty(IDX_APPENDONLY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_BLOCKINGSTORAGEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_3()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BLOCKINGSTORAGEOBJECTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_BOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_4()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_BOOKMARKSKIPPED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_5()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKSKIPPED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_BOOKMARKTYPE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_6()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_BOOKMARKTYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_CACHEDEFERRED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_7()
{
	//Setting the value of the DBPROP_CACHEDEFERRED property to VARIANT_TRUE
	//implicitly sets the value of DBPROP_DEFERRED property to VARIANT_TRUE.
	ULONG	uImpPrpt=IDX_DEFERRED;

	//For this property, do not request IReadData on the rowset
	if (VerifyProperty(IDX_CACHEDEFERRED,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_CANFETCHBACKWARDS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_8()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANFETCHBACKWARDS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_CANHOLDROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_9()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANHOLDROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_CANSCROLLBACKWARDS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_10()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CANSCROLLBACKWARDS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_CHANGEINSERTEDROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_11()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_CHANGEINSERTEDROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_COLUMNRESTRICT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_12()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COLUMNRESTRICT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(13)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_COMMANDTIMEOUT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_13()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COMMANDTIMEOUT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(14)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_COMMITPRESERVE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_14()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_COMMITPRESERVE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(15)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_DEFERRED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_15()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if(!VerifyProperty(IDX_DEFERRED,FALSE,0,NULL))
		return TEST_FAIL;
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(16)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_DELAYSTORAGEOBJECTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_16()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_DELAYSTORAGEOBJECTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(17)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_IMMOBILEROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_17()
{
	//This property can be VARIANT_TRUE only if DBPROP_OWNINSERT is VARIANT_TRUE.

	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IMMOBILEROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(18)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_LITERALBOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_18()
{
	//DBPROP_LITERALBOOKMARKS implies DBPROP_BOOKMARKS.
	ULONG	uImpPrpt=IDX_BOOKMARKS; 

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_LITERALBOOKMARKS,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(19)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_LITERALIDENTITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_19()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_LITERALIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(20)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_FILTERCOMPAREOPS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_20()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_FILTERCOMPAREOPS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(21)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_FINDCOMPAREOPS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_21()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_FINDCOMPAREOPS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(22)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_MAXOPENROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_22()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXOPENROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(23)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_MAXPENDINGROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_23()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXPENDINGROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(24)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_MAXROWS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_24()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MAXROWS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(25)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_MAYWRITECOLUMN
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_25()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (!VerifyProperty(IDX_MAYWRITECOLUMN,FALSE,0,NULL))
		return TEST_FAIL;
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(26)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_MEMORYUSAGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_26()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_MEMORYUSAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(27)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFICATIONPHASES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_27()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFICATIONPHASES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(28)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYCOLUMNSET
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_28()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYCOLUMNSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(29)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_29()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWDELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(30)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWFIRSTCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_30()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWFIRSTCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(31)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_31()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(32)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWRESYNCH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_32()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWRESYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(33)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWSETRELEASE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_33()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWSETRELEASE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(34)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_34()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWSETFETCHPOSITIONCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(35)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWUNDOCHANGE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_35()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDOCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(36)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWUNDODELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_36()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDODELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(37)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWUNDOINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_37()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUNDOINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(38)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_NOTIFYROWUPDATE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_38()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_NOTIFYROWUPDATE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(39)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_ORDEREDBOOKMARKS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_39()
{
	//DBPROP_ORDEREDBOOKMARKS implys DBPROP_BOOKMARKS.
	ULONG	uImpPrpt=IDX_BOOKMARKS; 

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_ORDEREDBOOKMARKS,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(40)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_OTHERINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_40()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OTHERINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(41)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_OTHERUPDATEDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_41()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OTHERUPDATEDELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(42)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_OWNINSERT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_42()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OWNINSERT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(43)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_OWNUPDATEDELETE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_43()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_OWNUPDATEDELETE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(44)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_QUICKRESTART
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_44()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_QUICKRESTART,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(45)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_REENTRANTEVENTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_45()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REENTRANTEVENTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(46)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_REMOVEDELETED
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_46()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REMOVEDELETED,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(47)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_REPORTMULTIPLECHANGES
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_47()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_REPORTMULTIPLECHANGES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(48)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_RETURNPENDINGINSERTS
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_48()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_RETURNPENDINGINSERTS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(49)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_ROWRESTRICT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_49()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWRESTRICT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(50)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_ROWSET_ASYNCH
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_50()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWSET_ASYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(51)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_ROWTHREADMODEL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_51()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ROWTHREADMODEL,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(52)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_SERVERCURSOR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_52()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_SERVERCURSOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(53)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_TRANSACTEDOBJECT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_53()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_TRANSACTEDOBJECT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(54)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_UPDATABILITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_54()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_UPDATABILITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(55)
//*-----------------------------------------------------------------------
// @mfunc unset DBPROP_STRONGIDENTITY
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_55()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_STRONGIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(56)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IAccessor
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_56()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IACCESSOR,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(57)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IChapteredRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_57()
{
	//For this property, request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICHAPTEREDROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(58)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IColumnsInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_58()
{
	//For this property, request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICOLUMNSINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(59)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IColumnsRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_59()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICOLUMNSROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(60)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IConnectionPointContainer
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_60()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICONNECTIONPOINTCONTAINER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(61)
//*-----------------------------------------------------------------------
// @mfunc set IID_IConvertType
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_61()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ICONVERTTYPE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(62)
//*-----------------------------------------------------------------------
// @mfunc set IID_IDBAsynchStatus
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_62()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IDBASYNCHSTATUS,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(63)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_63()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(64)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetChange
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_64()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETCHANGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(65)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetIdentity
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_65()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETIDENTITY,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(66)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetIndex
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_66()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETINDEX,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(67)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_67()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(68)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetLocate
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_68()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETLOCATE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(69)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetResynch
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_69()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETRESYNCH,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(70)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetScroll
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_70()
{
	//IRowsetScroll implies IRowsetLocate
	ULONG	uImpPrpt=IDX_IROWSETLOCATE;

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_IROWSETSCROLL,FALSE,1,&uImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(71)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetUpdate
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_71()
{
	//If DBPROP_IROWSETUPDATE is VARIANT_TRUE, then DBPROP_IROWSETCHANGE is
	//also set to VARIANT_TRUE.
	ULONG	rgImpPrpt[1]={IDX_IROWSETCHANGE};

	//For this property, do not request IReadData on the rowset.
	if (VerifyProperty(IDX_IROWSETUPDATE,FALSE,1,rgImpPrpt))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(72)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IRowsetView
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_72()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IROWSETVIEW,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(73)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IViewChapter
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_73()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWCHAPTER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(74)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IViewFilter
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_74()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWFILTER,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(75)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IViewRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_75()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWROWSET,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(76)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IViewSort
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_76()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_IVIEWSORT,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(77)
//*-----------------------------------------------------------------------
// @mfunc unset IID_ILockBytes
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_77()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ILOCKBYTES,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(78)
//*-----------------------------------------------------------------------
// @mfunc unset IID_ISequentialStream
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_78()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISEQUENTIALSTREAM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(79)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IStorage
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_79()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISTORAGE,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(80)
//*-----------------------------------------------------------------------
// @mfunc unset IID_IStream
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_80()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISTREAM,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(81)
//*-----------------------------------------------------------------------
// @mfunc unset IID_ISupportErrorInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_UnsetProperties::Variation_81()
{
	//For this property, do not request IReadData on the rowset, there is no
	//implied properties after execution.
	if (VerifyProperty(IDX_ISUPPORTERRORINFO,FALSE,0,NULL))
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_UnsetProperties::Terminate()
{
	return (TCICMDPRPT_ChangeProperties::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Boundary_Set)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Boundary_Set - Boundary conditions for SetProperties
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Boundary_Set::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{
		return TRUE;
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc cPropertySets=0, SetProperties does not do anything
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_1()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//Set property value to 0
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	//Set value=1  
	DBPrpt.vValue.lVal=1;
	//Call SetProperties with cPropertySets=0, verify SetProperties does not
	//do anything.  Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(0,&DBPrptSet),S_OK))
		return TEST_FAIL;

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//Call GetProperties to verify the property is set
	if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK))
		goto END;

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc cPropertySets=0 and rgPropertySets=NULL, SetProperties does not do anything
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_2()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXOPENROWS) ||
			!(g_rgDBProperties[IDX_MAXOPENROWS].fSettable))
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXOPENROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXOPENROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//Set property value to 0
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	//Call SetProperties with cPropertySets=0 and rgPropertySets=NULL, verify
	//SetProperties does not do anything.  Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(0,NULL),S_OK))
		return TEST_FAIL;

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXOPENROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//Call GetProperties to verify the property is set
	if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK))
		goto END;

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc cPropertySets>0 and rgPropertySets=NULL, E_INVALIDARG returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_3()
{
	if(!CHECK(m_pICommandProperties->SetProperties(1,NULL),E_INVALIDARG))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc cProperties=0, SetProperties does not do anything
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_4()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXPENDINGROWS) ||
			!(g_rgDBProperties[IDX_MAXPENDINGROWS].fSettable))
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXPENDINGROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXPENDINGROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//Set property value to 0
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	//Set value=1 and cProperties=0
	DBPrpt.vValue.lVal=1;
	DBPrptSet.cProperties=0;
	//Call SetProperties with cProperties=0, verify SetProperties does not
	//do anything.  Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXPENDINGROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//Call GetProperties to verify the property is set
	if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK))
		goto END;

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc cProperties=0 and rgProperties=NULL, SetProperties does not do anything
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_5()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	
	//Verify the property is supported
	if( !(g_rgDBProperties[IDX_MAXROWS].fSupported) ||
		(!(g_rgDBProperties[IDX_MAXROWS].fSettable) && 
		  (V_I4(&g_rgDBProperties[IDX_MAXROWS].vDefault))) )
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//Set property value to 0
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	//Set cProperties=0 and rgProperties=NULL
	DBPrptSet.cProperties=0;
   	DBPrptSet.rgProperties=NULL;
	//Call SetProperties with cProperties=0 and rgProperties=NULL, verify
	//SetProperties does not do anything.  Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//Call GetProperties to verify the property is set
	if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK))
		goto END;

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc cProperties>0 and rgProperties=NULL, E_INVALIDARG returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_6()
{
	DBPROPSET		DBPrptSet; 
	
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
   	DBPrptSet.rgProperties=NULL;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),E_INVALIDARG))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc cPropertySets=0 and rgPropertySets is invalid, return S_OK
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_7()
{
	if(CHECK(m_pICommandProperties->SetProperties(0,(DBPROPSET *)1), S_OK))
		return TEST_PASS;

	return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc cProperties=0 and guidPropertySet=invalid GUID, SetProperties does not do anything
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_8()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXROWS
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//Set property value to 0
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	//Set cProperties=0 and guidPropertySet=DBPROPSET_DATASOURCEINFO
	DBPrptSet.guidPropertySet=DBPROPSET_DATASOURCEINFO;
	DBPrptSet.cProperties=0;
	//Call SetProperties with cProperties=0 and guidPropertySet=
	//DBPROPSET_DATASOURCEINFO, verify SetProperties does not do anything.
	//Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		return TEST_FAIL;

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//Call GetProperties to verify the property is set
	if(!CHECK(m_pICommandProperties->GetProperties(1,&pPropertyIDSets,
													&cPrpt,&pDBPrpts),S_OK))
		goto END;

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_9()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_DATASOURCE;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_COMMANDTIMEOUT;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	//Property is not supported
	if(!COMPARE(DBPrptSet.rgProperties->dwStatus,DBPROPSTATUS_NOTSUPPORTED))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc guidPropertySet=invalid GUID and rgProperties=NULL, E_INVALIDARG returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_10()
{
	DBPROPSET		DBPrptSet; 
	
	DBPrptSet.guidPropertySet=DBPROPSET_DATASOURCE;
	DBPrptSet.cProperties=1;
   	DBPrptSet.rgProperties=NULL;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),E_INVALIDARG))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc Open a rowset and try to set a property, DB_E_OBJECTOPEN returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_11()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	BOOL			fTest=FALSE;
	
	//Open a rowset
	if(!OpenRowset())
		goto END;

	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_COMMANDTIMEOUT;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),DB_E_OBJECTOPEN))
		goto END;

	fTest=TRUE;

END:	
	ReleaseRowset();

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc Set a good Propset and 0, NULL Propsets
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_12()
{
	DBPROPSET		DBPrptSet[3]; 
	DBPROP			DBPrpt;
	BOOL			fTest=FALSE;
	
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrpt.dwPropertyID=DBPROP_IRowsetResynch;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;

	DBPrptSet[0].guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet[0].cProperties=1;
   	DBPrptSet[0].rgProperties=&DBPrpt;

	DBPrptSet[1].guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet[1].cProperties=0;
   	DBPrptSet[1].rgProperties=NULL;

	DBPrptSet[2].guidPropertySet=DBPROPSET_DBINIT;
	DBPrptSet[2].cProperties=0;
   	DBPrptSet[2].rgProperties=NULL;

	if(!CHECK(m_pICommandProperties->SetProperties(2,DBPrptSet),DB_E_ERRORSOCCURRED))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(2,DBPrptSet),DB_E_ERRORSOCCURRED))
		goto END;

	fTest=TRUE;

END:	
	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(13)
//*-----------------------------------------------------------------------
// @mfunc Set a 0, NULL Propsets with a DBINIT Propset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Set::Variation_13()
{
	DBPROPSET		DBPrptSet[3]; 
	DBPROP			DBPrpt;
	BOOL			fTest=FALSE;
	
	memset(&DBPrpt ,0,sizeof(DBPROP));
	DBPrpt.dwPropertyID=DBPROP_IRowsetResynch;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;

	DBPrptSet[0].guidPropertySet=DBPROPSET_SESSION;
	DBPrptSet[0].cProperties=0;
   	DBPrptSet[0].rgProperties=NULL;

	DBPrptSet[1].guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet[1].cProperties=0;
   	DBPrptSet[1].rgProperties=NULL;

	DBPrptSet[2].guidPropertySet=DBPROPSET_DBINIT;
	DBPrptSet[0].cProperties=1;
   	DBPrptSet[0].rgProperties=&DBPrpt;

	if(!CHECK(m_pICommandProperties->SetProperties(2,DBPrptSet),DB_E_ERRORSOCCURRED))
		goto END;

	if(!CHECK(m_pICommandProperties->SetProperties(2,DBPrptSet),DB_E_ERRORSOCCURRED))
		goto END;

	fTest=TRUE;

END:	
	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Boundary_Set::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Boundary_Get)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Boundary_Get - Boundary conditions for GetProperties
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Boundary_Get::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{
		// TO DO:  Add your own code here
		return TRUE;
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc cPropertyIDSets>0, rgPropertyIDSets=NULL, return E_INVALIDARG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_1()
{
	ULONG		cPropertySets	= 0;
	DBPROPSET	*pPropertySets	= NULL;
	
	if(!CHECK(m_pICommandProperties->GetProperties(1,NULL,
				&cPropertySets,&pPropertySets), E_INVALIDARG))
		return TEST_FAIL;

	//When an error occurs *pcPropertySets is set to 0
	if(!COMPARE(cPropertySets, 0))
		return TEST_FAIL;

	//When an error occurs *prgPropertySets is a null pointer
	if(!COMPARE(pPropertySets, NULL))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc cPropertyIDs>0, rgPropertyIDs=NULL, return E_INVALIDARG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_2()
{
	DBPROPIDSET		rgPropertyIDSets; 
	ULONG			cPropertySets=0;
	DBPROPSET		*prgPropertySets=NULL;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
   	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), E_INVALIDARG))
		return TEST_FAIL;

	//When an error occurs *pcPropertySets is set to 0
	if(!COMPARE(cPropertySets, 0))
		return TEST_FAIL;

	//When an error occurs *prgPropertySets is a null pointer
	if(!COMPARE(prgPropertySets, NULL))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc pcPropertySets=NULL, return E_INVALIDARG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_3()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_IRowset;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				NULL,&prgPropertySets), E_INVALIDARG))
		return TEST_FAIL;

	//When an error occurs *prgPropertySets is a null pointer
	if(!COMPARE(prgPropertySets, NULL))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc prgPropertySets=NULL, return E_INVALIDARG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_4()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	ULONG			cPropertySets=0;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_IRowset;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,NULL), E_INVALIDARG))
		return TEST_FAIL;

	//When an error occurs *pcPropertySets is set to 0
	if(!COMPARE(cPropertySets, 0))
		return TEST_FAIL;

	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc cPropertyIDSets>0, rgPropertyIDSets=NULL, pcPropertySets=NULL, prgPropertySets=NULL, E_INVALIDARG
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_5()
{
	if(CHECK(m_pICommandProperties->GetProperties(1,NULL, 
				NULL,NULL), E_INVALIDARG) )
		return TEST_PASS;

	return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc guidPropertySet=invalid GUID, DB_E_ERRORSOCCURRED returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_6()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_COLUMN;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_ABORTPRESERVE;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	//Property is not supported
	if(!COMPARE(prgPropertySets->rgProperties->dwStatus,DBPROPSTATUS_NOTSUPPORTED))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc rgPropertyIDs=invalid DBPROPID, DB_E_ERRORSOCCURRED returned
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_7()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_AUTH_USERID;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	//Property is not supported
	if(!COMPARE(prgPropertySets->rgProperties->dwStatus,DBPROPSTATUS_NOTSUPPORTED))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}

  
// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc DBPROPSET_ROWSET with 0, NULL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_8()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		return TEST_FAIL;

	//Count should be 1
	if(!COMPARE(cPropertySets,1))
		goto END;

	//Compare the property count
	if(!COMPARE(g_ulPropertyCount,prgPropertySets[0].cProperties))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc DBPROPSET_ROWSET with 0, NULL twice
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_9()
{
	DBPROPIDSET		rgPropertyIDSets[2]; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	
	rgPropertyIDSets[0].guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets[0].cPropertyIDs=0;
	rgPropertyIDSets[0].rgPropertyIDs=NULL;
	rgPropertyIDSets[1].guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets[1].cPropertyIDs=0;
	rgPropertyIDSets[1].rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(2,rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		return TEST_FAIL;

	//Count should be 2
	if(!COMPARE(cPropertySets,2))
		goto END;

	//Compare the property count
	if(!COMPARE(g_ulPropertyCount,prgPropertySets[0].cProperties))
		goto END;

	//Compare the property count
	if(!COMPARE(g_ulPropertyCount,prgPropertySets[1].cProperties))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc DBPROPSET_ROWSET with 0, NULL and a single property
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Boundary_Get::Variation_10()
{
	DBPROPIDSET		rgPropertyIDSets[2]; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	DBPROPSTATUS	dbPropStatus = DBPROPSTATUS_OK;
	
	m_hr = S_OK;
	rgPropertyIDs=DBPROP_LITERALIDENTITY;

	rgPropertyIDSets[0].guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets[0].cPropertyIDs=0;
	rgPropertyIDSets[0].rgPropertyIDs=NULL;
	rgPropertyIDSets[1].guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets[1].cPropertyIDs=1;
	rgPropertyIDSets[1].rgPropertyIDs=&rgPropertyIDs;

	// Figure out RETURNCODE
	if(!g_rgDBProperties[IDX_LITERALIDENTITY].fSupported)
	{
		m_hr = DB_S_ERRORSOCCURRED;
		dbPropStatus = DBPROPSTATUS_NOTSUPPORTED;
	}

	if(!CHECK(m_pICommandProperties->GetProperties(2,rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), m_hr))
		return TEST_FAIL;

	//Count should be 2
	if(!COMPARE(cPropertySets, 2))
		goto END;

	//Compare the property count
	if(!COMPARE(g_ulPropertyCount, prgPropertySets[0].cProperties))
		goto END;

	//Compare the property count
	if(!COMPARE(1, prgPropertySets[1].cProperties))
		goto END;

	//Compare the property count
	if(!COMPARE(dbPropStatus, prgPropertySets[1].rgProperties->dwStatus))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// }}
// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Boundary_Get::Terminate()
{
	return (TCICMDPRPT::Terminate());

}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Parameters)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Parameters - test parameters
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Parameters::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{
		m_DBPrpt.rgProperties=&m_DBProp;
		return TRUE;
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc Set MAXROWS to 0
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_1()
{
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=0;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),S_OK))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK));
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc Set MAXROWS to -1
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_2()
{
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=-1;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	if(!COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_BADVALUE))
		return TEST_FAIL;

	m_DBProp.vValue.vt=VT_I8;
	m_DBProp.vValue.lVal=0;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	if(!COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_BADVALUE))
		return TEST_FAIL;
	else
		return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc Set MaxOpenRows to 0
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_3()
{
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXOPENROWS) ||
			!(g_rgDBProperties[IDX_MAXOPENROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXOPENROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=0;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),S_OK))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK));
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc Set MaxOpenRows to -1
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_4()
{
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXOPENROWS) ||
			!(g_rgDBProperties[IDX_MAXOPENROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXOPENROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=-1;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	if(!COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_BADVALUE))
		return TEST_FAIL;

	m_DBProp.vValue.vt=VT_BOOL;
	m_DBProp.vValue.lVal=0;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	if(!COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_BADVALUE))
		return TEST_FAIL;
	else
		return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc Set MAXROWS to 55
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_5()
{
	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=55;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),S_OK))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK));
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc Set MAXROWS to 99999999
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_6()
{
	ULONG		cRowsets=0;
	IUnknown	*pIUnknown=NULL;
	BOOL		fTest=FALSE;

	//Verify the property is supported
	if(!VerifySupported(IDX_MAXROWS) ||
			!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=99999999;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),S_OK))
		return TEST_FAIL;

	if(!COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK))
		return TEST_FAIL;

	if(!ReadyToExecute())
		return TEST_FAIL;

	if(CHECK(m_hr=m_pICommand->Execute(NULL,IID_IAccessor,NULL,NULL,
			(IUnknown **)&pIUnknown),S_OK))
		fTest=TRUE;

	if(SUCCEEDED(m_hr))
		SAFE_RELEASE(pIUnknown);

	CleanUpFromExecute();

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc Set DBPROPSET_PROPERTYIESINERROR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_7()
{	
	DBPROPSET		DBPrpt;
	DBPROP			rgDBProp;
	BOOL			fTest=FALSE;

	memset(&rgDBProp ,0,sizeof(DBPROP));
	DBPrpt.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	DBPrpt.cProperties=1;
   	DBPrpt.rgProperties=&rgDBProp;

	rgDBProp.dwPropertyID=DBPROP_IRowset;
	rgDBProp.vValue.vt=VT_EMPTY;
	rgDBProp.dwOptions=DBPROPOPTIONS_REQUIRED;

	//Try to set the property
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrpt),DB_E_ERRORSOCCURRED))
		goto END;

	//See what information is returned
	COMPARE(rgDBProp.dwStatus,DBPROPSTATUS_NOTSUPPORTED);

	fTest=TRUE;

END:
	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc Set by ICommand::Execute
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_8()
{
	IUnknown		*pIUnknown=NULL;
	IRowsetInfo		*pIRowsetInfo=NULL;
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fPass=FALSE;

	//Get a new command object, start from scratch
	if(!ResetProperties())
		return TEST_FAIL;
	
	if(!ReadyToExecute())
		return TEST_FAIL;

	//Ask for second property upon Execute
	if(!CHECK(m_hr=m_pICommand->Execute(NULL,IID_IRowsetIdentity,NULL,NULL,
				&pIUnknown),S_OK))
		goto END;

	//Make sure IRowsetInfo returns
	if(!CHECK(pIUnknown->QueryInterface(IID_IRowsetInfo,(LPVOID *)&pIRowsetInfo),S_OK))
		goto END;

	//Check the value of IRowsetIdentity
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_IRowsetIdentity;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(pIRowsetInfo->GetProperties(1,&rgPropertyIDSets,&cPropertySets,
			&prgPropertySets),S_OK))
		goto END;

	if(COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_TRUE))
		fPass=TRUE;

END:

	//Release the objects
	SAFE_RELEASE(pIRowsetInfo);
	SAFE_RELEASE(pIUnknown);
	CleanUpFromExecute();

	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}		
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc SetCheap
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_9()
{
	//Find a property that is supported
	if(!VerifySupported(IDX_MAXROWS))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=0;
	m_DBProp.dwOptions=DBPROPOPTIONS_SETIFCHEAP;

	m_hr = m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt);

	if( m_hr == S_OK )
	{
		if(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK))
			return TEST_PASS;
	}

	if( m_hr == DB_S_ERRORSOCCURRED )
	{
		if(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_NOTSET))
			return TEST_PASS;
	}

	return(TEST_FAIL);
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc Set dwOptions to an invalid value. Return DBPROPSTATUS_BADOPTION
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_10()
{
	//Find a property that is supported
	if(!VerifySupported(IDX_MAXROWS))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=0;
	m_DBProp.dwOptions=99;		//Invalid option

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_E_ERRORSOCCURRED))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_BADOPTION));
}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc Set colid on a property that only supports all columns
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_11()
{
	DBID		colDBID;

	//Find a property that is supported
	if(!VerifySupported(IDX_MAXROWS))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwPropertyID=DBPROP_MAXROWS;
	m_DBProp.vValue.vt=VT_I4;
	m_DBProp.vValue.lVal=0;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;
	
	colDBID.eKind=DBKIND_NAME;
	colDBID.uName.pwszName=L"Bogus";
	m_DBProp.colid=colDBID;

	//Colid is ignored on properties that do not return
	//Column? designation from GetPropertyInfo for individual columns.
	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,&m_DBPrpt),S_OK))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,DBPROPSTATUS_OK));
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc Set an invalid colid on a property that supports colid
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_12()
{
	DBID			colDBID;
	DBPROPSTATUS	dbPropStatus = DBPROPSTATUS_OK;
	HRESULT			ExpHR		 = S_OK;

	//Check to see if the property is supported
	if(!SupportedProperty(DBPROP_TRANSACTEDOBJECT, DBPROPSET_ROWSET, m_pThisTestModule->m_pIUnknown))
		return TEST_SKIPPED;

	// Get the Column Flag
	if(GetPropInfoFlags(DBPROP_TRANSACTEDOBJECT, DBPROPSET_ROWSET, 
		m_pThisTestModule->m_pIUnknown, DATASOURCE_INTERFACE) & DBPROPFLAGS_COLUMNOK) 
	{
		dbPropStatus = DBPROPSTATUS_BADCOLUMN;
		ExpHR = DB_E_ERRORSOCCURRED;
	}

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=1;
	m_DBProp.dwOptions=DBPROPOPTIONS_REQUIRED;
	m_DBProp.dwPropertyID=DBPROP_TRANSACTEDOBJECT;
	m_DBProp.vValue.vt=VT_EMPTY;
	
	colDBID.eKind=99;	//Invalid DBKINDENUM
	m_DBProp.colid=colDBID;

	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,&m_DBPrpt), ExpHR))
		return TEST_FAIL;

	return(COMPARE(m_DBProp.dwStatus,dbPropStatus));
}
// }}


// {{ TCW_VAR_PROTOTYPE(13)
//*-----------------------------------------------------------------------
// @mfunc Set DBPROP_APPENDONLY and DBPROP_OTHERINSERT to VARIANT_TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_13()
{
	DBPROP			rgDBProp[2];

	//Verify property is supported
	if( (!VerifySupported(IDX_APPENDONLY)) ||
		((!g_rgDBProperties[IDX_APPENDONLY].fSettable) &&
		 (V_BOOL(&g_rgDBProperties[IDX_APPENDONLY].vDefault) == VARIANT_FALSE)) )
		return TEST_SKIPPED;

	//Verify property is supported
	if(!VerifySupported(IDX_OTHERINSERT))
		return TEST_SKIPPED;

	m_cPrpt=1;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	m_DBPrpt.cProperties=2;
	m_DBPrpt.rgProperties=rgDBProp;
	
	rgDBProp[0].dwPropertyID=DBPROP_APPENDONLY;
	rgDBProp[0].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[0].vValue)=VARIANT_TRUE;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_OTHERINSERT;
	rgDBProp[1].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[1].vValue)=VARIANT_TRUE;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;
	
	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,
			&m_DBPrpt),DB_S_ERRORSOCCURRED))
		return TEST_FAIL;

	if(!COMPARE(rgDBProp[0].dwStatus,DBPROPSTATUS_OK))
		return TEST_FAIL;

	//Verify property is supported
	if( (!g_rgDBProperties[IDX_OTHERINSERT].fSettable) && 
		(!GetProperty(DBPROP_OTHERINSERT, DBPROPSET_ROWSET, m_pICommandProperties)) )
		COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_NOTSETTABLE);
	else
		COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_CONFLICTING);

	// Check to see if DBPROP_IRowsetChange is VARIANT_TRUE
	// Check to see if DBPROP_OWNINSERT is VARIANT_TRUE
	// Check to see if DBPROP_UPDATABILITY is DBPROPVAL_UP_INSERT
	// Check to see if DBPROP_OTHERINSERT is VARIANT_FALSE
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs[5];
	ULONG			cPropertySets=0;
	DBPROPSET		*prgPropertySets=NULL;

	rgPropertyIDs[0]=DBPROP_APPENDONLY;
	rgPropertyIDs[1]=DBPROP_IRowsetChange;
	rgPropertyIDs[2]=DBPROP_OWNINSERT;
	rgPropertyIDs[3]=DBPROP_UPDATABILITY;
	rgPropertyIDs[4]=DBPROP_OTHERINSERT;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs[0];
	rgPropertyIDSets.cPropertyIDs=5;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		return TEST_FAIL;

	// Check the values
	COMPARE(cPropertySets, 1);
	COMPARE(prgPropertySets->cProperties, 5);

	// Compare the Property values
	COMPARE(prgPropertySets->rgProperties[0].dwPropertyID, DBPROP_APPENDONLY);
	COMPARE(prgPropertySets->rgProperties[0].dwStatus, DBPROPSTATUS_OK);
	COMPARE(V_BOOL(&prgPropertySets->rgProperties[0].vValue), VARIANT_TRUE);

	COMPARE(prgPropertySets->rgProperties[1].dwPropertyID, DBPROP_IRowsetChange);
	COMPARE(prgPropertySets->rgProperties[1].dwStatus, DBPROPSTATUS_OK);
	COMPARE(V_BOOL(&prgPropertySets->rgProperties[1].vValue), VARIANT_TRUE);

	COMPARE(prgPropertySets->rgProperties[2].dwPropertyID, DBPROP_OWNINSERT);
	COMPARE(prgPropertySets->rgProperties[2].dwStatus, DBPROPSTATUS_OK);
	COMPARE(V_BOOL(&prgPropertySets->rgProperties[2].vValue), VARIANT_TRUE);

	COMPARE(prgPropertySets->rgProperties[3].dwPropertyID, DBPROP_UPDATABILITY);
	COMPARE(prgPropertySets->rgProperties[3].dwStatus, DBPROPSTATUS_OK);
	COMPARE(V_I4(&prgPropertySets->rgProperties[3].vValue) & DBPROPVAL_UP_INSERT, DBPROPVAL_UP_INSERT);

	COMPARE(prgPropertySets->rgProperties[4].dwPropertyID, DBPROP_OTHERINSERT);
	COMPARE(prgPropertySets->rgProperties[4].dwStatus, DBPROPSTATUS_OK);
	COMPARE(V_BOOL(&prgPropertySets->rgProperties[4].vValue), VARIANT_FALSE);

	FreeProperties(&cPropertySets,&prgPropertySets);
	return TEST_PASS;
}
// }}


// {{ TCW_VAR_PROTOTYPE(14)
//*-----------------------------------------------------------------------
// @mfunc Set the same property twice in one call to SetProperties
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_14()
{
	HRESULT			ExpHR=S_OK;
	DBPROPSTATUS	ExpStatus1=DBPROPSTATUS_OK;
	DBPROPSTATUS	ExpStatus2=DBPROPSTATUS_OK;
	DBPROP			rgDBProp[2];

	// Verify property is supported
	if(!VerifySupported(IDX_MAXROWS)){
		ExpHR=DB_E_ERRORSOCCURRED;
		ExpStatus1=DBPROPSTATUS_NOTSUPPORTED;
		ExpStatus2=DBPROPSTATUS_NOTSUPPORTED;
	}
	else if(!g_rgDBProperties[IDX_MAXROWS].fSettable)
	{
		ExpHR=DB_E_ERRORSOCCURRED;
		ExpStatus1=DBPROPSTATUS_NOTSETTABLE;
		ExpStatus2=DBPROPSTATUS_NOTSETTABLE;
		
		//If the default is 0 or 5 than DB_S_ERRORSOCCURRED
		if(V_I4(&g_rgDBProperties[IDX_MAXROWS].vDefault)==0)
		{
			ExpHR=DB_S_ERRORSOCCURRED;
			ExpStatus1=DBPROPSTATUS_OK;
		}
		if(V_I4(&g_rgDBProperties[IDX_MAXROWS].vDefault)==5)
		{
			ExpHR=DB_S_ERRORSOCCURRED;
			ExpStatus2=DBPROPSTATUS_OK;
		}
	}

	m_cPrpt=1;
	m_DBPrpt.cProperties=2;
	memset(&rgDBProp ,0, (sizeof(DBPROP)*2));
	m_DBPrpt.rgProperties=rgDBProp;
	m_DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	
	rgDBProp[0].dwPropertyID=DBPROP_MAXROWS;
	rgDBProp[0].vValue.vt=VT_I4;
	rgDBProp[0].vValue.lVal=0;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_MAXROWS;
	rgDBProp[1].vValue.vt=VT_I4;
	rgDBProp[1].vValue.lVal=5;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;
	
	if(!CHECK(m_pICommandProperties->SetProperties(m_cPrpt,&m_DBPrpt),ExpHR))
		return TEST_FAIL;

	if(!COMPARE(rgDBProp[0].dwStatus,ExpStatus1))
		return TEST_FAIL;

	return(COMPARE(rgDBProp[1].dwStatus,ExpStatus2));
}
// }}


// {{ TCW_VAR_PROTOTYPE(15)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_15()
{	
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_IRowset;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), E_INVALIDARG))
		goto END;

	if(cPropertySets || prgPropertySets)
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(16)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR with cPropertyIDs>0, rgPropertyIDs=NULL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_16()
{	
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), E_INVALIDARG))
		goto END;

	if(cPropertySets || prgPropertySets)
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(17)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR with rgPropertyIDs!=NULL
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_17()
{	
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDs=DBPROP_IRowset;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), E_INVALIDARG))
		goto END;

	if(cPropertySets || prgPropertySets)
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(18)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_ROWSET and DBPROPSET_PROPERTYIESINERROR
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_18()
{	
	DBPROPIDSET		rgPropertyIDSets[2]; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;

	rgPropertyIDSets[0].guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets[0].cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXOPENROWS;
	rgPropertyIDSets[0].rgPropertyIDs=&rgPropertyIDs;

	rgPropertyIDSets[1].guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets[1].cPropertyIDs=0;
	rgPropertyIDSets[1].rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(2,rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), E_INVALIDARG))
		goto END;

	if(cPropertySets || prgPropertySets)
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(19)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR after successful ICommand::Execute
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_19()
{	
	DBPROPSET		DBPrpt;
	DBPROP			rgDBProp[2];
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	
	//Go back to initial state
	if(!ResetProperties())
		return TEST_FAIL;

	//The two properies have to be supported
	if(!VerifySupported(IDX_IROWSETLOCATE) ||
			!VerifySupported(IDX_MAXROWS))
		return TEST_SKIPPED;

	memset(&rgDBProp ,0, (sizeof(DBPROP)*2));
	DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	DBPrpt.cProperties=2;
   	DBPrpt.rgProperties=rgDBProp;

	rgDBProp[0].dwPropertyID=DBPROP_MAXROWS;
	rgDBProp[0].vValue.vt=VT_I4;
	rgDBProp[0].vValue.lVal=0;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_IRowsetLocate;
	rgDBProp[1].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[1].vValue)=VARIANT_TRUE;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;

	//Try to set these properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrpt),S_OK))
		return TEST_FAIL;

	//Make sure the correct information is returned
	COMPARE(rgDBProp[0].dwStatus,DBPROPSTATUS_OK);
	COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_OK);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;

	//Can not check anything from GetProperties because the it is not a 
	//valid call since Execute succeeded.
	
	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);
	ReleaseRowset();

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(20)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR after ICommand::Execute fails
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_20()
{	
	DBPROPSET		DBPrpt;
	DBPROP			rgDBProp[2];
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	EQUERY			eSQLStmt=SELECT_COLLISTFROMTBL;
	
	//Go back to initial state
	if(!ResetProperties())
		return TEST_FAIL;

	//The two properies have to be supported
	if( (!VerifySupported(IDX_IROWSETLOCATE)) || 
		(!g_rgDBProperties[IDX_IROWSETLOCATE].fSettable) ||
		(!VerifySupported(IDX_BOOKMARKS)) || 
		(!g_rgDBProperties[IDX_BOOKMARKS].fSettable) )
		return TEST_SKIPPED;

	memset(&rgDBProp ,0, (sizeof(DBPROP)*2));
	DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	DBPrpt.cProperties=2;
   	DBPrpt.rgProperties=rgDBProp;

	rgDBProp[0].dwPropertyID=DBPROP_BOOKMARKS;
	rgDBProp[0].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[0].vValue)=VARIANT_TRUE;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_IRowsetLocate;
	rgDBProp[1].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[1].vValue)=VARIANT_FALSE;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;

	//Try to set these properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrpt),S_OK))
		return TEST_FAIL;

	//Make sure the correct information is returned
	COMPARE(rgDBProp[0].dwStatus,DBPROPSTATUS_OK);
	COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_OK);

	//Expect Execute to fail
	//Make sure a select statement has been set up
	if(!m_pICommandText)
		if(!ReadyToExecute(eSQLStmt))
			goto END;

	m_hr=m_pICommand->Execute(NULL,IID_IRowsetInfo,NULL,NULL,
		(IUnknown **)&m_pIRowsetInfo);

	if( m_hr != DB_S_ERRORSOCCURRED && m_hr != DB_E_ERRORSOCCURRED )
	{
		fTest=TRUE;
		goto END;
	}

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;

	//Guid should be DBPROPSET_ROWSET
	if(!COMPARE(prgPropertySets->guidPropertySet,DBPROPSET_ROWSET))
		goto END;

	//Only two properties were set
	if(prgPropertySets->cProperties > 2)
		goto END;

	//PropertyID should be one of the two properties set
	if((prgPropertySets->rgProperties[0].dwPropertyID != DBPROP_BOOKMARKS) &&
			(prgPropertySets->rgProperties[0].dwPropertyID != DBPROP_OWNUPDATEDELETE))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	ReleaseRowset();
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(21)
//*-----------------------------------------------------------------------
// @mfunc Get DBPROPSET_PROPERTYIESINERROR twice in a row
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_21()
{	
	DBPROPSET		DBPrpt;
	DBPROP			rgDBProp[2];
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets=0;
	BOOL			fTest=FALSE;
	EQUERY			eSQLStmt=SELECT_COLLISTFROMTBL;
	
	//Go back to initial state
	if(!ResetProperties())
		return TEST_FAIL;

	//The two properies have to be supported
	if( !VerifySupported(IDX_IROWSETLOCATE) ||
		!VerifySupported(IDX_MAXROWS))
		return TEST_SKIPPED;

	memset(&rgDBProp ,0, (sizeof(DBPROP)*2));
	DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	DBPrpt.cProperties=2;
   	DBPrpt.rgProperties=rgDBProp;

	rgDBProp[0].dwPropertyID=DBPROP_MAXROWS;
	rgDBProp[0].vValue.vt=VT_I4;
	rgDBProp[0].vValue.lVal=0;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_IRowsetLocate;
	rgDBProp[1].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[1].vValue)=VARIANT_TRUE;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;

	//Try to set these properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrpt),S_OK))
		return TEST_FAIL;

	//Make sure the correct information is returned
	COMPARE(rgDBProp[0].dwStatus,DBPROPSTATUS_OK);
	COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_OK);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;

	ReleaseRowset();

	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	//The two properies have to be supported
	if( !VerifySupported(IDX_BOOKMARKS) ||
		!VerifySupported(IDX_OWNUPDATEDELETE))
		return TEST_SKIPPED;

	DBPrpt.guidPropertySet=DBPROPSET_ROWSET;
	DBPrpt.cProperties=2;
   	DBPrpt.rgProperties=rgDBProp;

	rgDBProp[0].dwPropertyID=DBPROP_BOOKMARKS;
	rgDBProp[0].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[0].vValue)=VARIANT_TRUE;
	rgDBProp[0].dwOptions=DBPROPOPTIONS_REQUIRED;

	rgDBProp[1].dwPropertyID=DBPROP_OWNUPDATEDELETE;
	rgDBProp[1].vValue.vt=VT_BOOL;
	V_BOOL(&rgDBProp[1].vValue)=VARIANT_FALSE;
	rgDBProp[1].dwOptions=DBPROPOPTIONS_REQUIRED;

	//Try to set these properties
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrpt),S_OK))
		return TEST_FAIL;

	//Make sure the correct information is returned
	COMPARE(rgDBProp[0].dwStatus,DBPROPSTATUS_OK);
	COMPARE(rgDBProp[1].dwStatus,DBPROPSTATUS_OK);

	//Expect Execute to fail
	//Make sure a select statement has been set up
	if(!m_pICommandText)
		if(!ReadyToExecute(eSQLStmt))
			goto END;

	m_hr=m_pICommand->Execute(NULL,IID_IRowsetInfo,NULL,NULL,
		(IUnknown **)&m_pIRowsetInfo);

	if( m_hr != DB_S_ERRORSOCCURRED && m_hr != DB_E_ERRORSOCCURRED )
	{
		fTest=TRUE;
		goto END;
	}

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;

	//Guid should be DBPROPSET_ROWSET
	if(!COMPARE(prgPropertySets->guidPropertySet,DBPROPSET_ROWSET))
		goto END;

	//Only two properties were set
	if(prgPropertySets->cProperties > 2)
		goto END;

	//Check for 0, NULL
	if( (!prgPropertySets->cProperties) && (!prgPropertySets->rgProperties) )
	{
		fTest=TRUE;
		goto END;
	}

	//PropertyID should be one of the two properties set
	if((prgPropertySets->rgProperties[0].dwPropertyID != DBPROP_BOOKMARKS) &&
			(prgPropertySets->rgProperties[0].dwPropertyID != DBPROP_OWNUPDATEDELETE))
		goto END;

	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);
	ReleaseRowset();

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(22)
//*-----------------------------------------------------------------------
// @mfunc GetProperties with DBPROPSET_PROPERTYIESINERROR 
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Parameters::Variation_22()
{	
	DBPROPIDSET	rgPropertyIDSets; 
	DBPROPSET * prgPropertySets=NULL;
	ULONG		cPropertySets=0;
	BOOL		fTest=FALSE;
	
	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;

	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	rgPropertyIDSets.guidPropertySet=DBPROPSET_PROPERTIESINERROR;
	rgPropertyIDSets.cPropertyIDs=0;
	rgPropertyIDSets.rgPropertyIDs=NULL;

	if(!CHECK(m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), S_OK))
		goto END;


	fTest=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Parameters::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_SequenceBeforeRowset)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_SequenceBeforeRowset - sequence test before a rowset is open
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SequenceBeforeRowset::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT_ChangeProperties::Init())
	// }}
	{
		m_fGet=TRUE;
		m_fSet=TRUE;
		m_pDBPrpt=NULL;
		m_pDBPrptIDSet.cPropertyIDs=1;
		m_pDBPrptIDSet.guidPropertySet=DBPROPSET_ROWSET;
		m_pDBPrptIDSet.rgPropertyIDs=&m_pDBPrptID;	

		return TRUE;
	}
	return FALSE;
}
	
//--------------------------------------------------------------------
//	@mfunc: GetInterface 
//	QueryInterface on the command object for interface riid.  Return
//	TRUE if QueryInterface returns S_OK, otherwise return FALSE.
BOOL TCICMDPRPT_SequenceBeforeRowset::GetInterface(REFIID riid, BOOL fMandatory)
{
	m_hr=m_pICommandProperties->QueryInterface(riid, (LPVOID*)&m_pICommandInterface);

	if( m_hr == S_OK )
		return TRUE;

	if( m_hr == E_NOINTERFACE && fMandatory == FALSE )
		return TRUE;

	odtLog<<wszInterfaceUnexpectedErr;

	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc After IAccessor
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_1()
{
	BOOL	fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_IAccessor, FALSE))
		goto END;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc After IColumnsInfo
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_2()
{
	WCHAR	*pwchar;
	BOOL	fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_IColumnsInfo, TRUE))
		goto END;

	//Call a method on the interface
	m_hr=((IColumnsInfo *)m_pICommandInterface)->GetColumnInfo(NULL,NULL,&pwchar);

	if((m_hr != E_INVALIDARG) && (m_hr != DB_E_NOTPREPARED))
		CHECK(m_hr, E_INVALIDARG);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc After IColumnsRowset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_3()
{
	BOOL	fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_IColumnsRowset, FALSE))
		goto END;

	//IColumnsRowset is not supported
	if(!m_pICommandInterface)
		return TEST_SKIPPED;
	
	//Call a method on the interface
	m_hr=((IColumnsRowset *)m_pICommandInterface)->GetAvailableColumns(NULL,NULL);

	if((m_hr != E_INVALIDARG) && (m_hr != DB_E_NOTPREPARED))
		CHECK(m_hr, E_INVALIDARG);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc After ICommand
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_4()
{
	BOOL	fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_ICommand, FALSE))
		goto END;

	//ICommand is not supported
	if(!m_pICommandInterface)
		return TEST_SKIPPED;

	//Call a method on the interface
	CHECK(((ICommand *)m_pICommandInterface)->Cancel(),S_OK);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc After ICommandCost
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_5()
{

#if( OLEDBVER >= 0x0300 )

	//initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//get the interface pointer
	if(!GetInterface(IID_ICommandCost, &m_fGet, FALSE))
		goto END;

	//call a mothod on the interface
	CHECK(((ICommandCost *)m_pICommandInterface)->GetCostEstimate(NULL,NULL,NULL),E_INVALIDARG);

	m_guidProperty=IID_IRowset;

	//Call GetPorperties and SetProperties
	m_fGet=CHECK(m_pICommandProperties->GetProperties(NULL,1,
	&m_guidProperty, &m_cDBPrptGet, &m_pDBPrpt),S_OK);

	m_fSet=CHECK(m_pICommandProperties->SetProperties(NULL,m_cDBPrptGet,m_pDBPrpt,NULL),S_OK);

	PROVIDER_FREE(m_pDBPrpt);
	
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(m_fGet && m_fSet)
		return TEST_PASS;
	else
		return TEST_FAIL;

#else
	return TEST_PASS;
#endif

}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc After ICommandPrepare
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_6()
{
	BOOL			fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_ICommandPrepare, FALSE))
		goto END;
	
	//ICommandPrepare is not supported
	if(!m_pICommandInterface)
		return TEST_SKIPPED;

	//Call a method on the interface
	CHECK(((ICommandPrepare *)m_pICommandInterface)->Unprepare(),S_OK);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc After ICommandQuery
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_7()
{

#if( OLEDBVER >= 0x0300 )

	//initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//get the interface pointer
	if(!GetInterface(IID_IQuery, &m_fGet, FALSE))
		goto END;

	//call a mothod on the interface
	CHECK(((IQuery *)m_pICommandInterface)->GetCardinalityEstimate(NULL),E_INVALIDARG);

	m_guidProperty=IID_IRowset;

	//Call GetPorperties and SetProperties
	m_fGet=CHECK(m_pICommandProperties->GetProperties(NULL,1,
	&m_guidProperty, &m_cDBPrptGet, &m_pDBPrpt),S_OK);

	m_fSet=CHECK(m_pICommandProperties->SetProperties(NULL,m_cDBPrptGet,m_pDBPrpt,NULL),S_OK);

	PROVIDER_FREE(m_pDBPrpt);
	
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(m_fGet && m_fSet)
		return TEST_PASS;
	else
		return TEST_FAIL;

#else
	return TEST_PASS;
#endif

}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc After ICommandTree
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_8()
{

#if( OLEDBVER >= 0x0300 )

	//initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//get the interface pointer
	if(!GetInterface(IID_ICommandTree, TRUE))
		goto END;

	//call a mothod on the interface
	CHECK(((ICommandTree *)m_pICommandInterface)->GetCommandTree(NULL),E_INVALIDARG);

	m_guidProperty=IID_IRowset;

	//Call GetPorperties and SetProperties
	m_fGet=CHECK(m_pICommandProperties->GetProperties(NULL,1,
	&m_guidProperty, &m_cDBPrptGet, &m_pDBPrpt),S_OK);

	m_fSet=CHECK(m_pICommandProperties->SetProperties(NULL,m_cDBPrptGet,m_pDBPrpt,NULL),S_OK);

	PROVIDER_FREE(m_pDBPrpt);
	
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(m_fGet && m_fSet)
		return TEST_PASS;
	else
		return TEST_FAIL;

#else
	return TEST_PASS;
#endif

}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc After ICommandText
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_9()
{
	BOOL			fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_ICommandText, FALSE))
		goto END;

	//ICommandText is not supported
	if(!m_pICommandInterface)
		return TEST_SKIPPED;

	//Call a method on the interface
	CHECK(((ICommandText *)m_pICommandInterface)->GetCommandText(NULL,NULL),E_INVALIDARG);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc After ICommandValidate
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_10()
{

#if( OLEDBVER >= 0x0300 )

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//get the interface pointer
	if(!GetInterface(IID_ICommandValidate, FALSE))
		goto END;

	//Call a method on the interface
	CHECK(((ICommandValidate *)m_pICommandInterface)->ValidateSyntax(),E_FAIL);

	m_guidProperty=IID_IRowset;

	//Call GetPorperties and SetProperties
	m_fGet=CHECK(m_pICommandProperties->GetProperties(NULL,1,
	&m_guidProperty, &m_cDBPrptGet, &m_pDBPrpt),S_OK);

	m_fSet=CHECK(m_pICommandProperties->SetProperties(NULL,m_cDBPrptGet,m_pDBPrpt,NULL),S_OK);

	PROVIDER_FREE(m_pDBPrpt);
	
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(m_fGet && m_fSet)
		return TEST_PASS;
	else
		return TEST_FAIL;
#else
	return TEST_PASS;
#endif

}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc After ICommandWithParameters
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_11()
{
	BOOL			fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_ICommandWithParameters, FALSE))
		goto END;

	//ICommandWithParameters is not supported
	if(!m_pICommandInterface)
		return TEST_SKIPPED;

	//Call a method on the interface
	CHECK(((ICommandWithParameters *)m_pICommandInterface)->SetParameterInfo(0,NULL,NULL),S_OK);

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

END:
	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc After IQuery
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_12()
{

#if( OLEDBVER >= 0x0300 )

	//initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//get the interface pointer
	if(!GetInterface(IID_IQuery, FALSE))
		goto END;

	//call tha method on the interface
	CHECK(((IQuery *)m_pICommandInterface)->AddPostProcessing(NULL,FALSE),E_INVALIDARG);

	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;

#else
	return TEST_PASS;
#endif

}


// {{ TCW_VAR_PROTOTYPE(13)
//*-----------------------------------------------------------------------
// @mfunc After IPersistStream
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceBeforeRowset::Variation_13()
{
#if( OLEDBVER >= 0x0300 )

	BOOL	fPass=FALSE;

	//Initialization
	m_fSet=TRUE;
	m_fGet=TRUE;

	//Get the interface pointer
	if(!GetInterface(IID_IPersistStream, FALSE))
		goto END;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//The interface should always be supported
	if(!m_pIRowsetInfo || VerifyMandatoryInterfaces())
		fPass=TRUE;

	ReleaseRowset();

	//There should be only 2 interfaces on the command object, m_pICommand and
	//m_pICommandProperties
	SAFE_RELEASE(m_pICommandInterface);

END:
	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
#else
	return TEST_PASS;
#endif
}
// }}


// }}
// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SequenceBeforeRowset::Terminate()
{
	return (TCICMDPRPT_ChangeProperties::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_SequenceAfterRowset)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_SequenceAfterRowset - sequence test after a rowset is open
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SequenceAfterRowset::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{
		return (OpenRowset());
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc Call SetProperties after a rowset is open, DB_E_OPENOBJECT
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_SequenceAfterRowset::Variation_1()
{
	DBPROPSET	DBPrptSet;
	DBPROP		DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_IRowsetInfo;
	DBPrpt.vValue.vt=VT_BOOL;
	V_BOOL(&DBPrpt.vValue)=VARIANT_TRUE;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrptSet.rgProperties=&DBPrpt;

	return(CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),DB_E_OBJECTOPEN));
}

// }}
// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_SequenceAfterRowset::Terminate()
{
	ReleaseRowset();

	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Zombie)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Zombie - Test zombie state for command object
//|	Created:			09/21/95
//-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Zombie::Init()
{
	// Check to see if Transactions are usable
	if(!IsUsableInterface(SESSION_INTERFACE, IID_ITransactionLocal))
		return TEST_SKIPPED;

	// Initialize to a invalid pointer
	m_pITransactionLocal = INVALID(ITransactionLocal*);
	
	if(CTransaction::Init())
	{
		if( RegisterInterface(COMMAND_INTERFACE, IID_ICommandProperties) )
			return TRUE;
	}

	// Check to see if ITransaction is supported
    if(!m_pITransactionLocal)
		return TEST_SKIPPED;

    // Clear the bad pointer value
	if(m_pITransactionLocal == INVALID(ITransactionLocal*))
		m_pITransactionLocal = NULL;

	return FALSE;
}


//--------------------------------------------------------------------
//@cmember: Get a supported interface property
//
BOOL TCICMDPRPT_Zombie::InterfaceSupported(DBPROPID *dwPropertyID)
{
	ULONG cPrpt;

	for(cPrpt=IDX_INTERFACE_START;cPrpt<=(ULONG)IDX_INTERFACE_END;cPrpt++)
	{
		if((g_rgDBProperties[cPrpt].fSupported) && (g_rgDBProperties[cPrpt].fSettable))
		{
			*dwPropertyID = g_rgDBProperties[cPrpt].dwPropertyID;
			return TRUE;
		}
	}

	return FALSE;
}

  
// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Abort ICommandProperties::GetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_1()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	ULONG				pcPropertySets		= 0;
	DBPROPSET *			prgPropertySets		= NULL;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==TRUE
	if(!GetAbort(TRUE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->GetProperties(0,NULL,&pcPropertySets,&prgPropertySets), S_OK))
		fSuccess = TRUE;

END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	//Free memory from GetProperties
	FreeProperties(&pcPropertySets,&prgPropertySets);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Abort ICommandProperties::GetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_2()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	ULONG				pcPropertySets		= 0;
	DBPROPSET *			prgPropertySets		= NULL;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==FALSE
	if(!GetAbort(FALSE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->GetProperties(0,NULL,&pcPropertySets,&prgPropertySets), S_OK))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	//Free memory from GetProperties
	FreeProperties(&pcPropertySets,&prgPropertySets);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Commit ICommandProperties::GetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_3()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	ULONG				pcPropertySets		= 0;
	DBPROPSET *			prgPropertySets		= NULL;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==TRUE
	if(!GetCommit(TRUE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->GetProperties(0,NULL,&pcPropertySets,&prgPropertySets), S_OK))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	//Free memory from GetProperties
	FreeProperties(&pcPropertySets,&prgPropertySets);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Commit ICommandProperties::GetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_4()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	ULONG				pcPropertySets		= 0;
	DBPROPSET *			prgPropertySets		= NULL;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==FALSE
	if(!GetCommit(FALSE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->GetProperties(0,NULL,&pcPropertySets,&prgPropertySets), S_OK))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	// Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	// Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	//Free memory from GetProperties
	FreeProperties(&pcPropertySets,&prgPropertySets);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_5()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowsetInfo;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==TRUE
	if(!GetAbort(TRUE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Get a valid property
	if(CHECK(pICommandProperties->SetProperties(1, &DBPrptSet), DB_E_OBJECTOPEN))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(6)
//*-----------------------------------------------------------------------
// @mfunc DB_E_OBJECTOPEN - Abort ICommandProperties::SetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_6()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowsetInfo;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==FALSE
	if(!GetAbort(FALSE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Get a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), DB_E_OBJECTOPEN))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	// Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(7)
//*-----------------------------------------------------------------------
// @mfunc DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_7()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowsetInfo;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==TRUE
	if(!GetCommit(TRUE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), DB_E_OBJECTOPEN))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(8)
//*-----------------------------------------------------------------------
// @mfunc DB_E_OBJECTOPEN - Commit ICommandProperties::SetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_8()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowsetInfo;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if(!StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==FALSE
	if(!GetCommit(FALSE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	//Set a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), DB_E_OBJECTOPEN))
		fSuccess = TRUE;
END:
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(9)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Abort ICommandProperties::SetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_9()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowset;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==TRUE
	if(!GetAbort(TRUE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Release the Rowset Objects
	SAFE_RELEASE(m_pIRowset);
	SAFE_RELEASE(m_pIRowsetInfo);
	SAFE_RELEASE(m_pIAccessor);
	SAFE_RELEASE(m_pIColumnsInfo);

	//Set a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), S_OK))
		fSuccess = TRUE;
END:
	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(10)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Abort ICommandProperties::SetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_10()
{
	BOOL				fSuccess			= FALSE;	// Variation passed	or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowset;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Abort the transaction with fRetaining==FALSE
	if(!GetAbort(FALSE))
		goto END;

	//Test zombie
	if(!m_fAbortPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Release the Rowset Objects
	SAFE_RELEASE(m_pIRowset);
	SAFE_RELEASE(m_pIRowsetInfo);
	SAFE_RELEASE(m_pIAccessor);
	SAFE_RELEASE(m_pIColumnsInfo);

	//Get a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), S_OK))
		fSuccess = TRUE;
END:
	//Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(11)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Commit ICommandProperties::SetProperties with fRetaining=TRUE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_11()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowset;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==TRUE
	if(!GetCommit(TRUE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Release the Rowset Objects
	SAFE_RELEASE(m_pIRowset);
	SAFE_RELEASE(m_pIRowsetInfo);
	SAFE_RELEASE(m_pIAccessor);
	SAFE_RELEASE(m_pIColumnsInfo);

	// Set a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), S_OK))
		fSuccess = TRUE;
END:
	//Cleanup Transactions
	CleanUpTransaction(S_OK);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(12)
//*-----------------------------------------------------------------------
// @mfunc S_OK - Commit ICommandProperties::SetProperties with fRetaining=FALSE
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Zombie::Variation_12()
{
	BOOL				fSuccess			= FALSE;	//Variation passed or failed
	DBCOUNTITEM			cRowsObtained		= 0;
	HROW *				rghRows				= NULL;
	ICommandProperties*	pICommandProperties	= NULL;
	DBPROPSET			DBPrptSet;
	DBPROP				DBPrpt;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet	= DBPROPSET_ROWSET;
	DBPrptSet.cProperties		= 1;
	DBPrptSet.rgProperties		= &DBPrpt;

	DBPrpt.dwPropertyID		= DBPROP_IRowset;
	DBPrpt.vValue.vt		= VT_BOOL;
	V_BOOL(&DBPrpt.vValue)	= VARIANT_TRUE;
	DBPrpt.dwOptions		= DBPROPOPTIONS_REQUIRED;

	//Retrieve an Interface pointer to ICommandPrepare within a Transaction
	if( !StartTransaction(SELECT_ALLFROMTBL, 
			(IUnknown**)&pICommandProperties,0,NULL))
		goto END;

	//Commit the transaction with fRetaining==FALSE
	if(!GetCommit(FALSE))
		goto END;

	//Test zombie
	if(!m_fCommitPreserve)
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), E_UNEXPECTED);
	else
		CHECK(m_pIRowset->GetNextRows(0,0,1,&cRowsObtained,&rghRows), S_OK);
		
	// Release the row handle on the 1st rowset
	if (rghRows)
		CHECK(m_pIRowset->ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL),S_OK);

	PROVIDER_FREE(rghRows);

	//Release the Rowset Objects
	SAFE_RELEASE(m_pIRowset);
	SAFE_RELEASE(m_pIRowsetInfo);
	SAFE_RELEASE(m_pIAccessor);
	SAFE_RELEASE(m_pIColumnsInfo);

	//Set a valid property
	if(CHECK(pICommandProperties->SetProperties(1,&DBPrptSet), S_OK))
		fSuccess = TRUE;
END:
	//Cleanup Transactions
	CleanUpTransaction(XACT_E_NOTRANSACTION);

	//Release ICommandProperties
	SAFE_RELEASE(pICommandProperties);

	if(fSuccess)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_TERMINATE_METHOD
// }}
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//

BOOL TCICMDPRPT_Zombie::Terminate()
{
	return (CTransaction::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Stress)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Stress - Stress testing for memory leak
//|	Created:			09/21/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Stress::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{	
		return TRUE;
	}

	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc Free Memory for GetProperties, check for memory leak
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Stress::Variation_1()
{
	ULONG			cCall;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrptSet=NULL;

	for(cCall=0; cCall < STRESS_MAX_CALL; cCall++)
	{
		m_hr = m_pICommandProperties->GetProperties(0,0,&cPrpt,&pDBPrptSet);

		//Free memory from GetProperties
		FreeProperties(&cPrpt,&pDBPrptSet);

		if( m_hr != S_OK )
			return TEST_FAIL;
	}

	return TEST_PASS;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Stress::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_Sequence)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_Sequence - test calling sequence
//|	Created:			09/28/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Sequence::Init()
{
	// {{ TCW_INIT_BASECLASS_CHECK
	if(TCICMDPRPT::Init())
	// }}
	{	
		return TRUE;
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc Set, Unset, and Unset
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Sequence::Variation_1()
{
	HRESULT			ExphrFalse = S_OK;
	HRESULT			ExphrTrue  = S_OK;
	DBPROPSET		DBPrptSet;
	DBPROP			DBPrpt;
	DBPROPIDSET		DBPrptIDSet;
	DBPROPID		DBPrptID;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPrpt=0;
	BOOL			fPass=FALSE;

	if(!VerifySupported(IDX_ICOLUMNSROWSET))
		return TEST_SKIPPED;
	
	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_IColumnsRowset;
	DBPrpt.vValue.vt=VT_BOOL;
	V_BOOL(&DBPrpt.vValue)=VARIANT_TRUE;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrptSet.rgProperties=&DBPrpt;

	//Get the Property value
	if( (!g_rgDBProperties[IDX_ICOLUMNSROWSET].fSettable) &&
		(GetProperty(DBPROP_IColumnsRowset, DBPROPSET_ROWSET, m_pICommandProperties)) )
		ExphrFalse = DB_E_ERRORSOCCURRED;

	if( (!g_rgDBProperties[IDX_ICOLUMNSROWSET].fSettable) &&
		(!GetProperty(DBPROP_IColumnsRowset, DBPROPSET_ROWSET, m_pICommandProperties)) )
		ExphrTrue = DB_E_ERRORSOCCURRED;

	//Set
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrTrue)) 
		return TEST_FAIL;

	//Make sure DBPrpt is not altered by SetProperties
	if(!COMPARE(DBPrpt.dwPropertyID, DBPROP_IColumnsRowset))
		return TEST_FAIL;
	if(!COMPARE(DBPrpt.dwOptions,DBPROPOPTIONS_REQUIRED))
		return TEST_FAIL;
	if(!COMPARE(V_BOOL(&DBPrpt.vValue),VARIANT_TRUE))
		return TEST_FAIL;

	//Unset
	V_BOOL(&DBPrpt.vValue)=VARIANT_FALSE;
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrFalse)) 
		return TEST_FAIL;

	//Make sure DBPrpt is not altered SetProperties
	if(!COMPARE(DBPrpt.dwPropertyID, DBPROP_IColumnsRowset))
		return TEST_FAIL;
	if(!COMPARE(V_BOOL(&DBPrpt.vValue),VARIANT_FALSE))
		return TEST_FAIL;

	//Check the value of IRowsetInfo
	DBPrptIDSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptIDSet.cPropertyIDs=1;
	DBPrptID=DBPROP_IColumnsRowset;
	DBPrptIDSet.rgPropertyIDs=&DBPrptID;

	//Get the property
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPrptIDSet,
					&cPrpt,&prgPropertySets),S_OK)) 
		return TEST_FAIL;

	//Make sure the property is not set
	if(ExphrFalse == S_OK)
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_FALSE))
			goto END;
	}
	else
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;
	}

	//Free memory from GetProperties
	FreeProperties(&cPrpt,&prgPropertySets);

	//Unset
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrFalse)) 
		return TEST_FAIL;

	//Get the property
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPrptIDSet,
					&cPrpt,&prgPropertySets),S_OK)) 
		return TEST_FAIL;

	//Make sure the property is not set
	if(ExphrFalse == S_OK)
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_FALSE))
			goto END;
	}
	else
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;
	}

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&prgPropertySets);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc Unset, Set, Set
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Sequence::Variation_2()
{
	HRESULT			ExphrFalse = S_OK;
	HRESULT			ExphrTrue  = S_OK;
	DBPROPSET		DBPrptSet;
	DBPROP			DBPrpt;
	DBPROPIDSET		DBPrptIDSet;
	DBPROPID		DBPrptID;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPrpt=0;
	BOOL			fPass=FALSE;

	if(!VerifySupported(IDX_ICOLUMNSROWSET))
		return TEST_SKIPPED;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_IColumnsRowset;
	DBPrpt.vValue.vt=VT_BOOL;
	V_BOOL(&DBPrpt.vValue)=VARIANT_FALSE;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrptSet.rgProperties=&DBPrpt;

	//Get the Property value
	if( (!g_rgDBProperties[IDX_ICOLUMNSROWSET].fSettable) &&
		(GetProperty(DBPROP_IColumnsRowset, DBPROPSET_ROWSET, m_pICommandProperties)) )
		ExphrFalse = DB_E_ERRORSOCCURRED;

	if( (!g_rgDBProperties[IDX_ICOLUMNSROWSET].fSettable) &&
		(!GetProperty(DBPROP_IColumnsRowset, DBPROPSET_ROWSET, m_pICommandProperties)) )
		ExphrTrue = DB_E_ERRORSOCCURRED;

	//Unset
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrFalse)) 
		return TEST_FAIL;

	//Check the value of IRowsetInfo
	DBPrptIDSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptIDSet.cPropertyIDs=1;
	DBPrptID=DBPROP_IColumnsRowset;
	DBPrptIDSet.rgPropertyIDs=&DBPrptID;

	//Check the value of the property
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPrptIDSet,
					&cPrpt,&prgPropertySets),S_OK)) 
		return TEST_FAIL;

	//The property should not be set
	//Make sure the property is not set
	if(ExphrFalse == S_OK)
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_FALSE))
			goto END;
	}
	else
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;
	}

	//Free memory from GetProperties
	FreeProperties(&cPrpt,&prgPropertySets);

	//Set
	V_BOOL(&DBPrpt.vValue)=VARIANT_TRUE;
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrTrue)) 
		return TEST_FAIL;

	//Set
	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),ExphrTrue)) 
		return TEST_FAIL;

	//Get the property
	if(!CHECK(m_pICommandProperties->GetProperties(1,&DBPrptIDSet,
					&cPrpt,&prgPropertySets),S_OK)) 
		return TEST_FAIL;

	//Make sure the property is set
	if(ExphrTrue == S_OK)
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_TRUE))
			goto END;
	}
	else
	{
		if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue),VARIANT_FALSE))
			goto END;
	}

	fPass=TRUE;

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&prgPropertySets);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc Multiple rowset objects open on the same command object
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Sequence::Variation_3()
{
	DBPROPSET		DBPrptSet;
	DBPROP			DBPrpt;
	DBPROPIDSET		DBPrptIDSet;
	DBPROPID		DBPrptID;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPrpt=0;
	BOOL			fPass=FALSE;

	if(!VerifySupported(IDX_IROWSETIDENTITY))
		return TEST_SKIPPED;

	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_IRowsetIdentity;
	DBPrpt.vValue.vt=VT_BOOL;
	V_BOOL(&DBPrpt.vValue)=VARIANT_TRUE;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrptSet.rgProperties=&DBPrpt;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK)) 
		return TEST_FAIL;

	//Open a rowset
	if(!OpenRowset())
		goto END;

	//Release the rowset
	SAFE_RELEASE(m_pIRowsetInfo);
	
	//Open a second rowset
	if(!OpenRowset())
		goto END;

	//Release the rowset
	SAFE_RELEASE(m_pIRowsetInfo);
	
	//Open a third rowset
	if(!OpenRowset())
		goto END;

	//Check the value of IRowsetIdentity
	DBPrptIDSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptIDSet.cPropertyIDs=1;
	DBPrptID=DBPROP_IRowsetIdentity;
	DBPrptIDSet.rgPropertyIDs=&DBPrptID;

	//Check the rowset
	if(!CHECK(m_pIRowsetInfo->GetProperties(1,&DBPrptIDSet,&cPrpt,
				&prgPropertySets),S_OK))
		goto END;

	if(!COMPARE(V_BOOL(&prgPropertySets->rgProperties->vValue), VARIANT_TRUE))
		goto END;

	fPass=TRUE;
	
END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&prgPropertySets);
	ReleaseRowset();

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc Set IReadData, unset IReadData, call Execute(
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_Sequence::Variation_4()
{
#if( OLEDBVER >= 0x0300 )

	IRowset			**ppIRowset;
	ULONG			cRowset=0;
	DBPROPERTYSUPPORT	DBPrpt;

	//make sure the properties are all supported
	if(!VerifySupported(IDX_IREADDATA) || !VerifySupported(IDX_IROWSET))
		return TEST_SKIPPED;

	//set IReadData
	DBPrpt.guidProperty=IID_IReadData;
	DBPrpt.vValue.vt=VT_BOOL;
	DBPrpt.vValue.bool=VARIANT_TRUE;
	DBPrpt.dwOptions=0;
	
	if(!CHECK(m_pICommandProperties->SetProperties(NULL,1,&DBPrpt,NULL),S_OK))
		return TEST_FAIL;

	//unset IReadData
	DBPrpt.vValue.bool=VARIANT_FALSE;
	
	if(!CHECK(m_pICommandProperties->SetProperties(NULL,1,&DBPrpt,NULL),S_OK))
		return TEST_FAIL;

	//set up for execute
	if(!ReadyToExecute())
		return TEST_FAIL;

	//ask for IRowset unpon Execute
	if(!CHECK(m_pICommand->Execute(NULL,IID_IRowset,NULL,NULL,FALSE,&cRowset,
				(IUnknown ***)&ppIRowset,NULL),S_OK))
	{
		CleanUpFromExecute();
		return TEST_FAIL;
	}

	//call a method on the IRowset pointer
	COMPARE(cRowset, 1);
	(*ppIRowset)->RestartPosition(NULL);
	SAFE_RELEASE((*ppIRowset));

	CleanUpFromExecute();

	return TEST_PASS;
#else
	return TEST_PASS;
#endif
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_Sequence::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCICMDPRPT_KAGERA)
//*-----------------------------------------------------------------------
//|	Test Case:		TCICMDPRPT_KAGERA - Kagera specific test case
//|	Created:			09/29/95
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_KAGERA::Init()
{
	if(TCICMDPRPT::Init())
	// }}
	{	
		return TRUE;
	}
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc A table without index only has forward only behavior
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCICMDPRPT_KAGERA::Variation_1()
{	
	DBPROPSET		DBPrptSet;
	DBPROP			DBPrpt;
	BOOL			fPass=FALSE;
	IRowset			*pIRowset;

	if(!VerifySupported(IDX_IROWSETCHANGE))
		return TEST_SKIPPED;

	//Start from scratch
	if(!ResetProperties())
		return TEST_FAIL;

	//Print out a message that this test variation is for SQL Server only
	odtLog<<wszSQLServerOnly;

	//Drop the index on the table
	if(!SUCCEEDED(g_pCTable->DropIndex()))
		odtLog<<L"The Drop Index failed\n";

	//Set command property IRowsetChange 
	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_IRowsetChange;
	DBPrpt.vValue.vt=VT_BOOL;
	V_BOOL(&DBPrpt.vValue)=VARIANT_TRUE;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrptSet.rgProperties=&DBPrpt;

	if(!CHECK(m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		goto END;

	if(!ReadyToExecute())
		goto END;

	//Execute the select statement
	CHECK(m_hr=m_pICommand->Execute(NULL,IID_IRowset,NULL,NULL,
			(IUnknown **)&pIRowset),S_OK);

	//Release the rowset object
	if(SUCCEEDED(m_hr)) {
		SAFE_RELEASE(pIRowset);
	}
	else
		goto END;

	fPass=TRUE;

END:
	CleanUpFromExecute();

	//Create an index on the first column of the table
	g_pCTable->CreateIndex(1);

	if(fPass)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCICMDPRPT_KAGERA::Terminate()
{
	return (TCICMDPRPT::Terminate());
}
// }}
// }}


// {{ TCW_TC_PROTOTYPE(TCExtendedErrors)
//*-----------------------------------------------------------------------
//|	Test Case:		TCExtendedErrors - Extended Errors
//|	Created:			07/30/96
//*-----------------------------------------------------------------------

//--------------------------------------------------------------------
// @mfunc TestCase Initialization Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCExtendedErrors::Init()
{
	if(TCICMDPRPT::Init())
		return TRUE;
	return FALSE;
}


// {{ TCW_VAR_PROTOTYPE(1)
//*-----------------------------------------------------------------------
// @mfunc Valid ICommandProperties calls with previous error object existing.
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCExtendedErrors::Variation_1()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	DBPROPIDSET		pPropertyIDSets;
	DBPROPID		rgPropertyIDs;
	ULONG			cPrpt=0;
	DBPROPSET		*pDBPrpts=NULL;
	BOOL			fTest=FALSE;
	HRESULT			hr;
	
   	//For each method of the interface, first create an error object on
	//the current thread, then try get S_OK from the ICommandProperties method.
	//We then check extended errors to verify nothing is set since an 
	//error object shouldn't exist following a successful call.

	//Verify the property is supported
	if( !VerifySupported(IDX_MAXROWS) ||
		!(g_rgDBProperties[IDX_MAXROWS].fSettable))
		return TEST_SKIPPED;

	//Set a rowset property DBPROP_MAXROWS
	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_ROWSET;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_MAXROWS;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	//create an error object
	m_pExtError->CauseError();
	
	//Set property value to 0
	if(CHECK(hr=m_pICommandProperties->SetProperties(1,&DBPrptSet),S_OK))
		//Do extended check following SetProperties
		fTest = XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);
 	else
	{
		fTest = FALSE;
		goto END;
	}

	//Set value=1  
	DBPrpt.vValue.lVal=1;
	//Call SetProperties with cPropertySets=0, verify SetProperties does not
	//do anything.  Therefore, lVal should stay at 0.
	if(!CHECK(m_pICommandProperties->SetProperties(0,&DBPrptSet),S_OK))
	{
		fTest = FALSE;
		goto END;
	}

	pPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	pPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_MAXROWS;
	pPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//create an error object
	m_pExtError->CauseError();
	
	//Call GetProperties to verify the property is set
	if(CHECK(hr=m_pICommandProperties->GetProperties(1,&pPropertyIDSets,&cPrpt,
			&pDBPrpts),S_OK))
		//Do extended check following GetProperties
		fTest &= XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);	

	if(!COMPARE(pDBPrpts->rgProperties->vValue.lVal, 0))
	{
		fTest = FALSE;
		goto END;
	}

END:
	//Free memory from GetProperties
	FreeProperties(&cPrpt,&pDBPrpts);

	if(fTest)
		return TRUE;
	else
		return FALSE;

}
// }}


// {{ TCW_VAR_PROTOTYPE(2)
//*-----------------------------------------------------------------------
// @mfunc Invalid SetProperties call with previous error object existing
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCExtendedErrors::Variation_2()
{
	BOOL		fTest = FALSE;
	HRESULT		hr;

	//For each method of the interface, first create an error object on
	//the current thread, then try get a failure from the ICommandProperties method.
	//We then check extended errors to verify the right extended error behavior.
  
	//create an error object
	m_pExtError->CauseError();
	
	if(CHECK(hr=m_pICommandProperties->SetProperties(1,NULL),E_INVALIDARG))
 		//Do extended check following SetProperties
		fTest = XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);	

	if(fTest)
		return TEST_PASS;
	else
		return TEST_FAIL;
}
// }}


// {{ TCW_VAR_PROTOTYPE(3)
//*-----------------------------------------------------------------------
// @mfunc Invalid SetProperties call with no previous error object existing
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCExtendedErrors::Variation_3()
{
	DBPROPSET		DBPrptSet; 
	DBPROP			DBPrpt;
	HRESULT			hr;
	BOOL			fTest = FALSE;

	//For each method of the interface, with no error object on
	//the current thread, try get a failure from the ICommandProperties method.
	//We then check extended errors to verify the right extended error behavior.
  
	memset(&DBPrpt ,0, sizeof(DBPROP));
	DBPrptSet.guidPropertySet=DBPROPSET_DATASOURCE;
	DBPrptSet.cProperties=1;
	DBPrpt.dwPropertyID=DBPROP_COMMANDTIMEOUT;
	DBPrpt.dwOptions=DBPROPOPTIONS_REQUIRED;
	DBPrpt.vValue.vt=VT_I4;
	DBPrpt.vValue.lVal=0;
   	DBPrptSet.rgProperties=&DBPrpt;

	if(CHECK(hr=m_pICommandProperties->SetProperties(1,&DBPrptSet),DB_E_ERRORSOCCURRED))
 		//Do extended check following SetProperties
		fTest = XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);	

	//Property is not supported
	if(!COMPARE(DBPrptSet.rgProperties->dwStatus,DBPROPSTATUS_NOTSUPPORTED))
		return TEST_FAIL;

	if(fTest)
		return TEST_PASS;
	else
	   	return TEST_FAIL;

}
// }}


// {{ TCW_VAR_PROTOTYPE(4)
//*-----------------------------------------------------------------------
// @mfunc Invalid GetProperties call with previous error object existing
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCExtendedErrors::Variation_4()
{
	DBPROPIDSET		rgPropertyIDSets; 
	DBPROPID		rgPropertyIDs;
	DBPROPSET		*prgPropertySets=NULL;
	ULONG			cPropertySets;
	BOOL			fTest=FALSE;
	HRESULT			hr;

	//For each method of the interface, first create an error object on
	//the current thread, then try get a failure from the ICommandProperties method.
	//We then check extended errors to verify the right extended error behavior.
  
	rgPropertyIDSets.guidPropertySet=DBPROPSET_ROWSET;
	rgPropertyIDSets.cPropertyIDs=1;
	rgPropertyIDs=DBPROP_AUTH_USERID;
	rgPropertyIDSets.rgPropertyIDs=&rgPropertyIDs;

	//create an error object
	m_pExtError->CauseError();

	if(CHECK(hr=m_pICommandProperties->GetProperties(1,&rgPropertyIDSets,
				&cPropertySets,&prgPropertySets), DB_E_ERRORSOCCURRED))
 		//Do extended check following GetProperties
		fTest = XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);	


	//Property is not supported
	if(!COMPARE(prgPropertySets->rgProperties->dwStatus,DBPROPSTATUS_NOTSUPPORTED))
	{
		fTest = FALSE;
		goto END;
	}

END:
	//Free memory from GetProperties
	FreeProperties(&cPropertySets,&prgPropertySets);

	if(fTest)
		return TRUE;
	else
		return FALSE;
}
// }}


// {{ TCW_VAR_PROTOTYPE(5)
//*-----------------------------------------------------------------------
// @mfunc Invalid GetProperties call with no previous error object existing
//
// @rdesc TEST_PASS or TEST_FAIL
//
int TCExtendedErrors::Variation_5()
{
	ULONG			cPropertySets;
	DBPROPSET		*pPropertySets=NULL;
	HRESULT			hr;
	BOOL			fTest = FALSE;

	//For each method of the interface, with no error object on
	//the current thread, try get a failure from the ICommandProperties method.
	//We then check extended errors to verify the right extended error behavior.
  
	if(CHECK(hr=m_pICommandProperties->GetProperties(1,NULL,
				&cPropertySets,&pPropertySets), E_INVALIDARG))
 		//Do extended check following GetProperties
		fTest = XCHECK(m_pICommandProperties, IID_ICommandProperties, hr);
	
	//When an error occurs *pcPropertySets is set to 0
	if(!COMPARE(cPropertySets, 0))
		fTest = FALSE;

	//When an error occurs *prgPropertySets is a null pointer
	if(!COMPARE(pPropertySets, NULL))
		fTest = FALSE;

	if(fTest)
		return TEST_PASS;
	else
	   	return TEST_FAIL;

}
// }}


// {{ TCW_TERMINATE_METHOD
//--------------------------------------------------------------------
// @mfunc TestCase Termination Routine
//
// @rdesc TRUE or FALSE
//
BOOL TCExtendedErrors::Terminate()
{
	return (TCICMDPRPT::Terminate());

}	// }}
// }}
// }}
