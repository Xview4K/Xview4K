//--------------------------------------------------------------------
// Microsoft OLE DB Test
//
// Copyright 1995-2000 Microsoft Corporation.  
//
// @doc
//
// @module IMDWPAR.H | Header file for ICommandWithParameters test module.
//
// @rev 01 | 02-04-96 | Microsoft | Created
// @rev 02 | 12-01-96 | Microsoft | Updated
//

#ifndef _ICMDWPAR_H_
#define _ICMDWPAR_H_

#include "oledb.h" 			// OLE DB Header Files
#include "oledberr.h"

#include "privlib.h"		//include private library, which includes
#include "stddef.h"			// offsetof

//-----------------------------------------------------------------------------
// Defines
//-----------------------------------------------------------------------------
#define TOTAL_NUMBER_OF_ROWS	30		// Total number of rows in the table.
#define NOT_TOUCHED_ORD			210	// "Not touched" ordinal value
#define NO_LONG_COLS			0
#define INCLUDE_LONG_COLS		1
#define MAX_STD_TYPE_NAME		30	// Max length of a standard type name for SetParameterInfo
#define MAX_STMT_BUF			1024 // Max length for SQL Stmt buffer
#define MAX_MSG_LEN				255
#define MAX_LTOW				33
#define RELCMP_NULL_VARIANT		2	// Since variants may be null internally we need
									// a way to recognize that.

#define OUT_PARAM_STATUS_INVALID	99
#define OUT_PARAM_LENGTH_INVALID	LONG_MAX-5;

#define EXPAND(x)	x, L#x
#define IS_BASE_TYPE(wType, wBaseType)	(((wType) & ~(DBTYPE_ARRAY|DBTYPE_BYREF|DBTYPE_VECTOR)) == (wBaseType))

//-----------------------------------------------------------------------------
// ENUM
//-----------------------------------------------------------------------------
enum SPPARAMETERTYPE_ENUM {
	INPUT_ONLY,
	OUTPUT_ONLY,
	INPUT_OUTPUT,
	RETURN_VALUE_TYPE,
	MAX_NUM_PARAMS,
	MAX_NUM_PARAMSPLUS2,
	DEFAULT_PARAM

};

enum SPDATAVALUES_ENUM {
	VALID_IN_OUT_DATA,
	VALID_IN_NULL_OUT_DATA,
	NULL_IN_VALID_OUT_DATA,
	NULL_IN_OUT_DATA
};

enum SPBINDING_ENUM {
	NULL_STATUS_ONLY,
	STATUS_ONLY,
	LENGTH_VALUE_ONLY,
	VALUE_STATUS_ONLY,
	VALUE_ONLY,
	LENGTH_VALUE_STATUS,
	PASS_BYREF,
	REVERSE_BIND
};

enum SPPARAMNAMES_ENUM {
	NO_PARAMNAMES,
	REGULAR_PARAMNAMES,
	VERY_LONG_PARAMNAMES
};

enum NAME_ENUM {
	ALL_VALID_NAMES,
	ALL_INVALID_NAMES,	// Control characters
	SOME_INVALID_NAMES,	// Odd names are invalid
	ALL_NULL_NAMES,
	ALL_EMPTY_STRING_NAMES
};

//This enumeration represents various objects that can be 
//obtained from Execute. For e.g., TC_Row represents the Test 
//Case which will test getting a ROW object (mostly) from Execute.
enum ETESTCASE
{
	TC_Rowset = 1,				//Getting Rowset
	TC_Row,						//Getting Row
};


const ULONG SP_TEXT_BLOCK_SIZE = 40000;
const ULONG SP_MAX_PARAMNAME_LENGTH = 128;
const ULONG SP_MAX_NUM_PARAMS = 255;

//-----------------------------------------------------------------------------
// String constants
//-----------------------------------------------------------------------------
// These strings are stored procedure statements specific to SQL SERVER (odbc)
// Syntax: drop procedure <procedure name>

// Create stored procedure.
// Syntax: Create procedure <procedure name>
//					<parametername  type [OUTPUT]>,
//					<.......>,
//					<.......>
//			as
//				SQL statements
//				SQL statements
// Returns a rowset.
// Sql statements for TYPEMISMATCH and OVERFLOW test cases.
const WCHAR	g_wszInsertInvalidValue[]		= L"Insert into %s values ( ? )";
const WCHAR	g_wszMultiInsertInvalidValue[]		= L"Insert into %s values ( ?,? )";
const WCHAR	g_wszInsertInvalidChar[]		= L"Insert into %s values ( ? )";
const WCHAR g_wszNotSqlServerOrNoOutParams[]= L"Not running against known provider/dbms or Output parameters or not supported\n";


// ----------------------------------------------------------------------
// All the following variables are for SetParameterInfo::Variation
// Just moved them here so that they won't clutter the variation.
// ----------------------------------------------------------------------
struct tagStdTypes
{
	WCHAR wszStdTypeName[MAX_STD_TYPE_NAME];
	DBTYPE wType;
	DBPARAMBINDINFO rgParamBindInfo[1];
} g_rgStdParamBindInfo[] =
{
	//													Bind info
	// Std Type Name			DBTYPE					  Type	Name ulParamSize dwFlags			bPrecision bScale
	L"DBTYPE_I1",				DBTYPE_I1,				{ NULL, NULL, 1,	DBPARAMFLAGS_ISSIGNED, (BYTE)3, (BYTE)0  },
	L"DBTYPE_I2",				DBTYPE_I2,				{ NULL, NULL, 2,	DBPARAMFLAGS_ISSIGNED, (BYTE)5, (BYTE)0  },
	L"DBTYPE_I4",				DBTYPE_I4,				{ NULL, NULL, 4,	DBPARAMFLAGS_ISSIGNED, (BYTE)10, (BYTE)0  },
	L"DBTYPE_I8",				DBTYPE_I8,				{ NULL, NULL, 8,	DBPARAMFLAGS_ISSIGNED, (BYTE)19, (BYTE)0  },
	L"DBTYPE_UI1",				DBTYPE_UI1,				{ NULL, NULL, 1,	DBPARAMFLAGS_ISSIGNED, (BYTE)3, (BYTE)0  },
	L"DBTYPE_UI2",				DBTYPE_UI2,				{ NULL, NULL, 2,	DBPARAMFLAGS_ISSIGNED, (BYTE)5, (BYTE)0  },
	L"DBTYPE_UI4",				DBTYPE_UI4,				{ NULL, NULL, 4,	DBPARAMFLAGS_ISSIGNED, (BYTE)10, (BYTE)0  },
	L"DBTYPE_UI8",				DBTYPE_UI8,				{ NULL, NULL, 8,	DBPARAMFLAGS_ISSIGNED, (BYTE)19, (BYTE)0  },
	L"DBTYPE_R4",				DBTYPE_R4,				{ NULL, NULL, 4,	DBPARAMFLAGS_ISSIGNED, (BYTE)7, (BYTE)~0  },
	L"DBTYPE_R8",				DBTYPE_R8,				{ NULL, NULL, 8,	DBPARAMFLAGS_ISSIGNED, (BYTE)15, (BYTE)~0  },
	L"DBTYPE_CY",				DBTYPE_CY,				{ NULL, NULL, 8,	DBPARAMFLAGS_ISSIGNED, 19,		    4		},
	L"DBTYPE_DECIMAL",			DBTYPE_DECIMAL,			{ NULL, NULL, 19,	DBPARAMFLAGS_ISSIGNED, (BYTE)28, (BYTE)0  },
	L"DBTYPE_NUMERIC",			DBTYPE_NUMERIC,			{ NULL, NULL, 19,	DBPARAMFLAGS_ISSIGNED, 25,			4		},
	L"DBTYPE_BOOL",				DBTYPE_BOOL,			{ NULL, NULL, 2,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_ERROR",			DBTYPE_ERROR,			{ NULL, NULL, 4,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_UDT",				DBTYPE_UDT,				{ NULL, NULL, 4,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_VARIANT",			DBTYPE_VARIANT,			{ NULL, NULL, sizeof(VARIANT),	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_IDISPATCH",		DBTYPE_IDISPATCH,		{ NULL, NULL, sizeof(IDispatch *),	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_IUNKNOWN",			DBTYPE_IUNKNOWN,		{ NULL, NULL, sizeof(IUnknown *),	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_GUID",				DBTYPE_GUID,			{ NULL, NULL, sizeof(GUID),	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_DATE",				DBTYPE_DATE,			{ NULL, NULL, 6,	DBPARAMFLAGS_ISSIGNED, (BYTE)23, (BYTE)3  },
	L"DBTYPE_DBDATE",			DBTYPE_DBDATE,			{ NULL, NULL, 6,	DBPARAMFLAGS_ISSIGNED, (BYTE)23, (BYTE)3  },
	L"DBTYPE_DBTIME",			DBTYPE_DBTIME,			{ NULL, NULL, 6,	DBPARAMFLAGS_ISSIGNED, (BYTE)23, (BYTE)3  },
	L"DBTYPE_DBTIMESTAMP",		DBTYPE_DBTIMESTAMP,		{ NULL, NULL, 16,	DBPARAMFLAGS_ISSIGNED, (BYTE)23, (BYTE)3  },
	L"DBTYPE_BSTR",				DBTYPE_BSTR,			{ NULL, NULL, 500,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_CHAR",				DBTYPE_STR,				{ NULL, NULL, 50,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_VARCHAR",			DBTYPE_STR,				{ NULL, NULL, 500,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_LONGVARCHAR",		DBTYPE_STR,				{ NULL, NULL, 5000, DBPARAMFLAGS_ISSIGNED|DBPARAMFLAGS_ISLONG, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_WCHAR",			DBTYPE_WSTR,			{ NULL, NULL, 50,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_WVARCHAR",			DBTYPE_WSTR,			{ NULL, NULL, 500,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_WLONGVARCHAR",		DBTYPE_WSTR,			{ NULL, NULL, 5000, DBPARAMFLAGS_ISSIGNED|DBPARAMFLAGS_ISLONG, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_BINARY",			DBTYPE_BYTES,			{ NULL, NULL, 50,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_VARBINARY",		DBTYPE_BYTES,			{ NULL, NULL, 500,	DBPARAMFLAGS_ISSIGNED, (BYTE)~0, (BYTE)~0  },
	L"DBTYPE_LONGVARBINARY",	DBTYPE_BYTES,			{ NULL, NULL, 5000, DBPARAMFLAGS_ISSIGNED|DBPARAMFLAGS_ISLONG, (BYTE)~0, (BYTE)~0  }
};

const ULONG g_cStdParams = NUMELEM(g_rgStdParamBindInfo);


struct tagParamFlags {
	DBPARAMFLAGS dwFlag;
	WCHAR * pwszFlagName;
} g_rgParamFlags[] =
{
	EXPAND(DBPARAMFLAGS_ISINPUT),
	EXPAND(DBPARAMFLAGS_ISOUTPUT),
	EXPAND(DBPARAMFLAGS_ISSIGNED),
	EXPAND(DBPARAMFLAGS_ISNULLABLE),
	EXPAND(DBPARAMFLAGS_ISLONG),
	EXPAND(DBPARAMFLAGS_SCALEISNEGATIVE)
};	


//----------------------------------------------------------------------------------------
// Use our own WCSDUP instead of _wcsdup
//----------------------------------------------------------------------------------------
inline WCHAR *
WCSDUP (IMalloc *pIAlloc, WCHAR * pwszStr)
{
	WCHAR *ptr=NULL;

	// If pwsz is not null.
	if (pwszStr)
	{
		ptr = (WCHAR *)pIAlloc->Alloc(sizeof(WCHAR)*wcslen(pwszStr) + sizeof(WCHAR));
		
		// If ptr is not null copy the string else return NULL;
		if (ptr)
			wcscpy(ptr, pwszStr);
	}
	return ptr;
}

#define MAX_SQL 250
#define MAX_PROVIDER_NAME 100
#define MAX_DBMS_NAME	100
#define MAX_LONG_VALUE	200001L //5000000L	// 5 MBytes
#define BOUNDARY_VALUE	65535L	// 64K
#define MAX_DATA_BUF	MAX_LONG_VALUE+1
#define MAX_COMMAND_BUF	1000
#define FILL_VALUE		0x01
#define MAX_ORDER_LIST	16		// Max number of columns in an order by clause

enum PARAM_OBJECT_TEST
{
	VALID_INPUT_DATA,
	NULL_STORAGE_OBJECT,
	EMPTY_STORAGE_OBJECT,
	NULL_DATA,
	DEFAULT_DATA,
	MULTIPLE_OBJECTS,
	NON_BLOCKING_OBJECTS,
	VALID_OUTPUT_DATA,
	VALID_INOUT_DATA,
	ZOMBIE_OBJECT,
	NULL_POBJECT,
	BADSTORAGEFLAGS,
	NO_VALUE_BINDING
};

// The following error conditions require the stream to
// remain active, that is not be released.
enum ACTIVE_ERROR
{
	INVALIDARG_MULTRES,
	INVALIDARG_NULL_PDATA,
	INVALIDARG_CPARAMSETS_ZERO,
	BADACCESSORHANDLE,
	BADACCESSORTYPE,
	ERRORSOCCURRED,
	NOINTERFACE,
	BADBINDINFO,
	BADORDINAL,
	BADSTORAGEFLAGS_ERR,
	UNSUPPORTEDCONVERSION,
	NOAGGREGATION_OLEDB1,
	NOAGGREGATION_NOT_IUNKOWN,
	NOCOMMAND,
	OBJECTOPEN,
	LAST_ACTIVE_ERROR	// Must remain last enum value
};


enum CREATE_FLAGS
{
	NO_FLAGS=0,
	CREATE_LONG_NAMES=1,	// Param names longer than max
	CREATE_MAX_NAMES=2		// Param names equal max
};

enum COMPARE_OP
{
	CP_EQ,
	CP_GT,
	CP_LT,
	CP_ISNULL,
	CP_ISNOTNULL
};

enum PROVIDER_ENUM 
{
	MSDASQL,
	SQLOLEDB,
	MSDAORA,
	MSDAORA8,
	UNKNOWN_PROVIDER	// This must be the last enum in the list
};

enum DBMS_ENUM 
{
	MS_SQL_SERVER,
	ORACLE,	
//	MS_ACCESS,
	UNKNOWN_DBMS		// This must be the last enum in the list
};

enum VERIFY_ENUM
{
	VERIFY_USE_TABLE,
	VERIFY_USE_PDATA,
	VERIFY_NULL,
	VERIFY_NONE
};

enum ROWSET_ENUM
{
	ROWSET_NONE,
	ROWSET_MAYBE,
	ROWSET_ALWAYS
};

enum DIALECT_ENUM
{
	ORA_SQL,			// ANSI SQL
	SS_SQL,				// SQL Server SQL
	JET_SQL				// JET Engine SQL
};

enum TOKEN_ENUM
{
	T_COL_LIST,
	T_CREATE_PROC,
	T_CREATE_PROC_RET,
	T_CREATE_PROC_INSERT_IN,
	T_CREATE_PROC_SELECT_IN,
	T_CREATE_PROC_SELECT_IN_RET,
	T_CREATE_PROC_SELECT_INOUT,
	T_CREATE_PROC_SELECT_LOOKUP,
	T_CREATE_PROC_SELECT_NO_PARM,
	T_CREATE_PROC_SELECT_OUT,
	T_CREATE_PROC_SELECT_OUT_DFLT,
	T_CREATE_PROC_SELECT_OUT_NULL,
	T_CREATE_PROC_SELECT_OUT_RET,
	T_DATA_VAL,
	T_DEFAULT,
	T_DROP,
	T_DROP_FUN,
	T_DROP_FUNC,
	T_DROP_PROC,
	T_EMPTY,
	T_EQUALS,
	T_EXEC,
	T_EXEC_PROC_DELETE,
	T_EXEC_PROC_DELETE_RET,
	T_EXEC_PROC_INSERT_INPUT,
	T_EXEC_PROC_INSERT_INPUT_RET,
	T_EXEC_PROC_SELECT_IN,
	T_EXEC_PROC_SELECT_IN_RET,
	T_EXEC_PROC_SELECT_INOUT,
	T_EXEC_PROC_SELECT_INOUT_RET,
	T_EXEC_PROC_SELECT_LOOKUP,
	T_EXEC_PROC_SELECT_NO_PARM,
	T_EXEC_PROC_SELECT_OUT,
	T_EXEC_PROC_SELECT_OUT_DFLT,
	T_EXEC_PROC_SELECT_OUT_NULL,
	T_EXEC_PROC_SELECT_OUT_RET,
	T_EXEC_PROC_UPDATE_INPUT,
	T_EXEC_PROC_UPDATE_INPUT_RET,
	T_EXEC_RET,
	T_FIRST_COL_EQ_PARM,
	T_FIRST_PARM,
	T_INTO,
	T_INSERT,
	T_INSERT_IN,
	T_INSERT_IN_MARKER,
	T_LOOKUP_PARM_EQ_LIST,
	T_LOOKUP_PARM_INTO,
	T_LOOKUP_WHERE_EQ,
	T_NO_LONG_COL_LIST,
	T_NO_LONG_COL_ORDER_LIST,
	T_NO_LONG_PARM_DEF_LIST,
	T_NO_LONG_PARM_DEF_LIST_DFLT,
	T_NO_LONG_PARM_DEF_LIST_PAREN,
	T_NO_LONG_PARM_DEF_LIST_DFLT_PAREN,
	T_NO_LONG_PARM_EQ_LIST,
	T_NO_LONG_PARM_LIST,
	T_NO_LONG_PARM_MARKER_EQ_LIST,
//	T_NO_LONG_PARM_MARKER_EQ_LIST_PAREN,
	T_NO_LONG_PARM_MARKER_LIST,
	T_NO_LONG_PARM_MARKER_LIST_PAREN,
	T_NONE,
	T_NULL_COL_LIST,
	T_NULL_PARM_EQ_LIST,
	T_OFFSET_NO_LONG_COL_LIST,
	T_OFFSET_NO_LONG_PARM_EQ_LIST,
	T_OFFSET_NO_LONG_PARM_MARKER_EQ_LIST,
//	T_OFFSET_NO_LONG_PARM_MARKER_EQ_LIST_PAREN,
	T_OFFSET_PARM_INTO,
	T_OFFSET_PARM_INTO_MARKER,
	T_OFFSET_SEARCHABLE_COL_EQ_PARM,
	T_OFFSET_WHERE_EQ,
	T_ORDER,
	T_ORDER_CLAUSE,
	T_ORDER_COL,
	T_PAREN,
	T_PARM_DEF,
	T_PARM_DEF_IN,
	T_PARM_DEF_INOUT,
	T_PARM_DEF_LIST,
	T_PARM_DEF_OUT,
	T_PARM_DEFAULT,
	T_PARM_EQ,
	T_PARM_IN,
	T_PARM_INOUT,
	T_PARM_INTO,
	T_PARM_INTO_MARKER,
	T_PARM_MARKER,
	T_PARM_MARKER_LIST,
	T_PARM_MARKER_LIST_DFLT,
	T_PARM_MARKER_LIST_RET,
	T_PARM_MARKER_LIST_PAREN,
	T_PARM_MARKER_LIST_DFLT_PAREN,
	T_PARM_MARKER_LIST_RET_PAREN,
	T_PARM_NAME,
	T_PARM_NAME_FMT,
	T_PARM_NULL,
	T_PARM_OUT,
	T_PARM_SIZE,
	T_PARM_TYPE,
	T_PROC_NAME,
	T_RET_DEF,
	T_RET_NAME,
	T_RET_TYPE,
	T_RET_TYPE_NAME,
	T_RET_VAL,
	T_ROOT,
	T_SEARCHABLE_COL_EQ,
	T_SEARCHABLE_COL_EQ_PARM,
	T_SEARCHABLE_COL_EQ_PARM_MARKER,
	T_SEARCHABLE_PARM_MARKER_LIST,
	T_SEARCHABLE_PARM_MARKER_LIST_PAREN,
	T_SECOND_COL,
	T_SELECT_IN,
	T_SELECT_IN_MARKER,
	T_SELECT_INOUT,
	T_SELECT_INOUT_MARKER,
	T_SELECT_LOOKUP,
	T_SELECT_NO_PARM,
	T_SELECT_NULL,
	T_SELECT_OUT,
	T_SELECT_OUT_MARKER,
	T_SELECT_OUT_NULL_MARKER,
	T_SELECT_UNIQUE,
	T_SELECT_UNIQUE_ALL,
	T_SELECT_WHERE,
	T_TABLE_NAME,
	T_UNIQUE_NO_LONG_PARM_EQ_LIST,
	T_UNIQUE_SEARCHABLE_COL_EQ_PARM,
	T_UNIQUE_SEARCHABLE_COL_EQ_PARM_MARKER,
	T_UNIQUE_WHERE_EQ,
	T_UNIQUE_WHERE_EQ_MARKER,
	T_UPDATABLE_COL_LIST,
	T_UPDATABLE_PARM_DEF_LIST,
	T_UPDATABLE_PARM_DEF_LIST_PAREN,
	T_UPDATABLE_PARM_LIST,
	T_UPDATABLE_PARM_MARKER_LIST,
	T_UPDATABLE_PARM_MARKER_LIST_PAREN,
	T_WHERE,
	T_WHERE_ALL,
	T_WHERE_EQ,
	T_WHERE_EQ_MARKER
};

typedef struct tagDialect
{
	enum PROVIDER_ENUM eProvider;
	enum DBMS_ENUM eDBMS;
	enum DIALECT_ENUM eDialect;
} Dialects;

const Dialects g_Dialects[] = 
{
	MSDAORA,			ORACLE,			ORA_SQL,
	MSDAORA8,			ORACLE,			ORA_SQL,
//	MSDASQL,			MS_ORACLE,		ORA_SQL,
	MSDASQL,			MS_SQL_SERVER,	SS_SQL,	
	SQLOLEDB,			MS_SQL_SERVER,	SS_SQL,
//	MSDASQL,			MS_ACCESS,		JET_SQL,
//	JOLT,				MS_ACCESS,		JET_SQL
	UNKNOWN_PROVIDER,	UNKNOWN_DBMS,	ORA_SQL	// This must be the last enum in the list
};

typedef struct tagDialectTokens
{
	enum DIALECT_ENUM eDialect;			// Dialect in use
	enum TOKEN_ENUM eToken;				// The token we want
	ULONG cTokens;						// Made up of this number of other tokens
	enum TOKEN_ENUM rgeTokens[20];		// Other tokens in proper order
	WCHAR * pwszTokenString;			// String for this token or NULL if none
} DialectTokens;

const DialectTokens g_DialectTokens[] =
{
//										Token
//	Dialect		String to create		Count	Token list, or required string.  NULL for root token we know how to build

	// Syntax items we need to be able to create for testing

	// For testing input and output params in same proc
	ORA_SQL,	T_CREATE_PROC_SELECT_OUT,	4,	{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_OUT}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_OUT,		3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_PAREN}, NULL,
	ORA_SQL,	T_SELECT_OUT_MARKER,		4,	{T_SELECT_WHERE, T_TABLE_NAME, T_PARM_INTO_MARKER, T_WHERE_EQ_MARKER}, NULL,

	// For testing no params
	ORA_SQL,	T_CREATE_PROC_SELECT_NO_PARM,4,	{T_CREATE_PROC, T_PROC_NAME, T_EMPTY, T_SELECT_NO_PARM}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_NO_PARM,	3,	{T_EXEC, T_PROC_NAME, T_EMPTY}, NULL,
//	ORA_SQL,	T_SELECT_NO_PARM,			4,	{T_SELECT_WHERE, T_TABLE_NAME, T_COL_LIST, T_EMPTY}, NULL,

	// For testing input only params
	ORA_SQL,	T_CREATE_PROC_SELECT_IN,	4,	{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_IN}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_IN,		3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_PAREN}, NULL,
	ORA_SQL,	T_SELECT_IN_MARKER,			4,	{T_SELECT_WHERE, T_TABLE_NAME, T_COL_LIST, T_WHERE_EQ_MARKER}, NULL,

	// For testing in/out params
	ORA_SQL,	T_CREATE_PROC_SELECT_INOUT,	4,	{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_INOUT}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_INOUT,	3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_PAREN}, NULL,
	ORA_SQL,	T_SELECT_INOUT_MARKER,		5,	{T_SELECT_UNIQUE, T_TABLE_NAME, T_PARM_INTO_MARKER, T_UNIQUE_WHERE_EQ_MARKER, T_NO_LONG_COL_ORDER_LIST}, NULL,

	// For testing return params
	ORA_SQL,	T_CREATE_PROC_SELECT_OUT_RET,6,	{T_CREATE_PROC_RET, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_OUT, T_RET_TYPE, T_RET_VAL}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_OUT_RET,	4,	{T_EXEC_RET, T_PROC_NAME, T_PARM_MARKER_LIST_RET_PAREN, T_PARM_MARKER}, NULL,

	// For proving we can return a NULL on top of a valid input param
	ORA_SQL,	T_CREATE_PROC_SELECT_LOOKUP,4,	{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_LOOKUP}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_LOOKUP,	3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_PAREN}, NULL,

	// For proving we can return a NULL when status-only is bound
	ORA_SQL,	T_CREATE_PROC_SELECT_OUT_NULL,4,{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_NULL}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_OUT_NULL,3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_PAREN}, NULL,
	ORA_SQL,	T_SELECT_OUT_NULL_MARKER,	4,	{T_SELECT_WHERE, T_TABLE_NAME, T_PARM_INTO_MARKER, T_WHERE_EQ_MARKER}, NULL,
	
	// For testing input and output params in same proc using a default param
	ORA_SQL,	T_CREATE_PROC_SELECT_OUT_DFLT,4,{T_CREATE_PROC, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_DFLT_PAREN, T_SELECT_OUT}, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_OUT_DFLT,3,	{T_EXEC, T_PROC_NAME, T_PARM_MARKER_LIST_DFLT_PAREN}, NULL,
	// Can't have default params in a statement, only a procedure.
//	ORA_SQL,	T_SELECT_OUT_MARKER_DFLT,		4,	{T_SELECT_WHERE, T_TABLE_NAME, T_PARM_INTO_MARKER, T_WHERE_EQ_MARKER}, NULL,

	// For testing of insert statements
	ORA_SQL,	T_CREATE_PROC_INSERT_IN,	4,	{T_CREATE_PROC, T_PROC_NAME, T_UPDATABLE_PARM_DEF_LIST_PAREN, T_INSERT_IN}, NULL,
	ORA_SQL,	T_EXEC_PROC_INSERT_INPUT,	3,	{T_EXEC, T_PROC_NAME, T_UPDATABLE_PARM_MARKER_LIST_PAREN}, NULL,
	ORA_SQL,	T_INSERT_IN_MARKER,			4,	{T_INSERT, T_TABLE_NAME, T_UPDATABLE_COL_LIST, T_UPDATABLE_PARM_MARKER_LIST}, NULL,

	// To drop the procedure or function when done
	ORA_SQL,	T_DROP_PROC,				2,	{T_DROP, T_PROC_NAME}, NULL,
	ORA_SQL,	T_DROP_FUNC,				2,	{T_DROP_FUN, T_PROC_NAME}, NULL,


/*
	// TODO: Add logic for create proc, stmt with markers, etc, for the following types
	ORA_SQL,	T_EXEC_PROC_UPDATE_INPUT,	?,	{?, ?, }, NULL,
	ORA_SQL,	T_EXEC_PROC_DELETE_INPUT,	?,	{?, ?, }, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_BETWEEN,	?,	{?, ?, }, NULL,
	ORA_SQL,	T_EXEC_PROC_SELECT_IN,		?,	{?, ?, }, NULL,
*/

	// Partial strings used to build up other strings
	ORA_SQL,	T_SELECT_OUT,				4,	{T_SELECT_WHERE, T_TABLE_NAME, T_PARM_INTO, T_WHERE_EQ}, NULL,
	ORA_SQL,	T_SELECT_NULL,				4,	{T_SELECT_WHERE, T_TABLE_NAME, T_PARM_NULL, T_WHERE_EQ}, NULL,
	ORA_SQL,	T_SELECT_NO_PARM,			4,	{T_SELECT_WHERE, T_TABLE_NAME, T_COL_LIST, T_ORDER_CLAUSE}, NULL,
	ORA_SQL,	T_SELECT_IN,				4,	{T_SELECT_WHERE, T_TABLE_NAME, T_COL_LIST, T_WHERE_EQ}, NULL,
	ORA_SQL,	T_SELECT_INOUT,				5,	{T_SELECT_UNIQUE, T_TABLE_NAME, T_PARM_INTO, T_UNIQUE_WHERE_EQ, T_NO_LONG_COL_ORDER_LIST}, NULL,
	ORA_SQL,	T_SELECT_LOOKUP,			4,	{T_SELECT_WHERE, T_TABLE_NAME, T_LOOKUP_PARM_INTO, T_LOOKUP_WHERE_EQ}, NULL,
	ORA_SQL,	T_SELECT_UNIQUE_ALL,		5,	{T_SELECT_UNIQUE, T_TABLE_NAME, T_NO_LONG_COL_LIST, T_WHERE_ALL, T_NO_LONG_COL_ORDER_LIST}, NULL,
	ORA_SQL,	T_WHERE_EQ,					2,	{T_WHERE, T_SEARCHABLE_COL_EQ_PARM},NULL,
	ORA_SQL,	T_LOOKUP_WHERE_EQ,			2,	{T_WHERE, T_FIRST_COL_EQ_PARM},NULL,
	ORA_SQL,	T_OFFSET_WHERE_EQ,			2,	{T_WHERE, T_OFFSET_SEARCHABLE_COL_EQ_PARM},NULL,
	ORA_SQL,	T_UNIQUE_WHERE_EQ,			2,	{T_WHERE, T_UNIQUE_SEARCHABLE_COL_EQ_PARM},NULL,
	ORA_SQL,	T_WHERE_EQ_MARKER,			2,	{T_WHERE, T_SEARCHABLE_COL_EQ_PARM_MARKER},NULL,
	ORA_SQL,	T_UNIQUE_WHERE_EQ_MARKER,	2,	{T_WHERE, T_UNIQUE_SEARCHABLE_COL_EQ_PARM_MARKER},NULL,
	ORA_SQL,	T_PARM_INTO,				3,	{T_INTO, T_NO_LONG_COL_LIST, T_NO_LONG_PARM_LIST}, NULL,
	ORA_SQL,	T_PARM_NULL,				3,	{T_INTO, T_NULL_COL_LIST, T_NO_LONG_PARM_LIST}, NULL,
	ORA_SQL,	T_LOOKUP_PARM_INTO,			3,	{T_INTO, T_SECOND_COL, T_FIRST_PARM}, NULL,
	ORA_SQL,	T_OFFSET_PARM_INTO,			3,	{T_INTO, T_OFFSET_NO_LONG_COL_LIST, T_NO_LONG_PARM_LIST}, NULL,
	ORA_SQL,	T_PARM_INTO_MARKER,			3,	{T_INTO, T_NO_LONG_COL_LIST, T_NO_LONG_PARM_MARKER_LIST}, NULL,
	ORA_SQL,	T_OFFSET_PARM_INTO_MARKER,	3,	{T_INTO, T_OFFSET_NO_LONG_COL_LIST, T_NO_LONG_PARM_MARKER_LIST}, NULL,
	ORA_SQL,	T_PARM_DEF_IN,				5,	{T_PARM_DEF, T_PARM_NAME, T_PARM_IN, T_PARM_TYPE, T_DEFAULT}, NULL,
	ORA_SQL,	T_PARM_DEF_OUT,				5,	{T_PARM_DEF, T_PARM_NAME, T_PARM_OUT, T_PARM_TYPE, T_EMPTY}, NULL, 
	ORA_SQL,	T_PARM_DEF_INOUT,			5,	{T_PARM_DEF, T_PARM_NAME, T_PARM_INOUT, T_PARM_TYPE, T_EMPTY}, NULL,
	ORA_SQL,	T_DEFAULT,					2,	{T_PARM_DEFAULT, T_DATA_VAL}, NULL,
	ORA_SQL,	T_UPDATABLE_PARM_DEF_LIST_PAREN,2,	{T_PAREN, T_UPDATABLE_PARM_DEF_LIST}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_DEF_LIST_PAREN,	2,	{T_PAREN, T_NO_LONG_PARM_DEF_LIST}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_DEF_LIST_DFLT_PAREN,2,	{T_PAREN, T_NO_LONG_PARM_DEF_LIST_DFLT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_MARKER_LIST_PAREN, 2,	{T_PAREN, T_NO_LONG_PARM_MARKER_LIST}, NULL,
//	ORA_SQL,	T_NO_LONG_PARM_MARKER_EQ_LIST_PAREN,2,{T_PAREN, T_NO_LONG_PARM_MARKER_EQ_LIST}, NULL,
//	ORA_SQL,	T_OFFSET_NO_LONG_PARM_MARKER_EQ_LIST_PAREN ,2,{T_PAREN, T_OFFSET_NO_LONG_PARM_MARKER_EQ_LIST}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST_PAREN,			2,	{T_PAREN, T_PARM_MARKER_LIST}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST_DFLT_PAREN,	2,	{T_PAREN, T_PARM_MARKER_LIST_DFLT}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST_RET_PAREN,		2,	{T_PAREN, T_PARM_MARKER_LIST_RET}, NULL,
	ORA_SQL,	T_SEARCHABLE_PARM_MARKER_LIST_PAREN,2,{T_PAREN, T_SEARCHABLE_PARM_MARKER_LIST}, NULL,
	ORA_SQL,	T_UPDATABLE_PARM_MARKER_LIST_PAREN,2,	{T_PAREN, T_UPDATABLE_PARM_MARKER_LIST}, NULL,
	ORA_SQL,	T_ORDER_CLAUSE,				2,	{T_ORDER, T_ORDER_COL}, NULL,
	ORA_SQL,	T_INSERT_IN,				4,	{T_INSERT, T_TABLE_NAME, T_UPDATABLE_COL_LIST, T_UPDATABLE_PARM_LIST}, NULL,

	// Root syntax that is merely returned and not composed of other tokens
	ORA_SQL,	T_WHERE,					0,	{T_ROOT}, L"where %1",
	ORA_SQL,	T_WHERE_ALL,				0,	{T_ROOT}, L"where 1=1",
	ORA_SQL,	T_SELECT_WHERE,				0,	{T_ROOT}, L"select %2 from %1 %3",
	ORA_SQL,	T_SELECT_UNIQUE,			0,	{T_ROOT}, L"select distinct %2 from %1 %3 order by %4",
	ORA_SQL,	T_CREATE_PROC,				0,	{T_ROOT}, L"create procedure %1%2 as begin %3; end;",
	ORA_SQL,	T_CREATE_PROC_RET,			0,	{T_ROOT}, L"create function %1%2 return %4 as begin %3; return(%5); end;",
	ORA_SQL,	T_INTO,						0,	{T_ROOT}, L"%1 into %2",
	ORA_SQL,	T_INSERT,					0,	{T_ROOT}, L"insert into %1(%2) values (%3)",
	ORA_SQL,	T_EQUALS,					0,	{T_ROOT}, L"%1 = %2",
	ORA_SQL,	T_PARM_NAME_FMT,			0,	{T_ROOT}, L"%1",
	ORA_SQL,	T_PARM_MARKER,				0,	{T_ROOT}, L"?",
	ORA_SQL,	T_EXEC,						0,	{T_ROOT}, L"{call %1 %2}",
	ORA_SQL,	T_EXEC_RET,					0,	{T_ROOT}, L"{%3=call %1 %2}",
	ORA_SQL,	T_DROP,						0,	{T_ROOT}, L"drop procedure %1",
	ORA_SQL,	T_DROP_FUN,					0,	{T_ROOT}, L"drop function %1",
	ORA_SQL,	T_PARM_DEF,					0,	{T_ROOT}, L"%1 %2 %3 %4",
	ORA_SQL,	T_PARM_IN,					0,	{T_ROOT}, L"IN",
	ORA_SQL,	T_PARM_OUT,					0,	{T_ROOT}, L"OUT",
	ORA_SQL,	T_PARM_INOUT,				0,	{T_ROOT}, L"IN OUT",
	ORA_SQL,	T_RET_NAME,					0,	{T_ROOT}, L"RETURN_VALUE",
	ORA_SQL,	T_RET_TYPE_NAME,			0,	{T_ROOT}, L"DBTYPE_CHAR",
	ORA_SQL,	T_PARM_DEFAULT,				0,	{T_ROOT}, L":= %1",
	ORA_SQL,	T_PAREN,					0,	{T_ROOT}, L"(%1)",
	ORA_SQL,	T_ORDER,					0,	{T_ROOT}, L"order by %1",
	ORA_SQL,	T_EMPTY,					0,	{T_ROOT}, L" ",

	// Provider specific syntax
	SS_SQL,		T_SELECT_OUT,				4,	{T_SELECT_WHERE, T_TABLE_NAME, T_NO_LONG_PARM_EQ_LIST, T_WHERE_EQ}, NULL,
	SS_SQL,		T_SELECT_NULL,				4,	{T_SELECT_WHERE, T_TABLE_NAME, T_NULL_PARM_EQ_LIST, T_WHERE_EQ}, NULL,
	SS_SQL,		T_SELECT_INOUT,				5,	{T_SELECT_UNIQUE, T_TABLE_NAME, T_NO_LONG_PARM_EQ_LIST, T_UNIQUE_WHERE_EQ, T_NO_LONG_COL_ORDER_LIST}, NULL,
	SS_SQL,		T_SELECT_LOOKUP,			4,	{T_SELECT_WHERE, T_TABLE_NAME, T_LOOKUP_PARM_EQ_LIST, T_LOOKUP_WHERE_EQ}, NULL,
	SS_SQL,		T_SELECT_INOUT_MARKER,		5,	{T_SELECT_UNIQUE, T_TABLE_NAME, T_NO_LONG_PARM_MARKER_EQ_LIST, T_UNIQUE_WHERE_EQ_MARKER, T_NO_LONG_COL_ORDER_LIST}, NULL,
	SS_SQL,		T_SELECT_OUT_MARKER,		4,	{T_SELECT_WHERE, T_TABLE_NAME, T_NO_LONG_PARM_MARKER_EQ_LIST, T_WHERE_EQ_MARKER}, NULL,
	SS_SQL,		T_PARM_NAME_FMT,			0,	{T_ROOT}, L"@%1",
	SS_SQL,		T_PARM_DEF,					0,	{T_ROOT}, L"%1 %2%3%4 %5", 
	SS_SQL,		T_PARM_DEF_IN,				6,	{T_PARM_DEF, T_PARM_NAME, T_PARM_TYPE, T_PARM_SIZE, T_DEFAULT, T_PARM_IN}, NULL,
	SS_SQL,		T_PARM_DEF_OUT,				6,	{T_PARM_DEF, T_PARM_NAME, T_PARM_TYPE, T_PARM_SIZE, T_DEFAULT, T_PARM_OUT}, NULL,
	SS_SQL,		T_PARM_DEF_INOUT,			6,	{T_PARM_DEF, T_PARM_NAME, T_PARM_TYPE, T_PARM_SIZE, T_DEFAULT, T_PARM_INOUT}, NULL,
	SS_SQL,		T_PARM_IN,					0,	{T_ROOT}, L"",
	SS_SQL,		T_PARM_OUT,					0,	{T_ROOT}, L"OUTPUT",
	SS_SQL,		T_PARM_INOUT,				0,	{T_ROOT}, L"OUTPUT",
	SS_SQL,		T_CREATE_PROC_RET,			0,	{T_ROOT}, L"create procedure %1%2 as begin %3 return(%4) end",
	SS_SQL,		T_DROP_FUN,					0,	{T_ROOT}, L"drop procedure %1",
	SS_SQL,		T_CREATE_PROC_SELECT_OUT_RET,5,	{T_CREATE_PROC_RET, T_PROC_NAME, T_NO_LONG_PARM_DEF_LIST_PAREN, T_SELECT_OUT, T_RET_VAL}, NULL,
	SS_SQL,		T_RET_TYPE_NAME,			0,	{T_ROOT}, L"DBTYPE_I4",
	SS_SQL,		T_LOOKUP_PARM_EQ_LIST,		3,	{T_EQUALS, T_FIRST_PARM, T_SECOND_COL}, NULL,
	SS_SQL,		T_PARM_DEFAULT,				0,	{T_ROOT}, L"= %1",
	SS_SQL,		T_RET_NAME,					0,	{T_ROOT}, L"@RETURN_VALUE",

	JET_SQL,	T_DROP,						0,	{T_ROOT}, L"drop table \"%1\"",

	// Special strings we know how to create given the table and possibly the bindings
	ORA_SQL,	T_SEARCHABLE_COL_EQ,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_UPDATABLE_COL_LIST,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_COL_LIST,					0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NULL_COL_LIST,			0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_COL_LIST,			0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_COL_ORDER_LIST,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_OFFSET_NO_LONG_COL_LIST,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_LIST,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_DEF_LIST,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_DEF_LIST_DFLT,0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_MARKER_LIST, 0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_MARKER_EQ_LIST,0,{T_ROOT}, NULL,
	ORA_SQL,	T_OFFSET_NO_LONG_PARM_MARKER_EQ_LIST,0,{T_ROOT}, NULL,
	ORA_SQL,	T_NO_LONG_PARM_EQ_LIST,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_NULL_PARM_EQ_LIST,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_OFFSET_NO_LONG_PARM_EQ_LIST,0,{T_ROOT}, NULL,
	ORA_SQL,	T_UNIQUE_NO_LONG_PARM_EQ_LIST,0,{T_ROOT}, NULL,
	ORA_SQL,	T_SEARCHABLE_COL_EQ_PARM,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_OFFSET_SEARCHABLE_COL_EQ_PARM,0,{T_ROOT}, NULL,
	ORA_SQL,	T_UNIQUE_SEARCHABLE_COL_EQ_PARM,0,{T_ROOT}, NULL,
	ORA_SQL,	T_SEARCHABLE_COL_EQ_PARM_MARKER,0,{T_ROOT},NULL,
	ORA_SQL,	T_UNIQUE_SEARCHABLE_COL_EQ_PARM_MARKER,0,{T_ROOT},NULL,
	ORA_SQL,	T_PROC_NAME,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_NAME,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_TYPE,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_SIZE,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_TABLE_NAME,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST,			0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST_DFLT,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_PARM_MARKER_LIST_RET,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_SEARCHABLE_PARM_MARKER_LIST,0,{T_ROOT}, NULL,
	ORA_SQL,	T_UPDATABLE_PARM_MARKER_LIST,0,	{T_ROOT}, NULL,
	ORA_SQL,	T_UPDATABLE_PARM_DEF_LIST,	0,	{T_ROOT}, NULL,
	ORA_SQL,	T_UPDATABLE_PARM_LIST,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_RET_DEF,					0,	{T_ROOT}, NULL,
	ORA_SQL,	T_RET_TYPE,					0,	{T_ROOT}, NULL,
	ORA_SQL,	T_RET_VAL,					0,	{T_ROOT}, NULL,
	ORA_SQL,	T_SECOND_COL,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_FIRST_PARM,				0,	{T_ROOT}, NULL,
	ORA_SQL,	T_FIRST_COL_EQ_PARM,		0,	{T_ROOT}, NULL,
	ORA_SQL,	T_DATA_VAL,					0,	{T_ROOT}, NULL,
	ORA_SQL,	T_ORDER_COL,				0,	{T_ROOT}, NULL
};

typedef struct tagProviderList
{
	enum PROVIDER_ENUM eProvider;
	WCHAR wszProviderName[MAX_PROVIDER_NAME];
} ProviderList;

const ProviderList g_ProviderList[] = 
{
	// MSDASQL, L"Microsoft OLE DB Provider for ODBC Drivers",		// Kagera 1.1
	MSDASQL,	L"MSDASQL.DLL",										// Chinook (Kagera 1.5)
	SQLOLEDB,	L"sqloledb.dll",
	MSDAORA,	L"MSDAORA.DLL",
	MSDAORA8,	L"MSDAORA8.DLL"
};

typedef struct tagDBMSList 
{
	enum DBMS_ENUM eDBMS;
	WCHAR wszDBMSName[MAX_DBMS_NAME];
} DBMSList;

const DBMSList g_DBMSList[] = 
{
	MS_SQL_SERVER,	L"Microsoft SQL Server",
	ORACLE,			L"Oracle",
//	MS_ACCESS,		L"ACCESS",
};

#endif 	//_ICMDWPAR_H_
